"use strict";(globalThis.webpackChunkcomputer_architecture=globalThis.webpackChunkcomputer_architecture||[]).push([[5369],{2093:(e,a,n)=>{n.d(a,{A:()=>t});const t="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPUAAADNCAIAAADv+qHyAAAQAElEQVR4AeydC5BO5R/Hd5I7MW6tLi5bwmaUmShGZpQpJWwxNP8Vw5oYmrZBReSylWqaFuW2xWgapnSZMBr9G8VkpyhDq0n0D0lEyGURNuP/mZ4683p3nXd33z3vOc8533d+c/o9l/M8v+f7+z6/53LIFRf1EwLhReCKNP2EQHgREL/D61uNLC1N/BYLwoyA+B1m72ps4newOSDrkkNA/E4OP70dbATE72D7R9Ylh4D4nRx+ejvYCIjfwfaPrEsOAfE7Ofz0drAR8JrfwR69rAs7AuJ32D0c7fGJ39H2f9hHL36H3cPRHp/4HW3/h3304nfYPew+vrCXit9h93C0xyd+R9v/YR+9+B12D0d7fOJ3tP0f9tGL32H3cLTHZzu/o+09jT4RAuJ3IoRUbjMC4rfN3pPtiRAQvxMhpHKbERC/bfaebE+EgPidCCGVJ4OA3++K3357QP17iYD47SW6attvBMRvvz2g/r1EQPz2El217TcC4rffHlD/XiIgfrujq1K7ERC/7fafrHdHQPx2x0eldiMgftvtP1nvjoD47Y6PSu1GQPy2239Rtz7R+MXvRAip3GYExG+bvSfbEyEgfidCSOU2IyB+2+w92Z4IAfE7EUIqtxkB8dtf76l3bxEQv73FV637i4D47S/+6t1bBMRvb/FV6/4iIH77i7969xYB8dtbfNW6vwgky29/rVfvQsAdgejy+2wofu7eVWlE+V1cXHzdddfVtvzXtWtXMdgdgYjyG1AyMjKOHDly0dpfUVFR9erVGYjEBYHo8htQSkpKeFoq586ds9TyVJodaX6nEmif+op6t+J31BkQ7vGL3+H2b9RHJ35HnQHhHr/4HW7/Rn104nfUGRDu8Qed3+FGX6PzGgHx22uE1b6fCIjffqKvvr1GQPz2GmG17ycC4ref6KtvrxEQv71GONztB3104vclHtq5c+d7//7WrVt39OjRS4pTniguLsaGs2fPprznkHQofl/iyE8++WT69On79u3btWvX22+/3bp168WLF19SI1UJmD1t2rQePXrceeedPXv29MuMVA3Xq34qzO+SkpK9e/diDk98gIIQ9niS/ObvH0UkEUeh6ODBg4Qiyrdt22aeFy5coE6gpGbNmvfcc8/48eMnTZq0ZMmSPXv2jBw58quvvkqxkQTsIUOGHD9+fMWKFRs2bCgoKFi0aBF0T7EZ5e8OR69Zs4aneQVHI0YnE844Tsf15MAHFARWONWMQhHvkk+p81alqVJhfp88efLxxx/HlFmzZuEDFKRXr148CwsL58yZs3///vz8fBZ5bJo8eTJjowiiLFiw4NSpUyjjxo378ssvd+/ebYooDaw0btx4+fLlGJxiC9ka/fLLL4DZsmVLbOjYsePq1avz8vJgRootKU93MBtHU5Olb9myZSjMSVZCFAS2wFdYAVlHjRoFAU6cOPHZZ58tXbqUTCYtr0OVrKwsKiOwiFlNHUoHDBjAW1CF/MpJhflNN/Xr1+d59dVX33rrrZiC3qRJE57Ifffdh6E4Bn6fOXOmbt26ZBqpVasW3ho0aNDtt9/eu3dvqpFjilL/LP/ffGnXrt3GjRtTbCHkAKjYTmE5C8vWrVtjM6tVq0YScqRY6NQRun7kkUcgK65nxYPi5FDqIAxb0Cnt06cPrmdcTNfz589DAGTu3LnMWwbCAHkLgRVI27ZtKaX+0KFDUahAUSWkMvw23bCGjhgxAvsIwwyATMz68ccfmXALFy7s2rVrnTp1yCxTYv/uCa+zAWAxSqVAFPpNS0sr0zzfMwl4LVq0iDOjVatWrNqxmUy8/v3735va37BhwwyDjSVsoohWRucJfX/66Se2eeiOOFBfvHjRZNaoUYM9LVSZP38+DZrM0s+zf/9K55c/p/L8Nn3MmzfvySefbN68uUniAFYT4jRbWDOqK674pwtMNXXinmx4cNB/UvsbM2YMh8g4S8pMQrUy8z3NJF6wDY3r4vTp08TC2Mz27dtPmTLludT+cnNzY6MpTMXpjlUHDhxo0KCBk3RRwB+qEMtHjx4dx424pEsjCYv+IV/CeperwDrCeFatWkUFzOrSpQurCYsRScI5txCHDx9GZ8PdqVMnlNLCwgTF/5fa3+bNm9u0aVPamNI5TODZs2eXzvc0p0OHDps2bYrtgpDJ1vamm26KzaxXr17nzp1ZKlMp9BhrA1MOupuDAUTH7PT0dPareJxqUILM2G0qmQj7k+7du0MVroZI0gJxhMro69evz8jIQKkSqQy/b775ZvpmATXL0NSpU/v160dOw4YNISuKI9xqcaSAScSevn37mvzrr7+eKWF0v56cDWBMmb1zssElOIxdEwfooqKixx57rMya3mUOHDjwrbfewgCnizfffPPGG2+M45ZT6q+ycuXKmTNn4tYJEybAb4zBTiQzMxP6ctnAHCCTRckhbtOmTWELmUYo4iBHZajSqFEjFJMP0ygyeuWeFeY3DObujM5ycnKYqShMPkaIQhRhRqI4wkaFIkIz2xWqmXzWI/KNHrQn4H777besPwyEyM28xXjH8pRZCz7Ev27durFz42oCr3NFuGXLlpQZUKGOWKgxj/0Gp0xDZV7Pzs7evn07U5QdCEkE5rC3QUFgMGxBcYQhUxm0nToUzZgxg8ZRKi0V5nele7LiRY5HHD2N4C2SfpmN+//66y+CCKFx7dq1mORQxy+T/Og32T7F72QR9O591g0mGPzm5oQozgruXV9hbVn8Drpn2Q3u2LGDvey1114bdFuDZ5/4HTyflLKISyq2s5zYSpUoIwEC4ncCgFRsNQLit9Xuk/EJEBC/EwCUZLFe9xcB8dtf/NW7twiI397iq9b9RUD89hd/9e4tAuK3t/iqdX8REL/9xV+9e4tAIn5727taFwLeIiB+e4uvWvcXAfHbX/zVu7cIiN/e4qvW/UVA/PYXf/XuLQLit7f4et262ndHQPx2x0eldiMgftvtP1nvjoD47Y6PSu1GQPy223+y3h0B8dsdH5XajYDf/LYbPVkfdATE76B7SPYlg4D4nQx6ejfoCIjfQfeQ7EsGAfE7GfT0btAREL+D7iF/7bO9d/Hbdg/KfjcExG83dFRmOwLit+0elP1uCIjfbuiozHYExG/bPSj73RAIO7/dxq6y8CMgfoffx1EeofgdZe+Hf+zid/h97PUIn3jiCbrYtm3bqFGjUJA1a9aQXLFiBU+SCDnffPPNunXrcnNzp02bNnny5IMHD5LkFXSkuLiY+ihDhgzh+eqrr549e3b48OGmMkVUMJXpjiRtlkcize8k/23F8uBb0Tp79+7F619d/kfp0aNHK9qsp/U//vhj2seqd955xzDvwIEDJDMyMj788EOKkGXLlpHcvXt3VlbW1KlTn3322fT0dJPMy8t74IEH5s6dS9H06dO///57csaOHXv69OkaNWqYyn379v3jjz9q167Ni8iuXbvee+89mk0oEeX3+fPnjx07hjMIEgkxSmWFrVu3PvPMM7j5ckLp/v37U2lSwr7q1atHHZBctGjRkiVLUMw/WtmxY8eNGzeSZNI2adKkcePGVIP6v/7666FDh9DT0tKIyocPH963b1+LFi3IIeIg1apVMy1AcSrzeklJSc2aNalAPu1kZ2ezIJBMKBHlN7jgFeJNjx49iIgkAyLEMGL3fy//oxTeBMTaODNg4Wuvvfb000/XrVvXFN1///3ffffdpk2b7r33XpOzffv2wsJCckhC1lWrVr3++uuLFy+GsuTECXsYKuOg48ePxxYxBwjtsTmX06PLbxBZvnz5yy+/zFI4cODAnTt3khMcuXDhAssLm9H+/fuz72TzGhzbXCxp2bJlw4YNieJwl2q9e/deu3YtsbZ79+4kmQCDBw+GyoMGDSJJaAf8F154gWnAvCUnTjp06EDl0aNHs5k5d+6cM23Y2LBXiatcZrIq+Y25jARBoTOWFVYfFCMQCJ+hc+aIzSfHFwEv4O7Zs+eWLVt69erVrl07jjLsGn0xpnSn7DuZezk5Oc8999zdd9/dpUuXcu44Szfldc6pU6dMF8bvWE5UNjlt27Zdv379NddcU79+fXKIu8QU9uILFy4kNpNjXmHVevfdd0kiTmvohHkqE90J4exPNm/ejD5nzpz58+dPnDiRCgmlyvgNZeGK6Y/jAsobb7zBZgsFgdkvvfQSfIL9jLBOnTpkBkSINESII0eOnDhxgm0iCGKnv7YRzAoKCj799FMgZTdCtNuxYweRLzjTLxaf1atXkyRC9+nTB4Xd888//0zoRUegwbhx41CQrKwsuMFB85ZbbiEYk7ztttvIJ+qPGTMGBfnoo494IqwD7HaonJmZyQxp2rTpK6+8gg4mbPSJ6NRJKFXGb86/+fn59/39g8F0fOWVV/J0pEGDBriNjSXrERA4+SiwP8VCp8QDno5wapk9ezY0IkyCPgHDKUq9AmPYk5iYZ3onEN5xxx1ff/21SZqngTHF0NGd6d15Yhs61jqcg68kyUTQwRYFQen6748KJHmSj5hGYhVG17lzZ1OdUpJMdZI80alZHqkyfrMMOVMWu0v3vWfPHs7+cCiuiMDP1GcHlkoZMWIEZ/Y4S0iCIzOQy9e77rqLTblZPcm/rHhTwNaOuBXXNn4lPzaT2wl256nEjWPiyJEjS1M81qpA6VXG71atWnFDacZW5vhbt2798MMPs/EydZwn2wMC/+WuwzzK5xtBs2bNHBtiFRYZ5iFbXvaR2BZb5LvO/jXWhvbt20+ZMsUjiMpslsMAG4nyh89Ya33Rq4zfTGs+O5kxPPTQQ0Rlo/M0dP/zzz+BhhtNNrhkOoLPWHRSLGbb59hgFKIjMbtbt24zZ87k1E+8NPmpf95www1cq8X2C4YbNmyIC+pccToreMoApMdYwwKuVxm/GTaHfVDmLoKgwr6qU6dOTz31FIwZNmzYmTNnSOKk8ePHc0DmLsVfXPi+E2sAs5HLE5YgjL948SKHiNjS1OsDBgzglsDcMJje2Xn/8MMPbORMMshPNnWx52Cc7lhrdNCmDoJCDoKOmGokEaObgz5FRqhvckxpeZ5Vxm8642DL4k7kg+skOR2vXLnygw8+WLp0KXTnjsIs97m5uWxzqeC7sHRgAzdQV111FV8QTp48iZHk+C4sHQsWLGjevDks5xachZFVpaioyBjsu3kuBrz44ouDBw9mG8OFJnSkJlt2Q3emKws4Oh/YOTZQDYXPk6z8fBJCqEl9Pum/++9d4fDhw2lk1qxZlLZp04b65s8CUK2cUpX8LmeXAanG4s6Kz4UgNz9cm8AkJmFAbMMMZhpW/f777w8++CBhm1UF0pMfZOEjFIszQY1bBK7wuBHGWu4BeRohwHH3QCnnHwSF2xUu1rjpB/+hQ4cymfkw6UxjFFbaSZMmPf/885RSn6BpmirnM7r8/u2336DO+++/z5oTkPUkzmdYxV0qexW8zncDvovFVQhaEguZisYqZiOfY4xekOBufAAAA9dJREFU+snHNbYcJp+py+JJkpU/7oBhKvCE5ZzcUCoq0eU3kZtvOuypKgpZiuuzweMyp7CwkI/SKe46me7YQxOty9MCzCbSs7EhQjMroDIh3LzoKCZZiWdE+Q1wrH0VPaxUAt8qeYXvlwTyii7NVdJ1hRoheHOYMa988cUXfJBCb9SoEZsWFD4PQ2WUOKlduzb79RkzZphYw3dKTtKmzueffx67vTGZFXpGlN8VwkiVy4kAG6p+/fpxUcY1FGdEbs94kcD86KOPkjN27Fg+LJATJzCYmO1kwvJDhw5xEceneD7IO4sA1Zw65VfE7/JjpZqJEWCpYdvNaaGgoMB8BkpPT+eTMDlsrzlNmiZYi5xL2Ly8PA6dJt88OUcS/vkCQDWTQwWqGb1CT/G7QnClvLKFHUJr9n5xhpfOcSpQ39Edhfpx+XFJp6a7In6746NSuxEQv+32n6x3R0D8dsdHpXYjIH7b7T9Z746A+O2Oj0rtRsBrftuNjqy3HQHx23YPyn43BMRvN3RUZjsC4rftHpT9bgiI327oqMx2BMRv2z2YnP1hfzvS/K5evbq9/o37/7fYOxBPLY8uv48dO5afn/+itb958+bZ8ufXPWWwe+MR5TeRe+LEic2aNatj7S8zM3PChAnu3lVpRPldq1atnJycXMt/2dnZYrA7AhHltzsoKg0NArbzOzSO0EA8QUD89gRWNRoQBMTvgDhCZniCgPjtCaxqNCAIiN8BcYTM8AQB8dsTWNXoPwj4/R/x228PqH8vERC/vURXbfuNgPjttwfUv5cIiN9eoqu2/UZA/PbbA+rfSwTEb3d0VWo3AuK33f6T9e4IiN/u+KjUbgTEb7v9J+vdERC/3fFRqd0IiN92+y/q1icav/idCCGV24yA+G2z92R7IgTE70QIqdxmBMRvm70n2xMhIH4nQkjlNiMgfvvrPfXuLQLit7f4qnV/ERC//cVfvXuLgPjtLb5q3V8ExG9/8Vfv3iIgfnuLr1r3F4Fk+e2v9epdCLgjIH6746NSuxEQv+32n6x3R0D8dsdHpXYjIH7b7T9Z746A+O2Oj+2lUbdf/I46A8I9fvE73P6N+ujE76gzINzjF7/D7d+oj078jjoDwj3+oPM73OhrdF4jIH57jbDa9xMB8dtP9NW31wiI314jrPb9RED89hN99e01AuK31wiHu/2gj078DrqHZF8yCIjfyaCnd4OOgPgddA/JvmQQEL+TQU/vBh0B8TvoHpJ9ySAQdX4ng53eDT4C4nfwfSQLK4+A+F157PRm8BEQv4PvI1lYeQTE78pjpzeDj8D/AQAA///sBy0fAAAABklEQVQDAFXUmJ33F+b5AAAAAElFTkSuQmCC"},5680:(e,a,n)=>{n.d(a,{xA:()=>o,yg:()=>g});var t=n(6540);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),n.push.apply(n,t)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach(function(a){r(e,a,n[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))})}return e}function c(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=t.createContext({}),s=function(e){var a=t.useContext(u),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},o=function(e){var a=s(e.components);return t.createElement(u.Provider,{value:a},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},d=t.forwardRef(function(e,a){var n=e.components,r=e.mdxType,i=e.originalType,u=e.parentName,o=c(e,["components","mdxType","originalType","parentName"]),p=s(n),d=r,g=p["".concat(u,".").concat(d)]||p[d]||m[d]||i;return n?t.createElement(g,l(l({ref:a},o),{},{components:n})):t.createElement(g,l({ref:a},o))});function g(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=d;var c={};for(var u in a)hasOwnProperty.call(a,u)&&(c[u]=a[u]);c.originalType=e,c[p]="string"==typeof e?e:r,l[1]=c;for(var s=2;s<i;s++)l[s]=n[s];return t.createElement.apply(null,l)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5705:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>s});var t=n(8168),r=(n(6540),n(5680));const i={},l="Circuite secventiale",c={unversionedId:"Laboratoare AB/3 RHDL Secvential/Circuite Secventiale/Teorie/README",id:"Laboratoare AB/3 RHDL Secvential/Circuite Secventiale/Teorie/README",title:"Circuite secventiale",description:"Concept",source:"@site/docs/Laboratoare AB/3 RHDL Secvential/Circuite Secventiale/Teorie/README.md",sourceDirName:"Laboratoare AB/3 RHDL Secvential/Circuite Secventiale/Teorie",slug:"/Laboratoare AB/3 RHDL Secvential/Circuite Secventiale/Teorie/",permalink:"/computer-architecture/Laboratoare AB/3 RHDL Secvential/Circuite Secventiale/Teorie/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Circuite Secventiale",permalink:"/computer-architecture/Laboratoare AB/3 RHDL Secvential/Circuite Secventiale/"},next:{title:"Exercitii",permalink:"/computer-architecture/Laboratoare AB/3 RHDL Secvential/Exercitii/"}},u={},s=[{value:"Concept",id:"concept",level:2},{value:"Implementare",id:"implementare",level:2},{value:"SynchronousDQ",id:"synchronousdq",level:3},{value:"SynchronousIO",id:"synchronousio",level:3},{value:"Synchronous",id:"synchronous",level:3},{value:"#derive(Synchronous, SyncronousDQ)",id:"derivesynchronous-syncronousdq",level:4},{value:"Manual Synchronous impl",id:"manual-synchronous-impl",level:4},{value:"rhdl_fpga::DFF",id:"rhdl_fpgadff",level:3},{value:"Exemplu de implementare, automatul ab",id:"exemplu-de-implementare-automatul-ab",level:2}],o={toc:s},p="wrapper";function m({components:e,...a}){return(0,r.yg)(p,(0,t.A)({},o,a,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"circuite-secventiale"},"Circuite secventiale"),(0,r.yg)("h2",{id:"concept"},"Concept"),(0,r.yg)("p",null,"Circuitele secventiale sunt circuite care nu neaparat mapeaza un set\nde inputuri la un alt set de outputuri fix. Acest comportament\npoate fi realizat numai cu un mecanism de memorie/stare interna, pe care noi ca\nmediu exterior o putem afecta doar intr-un mod controlat de logica\ninterna a acelui circuit. in general nu putem nici sa setam\nsi nici sa vedem starea interna a unui circuit secvential, dar\nputem sa controlam/estimam noi acea stare pe baza specificatiilor\nde le avem a acelui circuit."),(0,r.yg)("p",null,"Exista mai multe tipuri de circuite secventiale:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Latchuri, care poate sa lucreze in regim de modificare continua\na starii interne, sau un regim in care starea interna ramane nemodificata.\nAcest regim este determinat pe baza a unuia sau a mai multor semnale de intrare"),(0,r.yg)("li",{parentName:"ul"},"Circuite secventiale asincrone, a caror stare interioara se poate\nmodifica doar in cadrul unor evenimente instantanee ale unuia sau\na mai multor semnale. Aceste evenimente pot fi trecerea de la 0 la 1 (posedge) sau trecerea de la 1 la 0 (negedge)"),(0,r.yg)("li",{parentName:"ul"},"Circuitele secventiale sincrone, care sunt un caz particular al\ncircuitelor asincrone, starea lor interna se poate modifica doar pe\nbaza unui semnal periodic stabil numit clock. In general aceste circuite au cel mai mare grad de stabilitate, si desi par limitate,\nputem emula comportamentul celorlaltor 2 tipuri de circuite intr-un mod stabil atata timp cat e frecventa clockului suficient de mare")),(0,r.yg)("p",null,"De aceea in general se doreste, si chiar este si optimizat la nivel\nde HDL, ca circuitele secventiale sa fie de tip sincron"),(0,r.yg)("p",null,"Un alt aspect important al unui circuit secvential este ca nu putem\nsa presupunem ca la start-up vom avea mereu aceeasi stare initiala,\nde aceea s-a mai adaugat la majoritatea circuitelor un semnal\nnumit reset, al carui rol este pur si simplu sa puna circuitul in starea default cat timp e activ.\nAcest semnal de reset desi are comportament asincron, nu ne deranjeaza caracteristicile circuitului deoarece este folosit foarte rar,\niar in cazurile in care chiar este activ circuitul nostru nu putem\nsa zicem ca se afla in un regim util de functionare"),(0,r.yg)("h2",{id:"implementare"},"Implementare"),(0,r.yg)("p",null,"Noi ne vom atinge doar de circuite secventiale sincrone la laborator.\nPentru a putea implementa un astfel de circuit secvential, ne trebuie un struct care implementeaza traiturile ",(0,r.yg)("inlineCode",{parentName:"p"},"Synchronous"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"SynchronousIO")," si ",(0,r.yg)("inlineCode",{parentName:"p"},"SynchronousDQ"),"."),(0,r.yg)("h3",{id:"synchronousdq"},"SynchronousDQ"),(0,r.yg)("p",null,"Reprezinta tipurile de date lui ",(0,r.yg)("inlineCode",{parentName:"p"},"D")," si ",(0,r.yg)("inlineCode",{parentName:"p"},"Q"),".\nPentru a intelege ce reprezinta denumirile, ne vom uita la un bistabil D:"),(0,r.yg)("div",{align:"center"},(0,r.yg)("p",null,(0,r.yg)("img",{alt:"D-Flip-Flop",src:n(2093).A,width:"245",height:"205"})),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},"Figure: D Flip Flop"))),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"Q")," reprezinta iesirea bistabilului, iar ",(0,r.yg)("inlineCode",{parentName:"p"},"D")," intrarea.\nDar de fapt ",(0,r.yg)("inlineCode",{parentName:"p"},"Q")," este legat direct de continutul memoriei bistabilului, deci putem\nsa il interpretam ca si starea curenta.\nIar ",(0,r.yg)("inlineCode",{parentName:"p"},"D")," se leaga de intrarea in bistabil la care cand se va intampla urmatorul eveniment de update,\nbistabilul va prelua ca starea valoarea respectiva. Deci putem sa interpretam pe ",(0,r.yg)("inlineCode",{parentName:"p"},"D")," ca si starea urmatoare."),(0,r.yg)("p",null,"La fel cum putem reprezenta un circuit sincron prin tabelul de adevar cu I,Q/O,D functia noastra ",(0,r.yg)("inlineCode",{parentName:"p"},"kernel")," va lua ca inputuri tipurile I si Q si ca outputuri (O,D)"),(0,r.yg)("p",null,"Acest trait se poate implementa direct, si asta ar presupune ca\ndoar definesti tipurile ",(0,r.yg)("inlineCode",{parentName:"p"},"D")," si ",(0,r.yg)("inlineCode",{parentName:"p"},"Q"),", sau se poate deriva."),(0,r.yg)("p",null,"Derivarea traitului SynchronousDQ asupra unui struct va adauga la"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"struct CircSecvTop {\n    circ1: CircSecv1,\n    circ2: CircSecv2,\n    ...\n}\n")),(0,r.yg)("p",null,"aceste 2 tipuri D si Q"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"struct D {\n    circ1: <CircSecv1 as rhdl::core::SynchronousIO>::I,\n    circ2: <CircSecv2 as rhdl::core::SynchronousIO>::I,\n    ...\n}\nstruct Q {\n    circ1: <CircSecv1 as rhdl::core::SynchronousIO>::O,\n    circ2: <CircSecv2 as rhdl::core::SynchronousIO>::O,\n    ...\n}\n")),(0,r.yg)("admonition",{type:"tip"},(0,r.yg)("p",{parentName:"admonition"},"Observam ca in felul acesta nu avem acces la starea interna a unui\ncircuit intern, iar starea noastra interna se bazeaza pe outputurile circuitelor secventiale interne")),(0,r.yg)("h3",{id:"synchronousio"},"SynchronousIO"),(0,r.yg)("p",null,"Reprezinta tipurile de date ale lui ",(0,r.yg)("inlineCode",{parentName:"p"},"I")," si ",(0,r.yg)("inlineCode",{parentName:"p"},"O")," cat si functia ",(0,r.yg)("inlineCode",{parentName:"p"},"kernel")," asociata circuitului descris."),(0,r.yg)("p",null,"Functia ",(0,r.yg)("inlineCode",{parentName:"p"},"kernel")," va avea urmatoarea semnatura:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"#[kernel]\nfn my_circuit(cr: ClockReset, i: I, q: Q) -> (O, D);\n")),(0,r.yg)("h3",{id:"synchronous"},"Synchronous"),(0,r.yg)("p",null,"Avem 2 modalitati de a implementa ",(0,r.yg)("inlineCode",{parentName:"p"},"Synchronous"),"."),(0,r.yg)("h4",{id:"derivesynchronous-syncronousdq"},"#","[derive(Synchronous, SyncronousDQ)]"),(0,r.yg)("p",null,"Se poate face asta automat cu o functie ",(0,r.yg)("inlineCode",{parentName:"p"},"kernel")," care se foloseste de un ",(0,r.yg)("inlineCode",{parentName:"p"},"Synchronous")," si ",(0,r.yg)("inlineCode",{parentName:"p"},"SynchronousDQ")," derivat:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"#[derive(PartialEq, Debug, Clone, Synchronous, SynchronousDQ)]\nstruct MyCircuit {\n    state1: MyOtherCircuit // Circuitul acesta trebuie sa fie si el Synchronous\n}\n")),(0,r.yg)("h4",{id:"manual-synchronous-impl"},"Manual Synchronous impl"),(0,r.yg)("p",null,"Pentru a implementa manual ne trebuie urmatoarele functii:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"trait Synchronous {\n    // Tipul care contine toate informatiile necesare\n    type S;\n    \n    fn init(&self) -> Self::S;\n\n    // Ce se foloseste la simulare.\n    fn sim(&self, clock_reset: ClockReset, input: Self::I, state: &mut Self::S) -> Self::O;\n\n    // Template pentru generarea cod hdl (cum ar fi verilog)\n    fn hdl(&self, name: &str) -> Result<HDLDescriptor, RHDLError>;\n\n    // Contine nume, tipurile(compatibile hdl) ale i/o si d/q, submodulele, cat si informatii de netlist si rtl\n    fn descriptor(&self, name: &str) -> Result<CircuitDescriptor, RHDLError>;\n}\n")),(0,r.yg)("p",null,"Din pacate, trebuie sa depindem de un circuit ",(0,r.yg)("inlineCode",{parentName:"p"},"Synchronous")," pentru a face implementare automata la circuitele ulterioare, acesta trebuind\nimplementat cu functiile de mai sus. Din fericire, exista deja un astfel de circuit de baza."),(0,r.yg)("h3",{id:"rhdl_fpgadff"},"rhdl_fpga::DFF"),(0,r.yg)("p",null,"Este un bistabil D generic pe un tip ",(0,r.yg)("inlineCode",{parentName:"p"},"T")," (il putem numi chiar un ",(0,r.yg)("inlineCode",{parentName:"p"},"register"),"), care poate primi orice tip de date atata timp cat implementeaza traitul ",(0,r.yg)("inlineCode",{parentName:"p"},"Digital")," si ",(0,r.yg)("inlineCode",{parentName:"p"},"Default"),"."),(0,r.yg)("admonition",{type:"warning"},(0,r.yg)("p",{parentName:"admonition"},"Este ",(0,r.yg)("em",{parentName:"p"},"obligatoriu")," ca tipul nostru sa implementeze traitul ",(0,r.yg)("inlineCode",{parentName:"p"},"Default"),". De ce? Deoarece cand se va da reset pe 1, se va folosi fix acea valoare default.")),(0,r.yg)("h2",{id:"exemplu-de-implementare-automatul-ab"},"Exemplu de implementare, automatul ab"),(0,r.yg)("p",null,"Se cere sa se creeze un automat care sa recunoasca secventa(sa se termine in) 'ab'. Automatul va avea ",(0,r.yg)("span",{parentName:"p",className:"math math-inline"},(0,r.yg)("span",{parentName:"span",className:"katex"},(0,r.yg)("span",{parentName:"span",className:"katex-mathml"},(0,r.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.yg)("semantics",{parentName:"math"},(0,r.yg)("mrow",{parentName:"semantics"},(0,r.yg)("mi",{parentName:"mrow",mathvariant:"normal"},"\u03a3"),(0,r.yg)("mo",{parentName:"mrow"},"="),(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},"{"),(0,r.yg)("mi",{parentName:"mrow"},"a"),(0,r.yg)("mo",{parentName:"mrow",separator:"true"},","),(0,r.yg)("mi",{parentName:"mrow"},"b"),(0,r.yg)("mo",{parentName:"mrow",stretchy:"false"},"}")),(0,r.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\Sigma=\\{a,b\\}")))),(0,r.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,r.yg)("span",{parentName:"span",className:"mord"},"\u03a3"),(0,r.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.yg)("span",{parentName:"span",className:"mrel"},"="),(0,r.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.yg)("span",{parentName:"span",className:"base"},(0,r.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.yg)("span",{parentName:"span",className:"mopen"},"{"),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"a"),(0,r.yg)("span",{parentName:"span",className:"mpunct"},","),(0,r.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.1667em"}}),(0,r.yg)("span",{parentName:"span",className:"mord mathnormal"},"b"),(0,r.yg)("span",{parentName:"span",className:"mclose"},"}")))))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug,PartialEq,Eq,Digital,Clone,Copy)]\nenum In {\n    a,\n    b\n}\n")),(0,r.yg)("p",null,"Definim si starile:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"#[derive(Debug,PartialEq,Digital,Default)]\nenum StateAB {\n    #[default]\n    Initial,\n    a,\n    ab\n}\n")),(0,r.yg)("p",null,"Acuma ne vom defini si circuitul cu starile lui interne:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"// Ne folosim de derive sa ne genereze el automat ce ne trebuie\n// pentru un circuit secvential. D = Q = FsmAB', unde FsmAB' este\n// FsmAB alterat in asa fel incat sa aibe aceleasi campuri ca\n// FsmAB doar ca tipurile de date vor fi I-urile de la\n// circuitele Synchronous care sunt copii directi ai lui FsmAB\n#[derive(Synchronous,SynchronousDQ,Clone,Debug)]\nstruct FsmAB {\n    s: DFF<StateAB>\n}\n\nimpl Default for FsmAB {\n    fn default() -> Self {\n        Self {\n            s: DFF::new(StateAB::Initial)\n        }\n    }\n}\n\nimpl SynchronousIO for FsmAB {\n    type I = In,\n    type O = bool,\n    type Kernel = fsm_ker\n}\n")),(0,r.yg)("p",null,"Acesta e un boilerplate necesar pentru fiecare circuit secvential. Acuma logica automatului:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"#[kernel]\nfn fsm_ker(_cr: ClockReset, i: I, q: Q) -> (O, D) {\n    let (o,d) = match (q.state, i) {\n        (StateAB::Initial, In::a) => (false, StateAB::a),\n        (StateAB::a, In::b) => (false, StateAB::ab),\n        (StateAB::ab, In::a) => (true, StateAB::a),\n        (StateAB::ab, In::b) => (true, StateAB::Initial),\n        (StateAB::Initial, In::b) => (false, StateAB::Initial),\n        (StateAB::a, In::a) => (false, StateAB::a)\n    };\n    (o, D {s: d} )\n}\n")),(0,r.yg)("p",null,"Observati cum nu folosim ",(0,r.yg)("inlineCode",{parentName:"p"},"ClockReset"),"-ul, resetul este facut automat pentru noi deoarece am implementat ",(0,r.yg)("inlineCode",{parentName:"p"},"Default")))}m.isMDXComponent=!0}}]);