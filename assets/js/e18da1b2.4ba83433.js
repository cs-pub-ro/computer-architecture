"use strict";(globalThis.webpackChunkcomputer_architecture=globalThis.webpackChunkcomputer_architecture||[]).push([[3923],{139:(e,a,t)=>{t.d(a,{A:()=>n});const n="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALcAAABpCAYAAAB4WrLAAAACEHpUWHRteEdyYXBoTW9kZWwAAO1WTW/bMAz9NbnH1up2xyVL28uAATlsO6o2awuTLUOR87FfX8oiLTt2hw4rsMsQIKAeP0Q+PSlZiW19frCyrb6YAvQqXRfnlfi8StOb7AN+e+ASACGyAJRWFQFKIrBXv4DANaGdKuAwCXTGaKfaKZibpoHcTbBno6dbtLLk8hHY51LP0W+qcFVA71Jq2eOPoMqKt0myj8HzJPOfpTVdQ/s1poHgqSWX6QcSO+TKGoMVvFWft6A9X8xFmPr+Fe/Qn4WGevh9Arp8wlHqjkbcE68Hd+GpMQXZxMXmVCkH+1bm3nPC80SstLJQuN3WaGP7BLHLAD/zXqi9I1gHdP49RL09gKnB2QuGsPeWuiFxJDe0PkX2GapGxDMmSQPlUDlygQbRsUyNmFND/f8NNZ6Yd6FGrP8dNbczanxTc3byzh7B5yRIBpyV+z6yf6C99naDu3vHsGCPlk+gN8PNYRb7uyM2r3J4MJ3tTyHq20lbAkXRuUIxuepznkc8Jsz1mMgBtKClU8fpE7FEL+3x1SjsOB4c1+GU0D9Fje8uJ7I+rhPDlLPET9ZKPxCHtT7gsNAQ1U2zK2WJyRuCRqgYpTKw9ib13C2qZ/7sLKqnFwmpp8dZPcOCPc+mcfeyVtqP8Qj6CE7l8n1kRRoay4qU9l9Wb5XV1U/Tn8oKl/FnMoTH/xdi9wIfI2hlAAANNElEQVR4nO2de3BU133HPypio6tdxO7qAUUvLiXYHtnCpk0KI1p3AgmJQ96ZhOJ62gykxdPYTgS1G1wjQKmLMuNi2gTSTrraGSvZCHcKHtSC8NgiGw8pD4sAGgaC2mQsuWCQVlo9AEng0z+OJPQESXu1d/fq95n5jrT33r3nd3S/e/U7j7sHBEEQBEEQBGEQBay0OwhBsBqFmFtIcPYCR4a8bgSev897Gvt/irmFhGcvsA5t6gFjr+Pu3XlA60a8T8wtJAWNDL+DTwQxt5AUKO6mGyB3bsEhHEEbdx06RZkoYm4hoTnCcEMfYeLpiZhbEARBEARBEARBEARBEARBEAQhDriBfGAp8CfAl4Enx9ETwHJgCZAF/E78wxWE4XwUbcxngFeBQ8AF4CbQDTQB54BjwH8AVcBPxtB/Af8N/BpoAT4ErgC/ACqBrcDXgMfiUithxpEPfBH4HnpI/Trwm/7ffwiUAl8AHgb8FpSXCzwObAB2Af8OnAV60aZ/Bfg6sNCCsoQZhg/4KvAj4DJwFagBdgCfA37Xprg8wCeA7wIHgP9Dz0D8AbAWSLUpLiHB+RiwHXgHuIU283eAR2yMaSIUox+MeBvoAd4Ankbn78IM5jGgHGgALgIVwCdJ3kadFz3d9jWgD3gd+IqtEQlx5feAbcCvgP8Bvo/urXAaHuCbwFvANWAPsGyC77Wi3SDEkS+i89R2dO/GH9kbTlxZgv5AN6N7dZ64z/HB6Q4oWSkBynw+X1V2dnbY5/NddrvdbYByu91tPp/vcv/2KqCs//jpIh94Cd3oCqN7H2ZNY3nJwAbgVL82jHPMbWBTjOUkkg9iYu38+fNDHo8nsnDhwkhpaWn7vn371MGDB9XJkydVU1OT6u3tVU1NTerkyZPq4MGDat++fWrz5s0dpmm2zZkzJ7JgwYKfoVv8VvAY8G/ADXRX3cctOq+T+Cz6Lv6/jDbybaADyJ7kORPNBzHxjGEYkWXLlkUqKiruXLhwQX344YeT1oULF1RFRcWdZcuWRdLT09uAb00xnsfRjagrwIvAXKsq6mAeB/4TOA/8GeBCm7sHPfg0ERLNBzGx3uv1vldSUnLl+PHjU6rIeDp+/LgqKSm56vf735s1a9b6CcbzeeAousfDlj+IA3gC+Dk6XbmJfq4zwr3Tk0TzQUwszsjIOFVUVNR66NAhdefOnWnToUOHVHFxcVtGRsYpYPE48axCm/pd4Kl4/AEcTjFwCZ2SDHwNRRcwf8RxieaDmFmTnp4e3b59+7Xbt2+reGnnzp2thmF0AGuGxPIx9JD0ZcZvFAmTYxd6XksLw79jpQ09QDRAIvkgdjwez7Mul6unurq6O54VGtD+/ft7XS5Xz9y5c3cBAfRw+HcsreTMpQidc/ehc+3b6BHaTiCK7jq9BXwjUXyQlZW12ZKap6amvlJYWBipr6+Pe2WGqr6+XqWlpfWlpqb+EkizpHLCWLjQQ/cmesruSuAzKSkpNXl5ee2J4APTNKOGYbwaUy09Hs+zeXl5Lc3Nzaqvr892NTc3q4KCgtacnBxrPrnChHCiD9a4XK6e06dPq97e3oTR6dOnlcvl6sHq3EsYD8f5YLFhGB2hUKjb7kqMperq6t7+xsW0tZ4FwIk+yMjIOPXyyy/fsjv4e2nXrl13vF7vu9N3XQUn+uBPH3jggQ96enpUouuhhx5qSUtLk/7t6cF5PvB6ve8dOHCg79atWyrRdeDAAeX3+5vicKFnHI7zgdvtLl2xYsUVu4OdjFauXHlt3rx5fxunaz4jcKQPDMOIhMNh2wOdjMLhsOqfZCNYhBN9sPaRRx65dvPmTZVsWrp0aSsJMk3SATjPB/PmzQvt2LGj48aNGyrZVF5efjM3N3d//H3gPBzpA4/HEzlz5oztAU5FZ86cUR6PJ2KDFxyHE31QUlhYGLE7uFhUWFgYIYEfVUoSHOmDsi1btvR1d3crK8SIpelG7l+0aNHgvoaGBkvK3LJlSx/6WTxh6sTVB93d3SoYDKpFixZZUt6YPsjKygrt2bNHdXV1xSzTNFV5efng6/LycgUMvt64caPauHHj4D7TNC0pd8+ePSorKytkiyUcQjx90NXVpYLBoAIs88CYPsjJyXmnuro65hOfP39eAer8+fPDtgMqGAwO/v7mm28O2zf09VRVXV2tcnJy3rHFFQ4hnj5YvXq1Mk1TBYNBS809ygeZmZmN4XDYkpOvXr16WCXuV+mBCsZabjgcVpmZmY3jXDdhAsTLB0NltblH+cDtdrdfunRJdXZ2WqLKysphuVZlZaXq7OxUR48eHTT3wLGmaQ7uj0WXLl1Sbre73R5bOIN4+WDkMaZpWlbmWD5QkUhEdXR0WK7a2loFqNraWnXu3DkFqHPnzg3uN01TBQKBmMtpb29X69evP2qDJ5xEXHwwdHsgEFCmaVpWzigfuN3u9osXL8Z84kAgoFatWjVq+1ADj6zgWBWeii5evCh37hiJpw+my9yjfODz+Rrr6upUNBqNWYAKBAKDrwOBgALU2bNnVTQaVatWrVIbNmxQ0WhU7dixQ5mmaUm5dXV1yufzSc4dA/H0wdDtVnlgTB/k5OS8EwqFLCuAEf2bIyt0r31TVSgUkt6SGIm3D6bD3KN8kJ2dHdq9e7dlBdih3bt3q+zsbOnnjgGn+qCstLS0r729XSWrSktLZYQydhzpg5LCwsK2trY2lawqLCxsQ+aWxIozfeDxeCInTpywPbip6MSJE8rj8cgDCxbgSB/Mnz//Zy+99FKX3QFORWVlZT15eXmv2+AFx+FUH6wtKiq6HolEVLKpuLhYnsSxDmf6wDCMttraWtXa2po0qq2tVW63Oxrf6+9sHOkDn8/3N8uXL79qd6CTUUlJyfXc3NwX43jtHY9jfeD1eptCoZDtwU5EoVBI+f3+5jhd8xmFI30wa9as9UuWLLne0tKiEl0PPvhgq9fr/UYcrvWMw7E+mDNnzqmysrK+69evq0TV9u3b7/h8vjPTfI1nNE71wWLDMDoCgUCv3cGPpWAwqAzD6ES+5XW6cawP1rhcrp5jx47ZXomhOnbsmHK5XL2pqamfnoaLKYzGmT7w+/2b8/LyWhsaGtS1a9dsV0NDg8rPz4/k5eW9YPEFFO6B3+/fnJmZ2XH27FnbPWCpDwzDeHXhwoXRuro69cEHH9imt99+W+Xn53elpKR0AO8DZ9GrbL0B/AtQAWwF/hq9WKgnpooLA3wceCMlJaWloKCgIxF8YJpmZ8xr4gyQlZW12eVy9QQCgV47KlRZWalcLldv/yf1m0A3I+YK9+sWUM3kl3UWRrMI+DF65bhnIeF8YClrDMPoeOGFF9riWaGtW7d2GIbRmZqaOnTtk2Po1W0HTB1BLwy60epKz0DmAv8A3AHKAWPE/kTygaUsnjt37rtFRUXtVVVV6urVq9Omqqoq9fDDD3d6vd4zjG4N53N3CWcF9AI/BR6YrorPAOYBL6NXDN6H/huPR6L4wHrS0tKe8vl8TcuXL79WU1Ojrly5YplqamrUihUrWvx+f/N9Oub/krvLONegJ6jfAF5l9HLOwvgsBP4Rfaf+Z+CjE31jgvhgepg9e/Zz6enp7UuXLm3ftm2bCofDU6pIOBxW27ZtU48++mjU7XZHZ8+e/dwEQ6hFr3j7Wv/rHOAVoAfYAWRaX2vHUIy+Q/cA3wfypnqiBPDBtLJ2wYIF+z0eT6SgoCCyadOmaEVFhQoGg+rw4cOqvr5evf/++6q+vl4dPnxYBYNBVVFRoZ5++unOgoKCNo/H05abm/s6k5+2WoA2d9WI7YuBf0Uv+fxPwIMx19A5fA04gu5x2om1NwC7fBA3SoAyr9db5ff7w16v93L/cg4qPT29zev1Xu7fXoVOJWJ9NGwT8N1x9uUC30M3OEPAH8dYVrKSB2wDfgO8BTwZhzLj7QPHsv4++13Ac8Al4JfAM+j1zZ2MATyFHge4CfwQ+ANbIxKmnc+gc/Tb6D7xL9gbjuV8Gd1z1Is29lOM7s4THM4c4K+An6MHKirR+egcO4OaAia652g/0Aa8iU7VnP6fSZggi9DD9jXoLrFa4NvAMjuDGods4Al0r9A59AfzNeDPgQU2xiUkAWnAl9C9LefRgxpvAX8PfB7dSI0XGeiG1reBnwC/BtrRd+e/A/4wjrEIDsSPztO3A4fRd8oocBrdA7MTndd+Cvh9dJqQMYHzetBdmY8CnwC+DryITo9+AVxBf7BOohuDfwEUWVIjQbgHPvRsuSfRpv8pcBR4F/gteuS0B2gZoutDdAtt3PeAX6FnN76OntOxAXic+P6HEIRJ4UIPkAwoa4g+YmNcgiAIgiAIgiAIgiAIgiAIgmAl67j7LOg6m2MRBEtRwMp+KZtjEYRx2Yt+hGuARuD5exy/sv+YAQaMLggJyV50evE8d409NPUYmoKsY7i5G5HUREhwGhl+Bx8PMbeQdCiGm3a8O7ekJUJScYS7KcfeCRwvDUohKTjCcEMf4f7piXQFCoIgCIIgCIKQlPw/3ZLHEW2gce0AAAAASUVORK5CYII="},2969:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>u,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var n=t(8168),r=(t(6540),t(5680));const i={},u="Automate finite",o={unversionedId:"Laboratoare AB/0 Recapitulare/Automate finite/Teorie/README",id:"Laboratoare AB/0 Recapitulare/Automate finite/Teorie/README",title:"Automate finite",description:"Prin automate finite (eng. Finite-state machine - FSM) \xeen\u021belegem de fapt un circuit secven\u021bial sincron a\u0219a cum a fost el descris anterior. De obicei, proiectarea unui automat finit porne\u0219te de la o descriere informal\u0103 a modului \xeen care automatul trebuie s\u0103 func\u021bioneze. Primul pas \xeen realizarea automatului este descrierea formal\u0103 a func\u021bion\u0103rii acestuia. Dou\u0103 dintre metodele prin care un automat finit poate fi descris sistematic sunt:",source:"@site/docs/Laboratoare AB/0 Recapitulare/Automate finite/Teorie/README.md",sourceDirName:"Laboratoare AB/0 Recapitulare/Automate finite/Teorie",slug:"/Laboratoare AB/0 Recapitulare/Automate finite/Teorie/",permalink:"/computer-architecture/Laboratoare AB/0 Recapitulare/Automate finite/Teorie/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Automate finite",permalink:"/computer-architecture/Laboratoare AB/0 Recapitulare/Automate finite/"},next:{title:"1 Limbajul Rust",permalink:"/computer-architecture/Laboratoare AB/1 Limbajul Rust/"}},l={},c=[{value:"Recunoa\u015fterea secven\u021bei &quot;ba&quot;",id:"recunoa\u015fterea-secven\u021bei-ba",level:2},{value:"Intersec\u021bie semaforizat\u0103",id:"intersec\u021bie-semaforizat\u0103",level:2}],s={toc:c},m="wrapper";function d({components:e,...a}){return(0,r.yg)(m,(0,n.A)({},s,a,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"automate-finite"},"Automate finite"),(0,r.yg)("p",null,"Prin automate finite (eng. ",(0,r.yg)("em",{parentName:"p"},"Finite-state machine - FSM"),") \xeen\u021belegem de fapt un circuit secven\u021bial sincron a\u0219a cum a fost el descris anterior. De obicei, proiectarea unui automat finit porne\u0219te de la o descriere informal\u0103 a modului \xeen care automatul trebuie s\u0103 func\u021bioneze. Primul pas \xeen realizarea automatului este descrierea formal\u0103 a func\u021bion\u0103rii acestuia. Dou\u0103 dintre metodele prin care un automat finit poate fi descris sistematic sunt:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Diagrama de st\u0103ri")," prezint\u0103 \xeentr-un mod grafic func\u021bionarea unui automat finit. St\u0103rile automatului sunt reprezentate prin noduri, iar tranzi\u021biile sunt reprezentate prin arce \xeentre starea surs\u0103 \u0219i starea destina\u021bie. Fiecare arc este marcat cu condi\u021bia necesar\u0103 pentru a fi efectuat\u0103 o tranzi\u021bie. De asemenea, eventualele semnale de ie\u0219ire ale automatului sunt marcate \xeen dreptul st\u0103rilor care genereaz\u0103 acele ie\u0219iri.")),(0,r.yg)("div",{align:"center"},(0,r.yg)("p",null,(0,r.yg)("img",{alt:" Exemplu de diagram\u0103 de st\u0103ri",src:t(139).A,width:"183",height:"105"})),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},"Figure: Exemplu de diagram\u0103 de st\u0103ri"))),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Tabelul de tranzi\u021bii")," prezint\u0103 func\u021bionarea unui automat finit sub form\u0103 de tabel. Fiecare r\xe2nd al tabelului reprezint\u0103 o tranzi\u021bie a automatului \u0219i con\u021bine starea curent\u0103, starea urm\u0103toare \u0219i intr\u0103rile necesare pentru a activa tranzi\u021bia.")),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Starea curent\u0103"),(0,r.yg)("th",{parentName:"tr",align:null},"x"),(0,r.yg)("th",{parentName:"tr",align:null},"Starea urm\u0103toare"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"S0"),(0,r.yg)("td",{parentName:"tr",align:null},"1"),(0,r.yg)("td",{parentName:"tr",align:null},"S1")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"S1"),(0,r.yg)("td",{parentName:"tr",align:null},"0"),(0,r.yg)("td",{parentName:"tr",align:null},"S0")))),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},"Table: Exemplu de tabel de tranzi\u021bii")),(0,r.yg)("p",null,"\xcen continuare vom proiecta dou\u0103 automate finite simple:"),(0,r.yg)("h2",{id:"recunoa\u015fterea-secven\u021bei-ba"},'Recunoa\u015fterea secven\u021bei "ba"'),(0,r.yg)("p",null,'Se dore\u0219te proiectarea unui automat finit capabil s\u0103 recunoasc\u0103 secven\u021ba "ba". Automatul prime\u0219te la intrare \xeen mod continuu caractere codificate printr-un semnal de un bit (caracterele posibile sunt "a" \u0219i "b"). Ie\u0219irea automatului va consta dintr-un semnal care va fi activat (valoarea 1) atunci c\xe2nd ultimele dou\u0103 caractere introduse vor fi "b" urmat de "a". Semnalul de ie\u0219ire va r\u0103m\xe2ne activ p\xe2n\u0103 la introducerea unui nou caracter, dup\u0103 care automatul va continua opera\u021bia de recunoa\u0219tere.'),(0,r.yg)("p",null,'Vom \xeencepe proiectarea automatului prin identificarea intr\u0103rilor \u0219i ie\u0219irilor. Din descriere observ\u0103m c\u0103 intrarea este format\u0103 dintr-un singur semnal de 1 bit (automatul va avea \u0219i o intrare de ceas, \xeens\u0103 aceasta nu este considerat\u0103 intrare propriu zis\u0103 de date). Deoarece codificarea caracterelor nu este specificat\u0103 vom presupune c\u0103 valoarea 0 indic\u0103 un caracter "a", iar valoarea 1 indic\u0103 un caracter "b". Ie\u0219irea este format\u0103 deasemenea dintr-un semnal de 1 bit cu valoarea 1 atunci c\xe2nd secven\u021ba c\u0103utat\u0103 a fost g\u0103sit\u0103 \u0219i 0 \xeen rest.'),(0,r.yg)("p",null,"Vom realiza \xeen continuare diagrama de st\u0103ri a automatului. La pornire, vom ini\u021bializa automatul \xeentr-o stare pe care o vom numi ''S0''. Dac\u0103 la prima tranzi\u021bie de ceas intrarea are valoarea:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"0 (caracterul \"a\") - vom avansa \xeentr-o stare pe care o vom numi ''Sa'' care ne spune c\u0103 intrarea precedent\u0103 a fost \"a\""),(0,r.yg)("li",{parentName:"ul"},"1 (caracterul \"b\") - vom avansa \xeentr-o stare pe care o vom numi ''Sb'' care ne spune c\u0103 intrarea precedent\u0103 a fost \"b\"\n\xcen continuare vom analiza ce se \xeent\xe2mpl\u0103 atunci c\xe2nd automatul este \xeen starea ''Sa''. Dac\u0103 la intrare avem valoarea:"),(0,r.yg)("li",{parentName:"ul"},'0 (caracterul "a") - automatul va r\u0103m\xe2ne \xeen acest\u0103 stare, care ne spune c\u0103 intrarea precedent\u0103 a fost "a"'),(0,r.yg)("li",{parentName:"ul"},"1 (caracterul \"b\") - automatul va trece \xeen ''Sb'', care ne spune c\u0103 intrarea precedent\u0103 a fost \"b\"\nDac\u0103 ne afl\u0103m \xeen starea ''Sb'' \u0219i automatul prime\u0219te la intrare valoarea:"),(0,r.yg)("li",{parentName:"ul"},'0 (caracterul "a") - automatul a \xeent\xe2lnit secven\u021ba dorit\u0103 "ba" (fiind \xeen starea \'\'Sb\'\' intrarea precedent\u0103 a fost "b", iar intrarea curent\u0103 este "a"); vom avansa \xeentr-o stare pe care o vom numi \'\'SA\'\' \xeen care vom activa ie\u0219irea automatului; de asemenea, aceast\u0103 stare ne spune \u0219i c\u0103 intrarea precedent\u0103 a fost "a", lucru folosit pentru a putea recunoa\u0219te \u0219i urm\u0103toarele secven\u021be "ba" care vor mai fi \xeent\xe2lnite la intrare'),(0,r.yg)("li",{parentName:"ul"},"1 (caracterul \"b\") - automatul va r\u0103m\xe2ne \xeen aceast\u0103 stare, care ne spune c\u0103 intrarea precedent\u0103 a fost \"b\"\nDac\u0103 ne afl\u0103m \xeen starea ''SA'' \u0219i automatul prime\u0219te la intrare valoarea:"),(0,r.yg)("li",{parentName:"ul"},'0 (caracterul "a") - automatul va trece \xeen starea \'\'Sa\'\' care ne spune c\u0103 intrarea precedent\u0103 a fost "a", \xeens\u0103 nu vom activa ie\u0219irea automatului deoarece automatul nu a v\u0103zut \u0219i caracterul "b"'),(0,r.yg)("li",{parentName:"ul"},"1 (caracterul \"b\") - automatul va trece \xeen starea ''Sb'' care ne spune c\u0103 intrarea precedent\u0103 a fost \"b\"")),(0,r.yg)("p",null,"\xcen momentul de fa\u021b\u0103 comportamentul automatului a fost descris complet, toate cele 4 st\u0103ri identificate av\xe2nd definite tranzi\u021biile pentru toate combina\u021biile semnalelor de intrare. Figura de mai jos prezint\u0103 diagrama de st\u0103ri a automatului."),(0,r.yg)("div",{align:"center"},(0,r.yg)("p",null,(0,r.yg)("img",{alt:" Automatul de recunoa\u0219tere a secven\u021bei &quot;ba&quot;",src:t(9562).A,width:"331",height:"327"})),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},'Figure: Automatul de recunoa\u0219tere a secven\u021bei "ba"'))),(0,r.yg)("p",null,"O dat\u0103 determinat\u0103 diagrama de st\u0103ri a automatului, putem trece la implementarea acestuia \xeentr-un limbaj cunoscut (C/C++/C#/Java):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C++"},'void FSM_ba() {  \n  // FSM input: 0 - a, 1 - b, other - exit\n  // FSM output: 0 - not found, 1 - found\n  // FSM state: 0 - S0, 1 - Sa, 2 - Sb, 3 - SA\n  int state = 0;\n  int in, out;\n  out = 0;\n  in = 0;\n\n  while(1) {\n      switch(state) {\n          case 0:\n              out = 0;\n              break;\n\n          case 1:\n              out = 0;\n              break;\n\n          case 2:\n              out = 0;\n              break;\n\n          case 3:\n              out = 1;\n              break;\n      }\n    std::cout << "Output: " << out << std::endl;\n      \n    // Read input\n    std::cout << "Please input a number (0 for a, 1 for b, other exit ): ";\n    std::cin >> in;\n    if (in > 1) {\n        break;\n    }\n\n      switch(state) {\n          case 0:\n              if(in == 0)\n                  state = 1;\n              else\n                  state = 2;\n              break;\n\n          case 1:\n              if(in == 0)\n                  state = 1;\n              else\n                  state = 2;\n              break;\n\n          case 2:\n              if(in == 0)\n                  state = 3;\n              else\n                  state = 2;\n              break;\n\n          case 3:\n              if(in == 0)\n                  state = 1;\n              else\n                  state = 2;\n              break;\n      }\n  }\n}\n')),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://github.com/cs-pub-ro/computer-architecture/tree/main/chapters/sequential-circuits/fsms/demos/fsm"},"Codul sursa pentru functia FSM_ba")),(0,r.yg)("h2",{id:"intersec\u021bie-semaforizat\u0103"},"Intersec\u021bie semaforizat\u0103"),(0,r.yg)("p",null,"Se dore\u0219te modelarea prin intermediul unui automat de st\u0103ri a unei intersec\u021bii semaforizate \xeen care ma\u0219inile pot intra din nord (N), est (E), sud(S) sau vest (W). Semaforul din nord este sincronizat cu semaforul din sud, iar cel din est este sincronizat cu cel din vest. Duratele de timp pentru cele dou\u0103 direc\u021bii vor fi: Nord - Sud: ro\u0219u - 40 sec, galben - 10sec, verde - 50sec; Est-Vest: ro\u0219u - 60 sec, galben - 10 sec, verde - 30 sec."),(0,r.yg)("p",null,"Vom \xeencepe proiectarea automatului prin identificarea intr\u0103rilor \u0219i ie\u0219irilor. Deoarece descrierea informal\u0103 nu con\u021bine informa\u021bii despre intr\u0103rile \u0219i ie\u0219irile necesare vom folosi oric\xe2te intr\u0103ri \u0219i ie\u0219iri avem nevoie pentru implementarea comportamentului. Un minim de ie\u0219iri pentru automat reprezint\u0103 semnalele de comand\u0103 pentru culorile semaforului pentru pietoni \u0219i pentru ma\u0219ini. Cele 5 semnale vor fi:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"N_rosu- aprindere culoare ro\u0219ie pentru ma\u0219inile din Nord"),(0,r.yg)("li",{parentName:"ul"},"N_galben - aprindere culoare galben\u0103 pentru ma\u0219inile din Nord"),(0,r.yg)("li",{parentName:"ul"},"N_verde - aprindere culoare verde pentru ma\u0219inile din Nord"),(0,r.yg)("li",{parentName:"ul"},"E_rosu- aprindere culoare ro\u0219ie pentru ma\u0219inile din Est"),(0,r.yg)("li",{parentName:"ul"},"E_galben - aprindere culoare galben\u0103 pentru ma\u0219inile din Est"),(0,r.yg)("li",{parentName:"ul"},"E_verde - aprindere culoare verde pentru ma\u0219inile din Est"),(0,r.yg)("li",{parentName:"ul"},"S_rosu- aprindere culoare ro\u0219ie pentru ma\u0219inile din Sud"),(0,r.yg)("li",{parentName:"ul"},"S_galben - aprindere culoare galben\u0103 pentru ma\u0219inile din Sud"),(0,r.yg)("li",{parentName:"ul"},"S_verde - aprindere culoare verde pentru ma\u0219inile din Sud"),(0,r.yg)("li",{parentName:"ul"},"W_rosu- aprindere culoare ro\u0219ie pentru ma\u0219inile din Vest"),(0,r.yg)("li",{parentName:"ul"},"W_galben - aprindere culoare galben\u0103 pentru ma\u0219inile din Vest"),(0,r.yg)("li",{parentName:"ul"},"W_verde - aprindere culoare verde pentru ma\u0219inile din Vest\nPentru a m\u0103sura duratele de timp am putea folosi semnalul de ceas al automatului, introduc\xe2nd multiple st\u0103ri cu tranzi\u021bii necondi\u021bionate, \xeen care o culoare a semaforului este \u021binut\u0103 aprins\u0103. Av\xe2nd \xeen vedere \xeens\u0103 c\u0103 semnalul de ceas pentru un automat are o perioad\u0103 de ceas mic\u0103 (%%<<%% 1 sec) am avea nevoie de multe st\u0103ri pentru a realiza o durat\u0103 de 30 sec. O solu\u021bie mult mai bun\u0103 este s\u0103 folosim un num\u0103r\u0103tor pentru a realiza \xeent\xe2rzierile necesare. Num\u0103r\u0103torul este un circuit secven\u021bial (automat finit) care poate num\u0103ra cresc\u0103tor sau descresc\u0103tor tranzi\u021biile unui semnal, av\xe2nd un semnal de ie\u0219ire care este activat atunci c\xe2nd indexul ajunge la 0 sau la o valoare care poate fi controlat\u0103. Concret, pentru m\u0103surarea duratelor de timp \xeen automatul nostru vom folosi un num\u0103r\u0103tor cresc\u0103tor a c\u0103rui valoare maxim\u0103 o vom configura pentru a ob\u021bine duratele de timp necesare, \xeen func\u021bie de perioada de ceas a automatului.\nVom ad\u0103uga astfel o ie\u0219ire (''T''), care va controla valoarea maxim\u0103 a num\u0103r\u0103torului \u0219i o intrare (''done'') care va primi semnalul de terminare de la num\u0103r\u0103tor.")),(0,r.yg)("p",null,"Diagrama de st\u0103ri a automatului va urm\u0103ri tranzi\u021bia celor 3 culori ale semaforului pentru ma\u0219ini: verde -> galben -> ro\u0219u -> verde . "),(0,r.yg)("div",{align:"center"},(0,r.yg)("p",null,(0,r.yg)("img",{alt:" Automatul intersec\u021biei",src:t(9386).A,width:"748",height:"424"})),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},"Figure: Automatul intersec\u021biei"))),(0,r.yg)("p",null,"Odat\u0103 determinat\u0103 diagrama de st\u0103ri a automatului, putem trece la implementarea acestuia \xeentr-un limbaj cunoscut (C/C++/C#/Java): "),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C++"},'void FSM_intersectie() {\n    int state = 0; // FSM state: 0 - N/S_verde, 1 - N/S_galben, 2 - N/S_rosu, 3 - E/W_galben\n    int N_rosu;\n    int N_galben;\n    int N_verde;\n    int S_rosu;\n    int S_galben;\n    int S_verde;\n    int W_rosu;\n    int W_galben;\n    int W_verde;\n    int E_rosu;\n    int E_galben;\n    int E_verde;\n    int done;\n    int T;\n    done = 0;\n    T = 0;\n\n    while(1) {\n        N_rosu = 0;\n        N_galben = 0;\n        N_verde = 0;\n        S_rosu = 0;\n        S_galben = 0;\n        S_verde = 0;\n        W_rosu = 0;\n        W_galben = 0;\n        W_verde = 0;\n        E_rosu = 0;\n        E_galben = 0;\n        E_verde = 0;\n        switch(state) {\n            case 0:\n                E_rosu = 1;\n                W_rosu = 1;\n                N_verde = 1;\n                S_verde = 1;\n                T = 50;\n                if(done == 1)\n                    state = 1;\n                else\n                    state = 0;\n                break;\n            case 1:\n                N_galben = 1;\n                S_galben = 1;\n                E_rosu = 1;\n                W_rosu = 1;\n                T = 10;\n                if(done == 1)\n                    state = 2;\n                else\n                    state = 1;\n                break;\n            case 2:\n                N_rosu = 1;\n                S_rosu = 1;\n                E_verde = 1;\n                W_verde = 1;\n                T = 30;\n                if(done == 1)\n                    state = 3;\n                else\n                    state = 2;\n                break;\n            case 3:\n                N_rosu = 1;\n                S_rosu = 1;\n                E_galben = 1;\n                W_galben = 1;\n                T = 10;\n                if(done == 1)\n                    state = 0;\n                else\n                    state = 3;\n                break;\n        }\n\n        std::cout << "Stare: " << state << std::endl;\n        std::cout << "Done: " << done << std::endl;\n        std::cout << "N: " << N_rosu << N_galben << N_verde << std::endl;\n        std::cout << "S: " << S_rosu << S_galben << S_verde << std::endl;\n        std::cout << "W: " << W_rosu << W_galben << W_verde << std::endl;\n        std::cout << "E: " << E_rosu << E_galben << E_verde << std::endl;\n        std::cout << "Timp: " << T << std::endl;\n        std::cin >> done;\n        if (done > 1) {\n            break;\n        }\n    }\n}\n')),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://github.com/cs-pub-ro/computer-architecture/tree/main/chapters/sequential-circuits/fsms/demos/semaphore"},"Codul sursa pentru functia FSM_intersectie")))}d.isMDXComponent=!0},5680:(e,a,t)=>{t.d(a,{xA:()=>s,yg:()=>g});var n=t(6540);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),t.push.apply(t,n)}return t}function u(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach(function(a){r(e,a,t[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})}return e}function o(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=n.createContext({}),c=function(e){var a=n.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):u(u({},a),e)),t},s=function(e){var a=c(e.components);return n.createElement(l.Provider,{value:a},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},p=n.forwardRef(function(e,a){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=c(t),p=r,g=m["".concat(l,".").concat(p)]||m[p]||d[p]||i;return t?n.createElement(g,u(u({ref:a},s),{},{components:t})):n.createElement(g,u({ref:a},s))});function g(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=t.length,u=new Array(i);u[0]=p;var o={};for(var l in a)hasOwnProperty.call(a,l)&&(o[l]=a[l]);o.originalType=e,o[m]="string"==typeof e?e:r,u[1]=o;for(var c=2;c<i;c++)u[c]=t[c];return n.createElement.apply(null,u)}return n.createElement.apply(null,t)}p.displayName="MDXCreateElement"},9386:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/fsm_intersectie-f7107935accbaa3b9119eb7631e89818.jpg"},9562:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/fsm-ba-cececf7f171e47c97292fa347809e36a.png"}}]);