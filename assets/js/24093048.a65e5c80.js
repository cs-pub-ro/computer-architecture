"use strict";(globalThis.webpackChunkcomputer_architecture=globalThis.webpackChunkcomputer_architecture||[]).push([[9341],{5680:(e,r,a)=>{a.d(r,{xA:()=>m,yg:()=>y});var t=a(6540);function i(e,r,a){return r in e?Object.defineProperty(e,r,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[r]=a,e}function n(e,r){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),a.push.apply(a,t)}return a}function l(e){for(var r=1;r<arguments.length;r++){var a=null!=arguments[r]?arguments[r]:{};r%2?n(Object(a),!0).forEach(function(r){i(e,r,a[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(a,r))})}return e}function o(e,r){if(null==e)return{};var a,t,i=function(e,r){if(null==e)return{};var a,t,i={},n=Object.keys(e);for(t=0;t<n.length;t++)a=n[t],r.indexOf(a)>=0||(i[a]=e[a]);return i}(e,r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(t=0;t<n.length;t++)a=n[t],r.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var u=t.createContext({}),p=function(e){var r=t.useContext(u),a=r;return e&&(a="function"==typeof e?e(r):l(l({},r),e)),a},m=function(e){var r=p(e.components);return t.createElement(u.Provider,{value:r},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},s=t.forwardRef(function(e,r){var a=e.components,i=e.mdxType,n=e.originalType,u=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=p(a),s=i,y=c["".concat(u,".").concat(s)]||c[s]||g[s]||n;return a?t.createElement(y,l(l({ref:r},m),{},{components:a})):t.createElement(y,l({ref:r},m))});function y(e,r){var a=arguments,i=r&&r.mdxType;if("string"==typeof e||i){var n=a.length,l=new Array(n);l[0]=s;var o={};for(var u in r)hasOwnProperty.call(r,u)&&(o[u]=r[u]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<n;p++)l[p]=a[p];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}s.displayName="MDXCreateElement"},9896:(e,r,a)=>{a.r(r),a.d(r,{assets:()=>u,contentTitle:()=>l,default:()=>g,frontMatter:()=>n,metadata:()=>o,toc:()=>p});var t=a(8168),i=(a(6540),a(5680));const n={},l="Circuite secven\u021biale",o={unversionedId:"Practic\u0103 Verilog AA AC/Laborator 3/README",id:"Practic\u0103 Verilog AA AC/Laborator 3/README",title:"Circuite secven\u021biale",description:"1. Registru elementar (5p)",source:"@site/docs/Practic\u0103 Verilog AA AC/Laborator 3/README.md",sourceDirName:"Practic\u0103 Verilog AA AC/Laborator 3",slug:"/Practic\u0103 Verilog AA AC/Laborator 3/",permalink:"/computer-architecture/Practic\u0103 Verilog AA AC/Laborator 3/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Circuite combina\u021bionale \u0219i secven\u021biale",permalink:"/computer-architecture/Practic\u0103 Verilog AA AC/Laborator 2/"},next:{title:"Evaluare",permalink:"/computer-architecture/Evaluare/"}},u={},p=[{value:"1. <strong>Registru elementar</strong> (5p)",id:"1-registru-elementar-5p",level:2},{value:"2. <strong>Automat secven\u021bial pentru multiplicare \u0219i afi\u0219are</strong> (5p)",id:"2-automat-secven\u021bial-pentru-multiplicare-\u0219i-afi\u0219are-5p",level:2}],m={toc:p},c="wrapper";function g({components:e,...r}){return(0,i.yg)(c,(0,t.A)({},m,r,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"circuite-secven\u021biale"},"Circuite secven\u021biale"),(0,i.yg)("h2",{id:"1-registru-elementar-5p"},"1. ",(0,i.yg)("strong",{parentName:"h2"},"Registru elementar")," (5p)"),(0,i.yg)("p",null,"Implementa\u021bi modulul ",(0,i.yg)("inlineCode",{parentName:"p"},"Register"),", care simuleaz\u0103 func\u021bionarea unui registru real.  "),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Hints:"),"  "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Semnalele ",(0,i.yg)("inlineCode",{parentName:"li"},"oe")," \u0219i ",(0,i.yg)("inlineCode",{parentName:"li"},"we")," reprezint\u0103 ",(0,i.yg)("strong",{parentName:"li"},"Output Enable")," \u0219i ",(0,i.yg)("strong",{parentName:"li"},"Write Enable"),".  "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"oe")," controleaz\u0103 ie\u0219irea registrului:  ",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"dac\u0103 ",(0,i.yg)("inlineCode",{parentName:"li"},"oe = 1"),", ie\u0219irea este activ\u0103 \u0219i afi\u0219eaz\u0103 valoarea memorat\u0103;  "),(0,i.yg)("li",{parentName:"ul"},"dac\u0103 ",(0,i.yg)("inlineCode",{parentName:"li"},"oe = 0"),", ie\u0219irea este ",(0,i.yg)("inlineCode",{parentName:"li"},"0"),".",(0,i.yg)("br",{parentName:"li"}),"Acest semnal trebuie s\u0103 fie ",(0,i.yg)("strong",{parentName:"li"},"asincron"),".  "))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"we")," controleaz\u0103 scrierea \xeen registru:  ",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"dac\u0103 ",(0,i.yg)("inlineCode",{parentName:"li"},"we = 1"),", valoarea de la intrare este memorat\u0103;  "),(0,i.yg)("li",{parentName:"ul"},"dac\u0103 ",(0,i.yg)("inlineCode",{parentName:"li"},"we = 0"),", valoarea nu se modific\u0103.",(0,i.yg)("br",{parentName:"li"}),"Acest semnal trebuie s\u0103 fie ",(0,i.yg)("strong",{parentName:"li"},"sincron")," (la tranzi\u021bia ceasului).  "))),(0,i.yg)("li",{parentName:"ul"},"Semnalul ",(0,i.yg)("inlineCode",{parentName:"li"},"disp_out")," este folosit pentru afi\u0219are/debugging \u0219i arat\u0103 mereu valoarea memorat\u0103 (independent de ",(0,i.yg)("inlineCode",{parentName:"li"},"oe"),").  "),(0,i.yg)("li",{parentName:"ul"},"Semnalul de reset ",(0,i.yg)("inlineCode",{parentName:"li"},"rst_n")," este activ pe ",(0,i.yg)("inlineCode",{parentName:"li"},"0"),".  "),(0,i.yg)("li",{parentName:"ul"},"Pute\u021bi folosi operatorul condi\u021bional (",(0,i.yg)("inlineCode",{parentName:"li"},"? :"),") pentru implementare.  ")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Expected outcome:"),"  "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Registrul memoreaz\u0103 corect valorile la scriere \u0219i controleaz\u0103 ie\u0219irea conform semnalelor ",(0,i.yg)("inlineCode",{parentName:"li"},"oe")," \u0219i ",(0,i.yg)("inlineCode",{parentName:"li"},"we"),".  "),(0,i.yg)("li",{parentName:"ul"},"Ie\u0219irea ",(0,i.yg)("inlineCode",{parentName:"li"},"disp_out")," reflect\u0103 permanent valoarea intern\u0103 a registrului.  "),(0,i.yg)("li",{parentName:"ul"},"La reset (",(0,i.yg)("inlineCode",{parentName:"li"},"rst_n = 0"),"), registrul revine la valoarea ini\u021bial\u0103.")),(0,i.yg)("hr",null),(0,i.yg)("h2",{id:"2-automat-secven\u021bial-pentru-multiplicare-\u0219i-afi\u0219are-5p"},"2. ",(0,i.yg)("strong",{parentName:"h2"},"Automat secven\u021bial pentru multiplicare \u0219i afi\u0219are")," (5p)"),(0,i.yg)("p",null,"Pornind de la interfa\u021ba modulului ",(0,i.yg)("inlineCode",{parentName:"p"},"sequential_multiplier")," din scheletul de cod, implementa\u021bi un ",(0,i.yg)("strong",{parentName:"p"},"automat de st\u0103ri")," care s\u0103 utilizeze instan\u021be parametrizate ale modulului ",(0,i.yg)("inlineCode",{parentName:"p"},"Register"),".  "),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Func\u021bionalit\u0103\u021bi cerute:"),"  "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"La activarea semnalului ",(0,i.yg)("inlineCode",{parentName:"li"},"write"),", valorile semnalelor ",(0,i.yg)("inlineCode",{parentName:"li"},"a")," \u0219i ",(0,i.yg)("inlineCode",{parentName:"li"},"b")," sunt scrise \xeen registrele corespunz\u0103toare.  "),(0,i.yg)("li",{parentName:"ul"},"La activarea semnalului ",(0,i.yg)("inlineCode",{parentName:"li"},"multiply"),", valorile sunt extrase, \xeenmul\u021bite, iar rezultatul este memorat \xeentr-un al treilea registru.  "),(0,i.yg)("li",{parentName:"ul"},"La activarea semnalului ",(0,i.yg)("inlineCode",{parentName:"li"},"display"),", semnalul ",(0,i.yg)("inlineCode",{parentName:"li"},"out")," va primi valoarea din al treilea registru.  "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Prioritate semnale:"),"  ",(0,i.yg)("ol",{parentName:"li"},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("inlineCode",{parentName:"li"},"write")," > 2. ",(0,i.yg)("inlineCode",{parentName:"li"},"multiply")," > 3. ",(0,i.yg)("inlineCode",{parentName:"li"},"display"),".  ")))),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Expected outcome:"),"  "),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Automat de st\u0103ri func\u021bional, cu tranzi\u021bii corecte \xeentre scriere, multiplicare \u0219i afi\u0219are.  "),(0,i.yg)("li",{parentName:"ul"},"Rezultatul multiplic\u0103rii este salvat \u0219i disponibil la afi\u0219are.  "),(0,i.yg)("li",{parentName:"ul"},"Simul\u0103rile valideaz\u0103 c\u0103 priorit\u0103\u021bile sunt respectate.")))}g.isMDXComponent=!0}}]);