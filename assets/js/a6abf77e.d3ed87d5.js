"use strict";(self.webpackChunkcomputer_architecture=self.webpackChunkcomputer_architecture||[]).push([[2682],{5680:(e,r,a)=>{a.d(r,{xA:()=>c,yg:()=>g});var i=a(6540);function t(e,r,a){return r in e?Object.defineProperty(e,r,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[r]=a,e}function n(e,r){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);r&&(i=i.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),a.push.apply(a,i)}return a}function u(e){for(var r=1;r<arguments.length;r++){var a=null!=arguments[r]?arguments[r]:{};r%2?n(Object(a),!0).forEach((function(r){t(e,r,a[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(a,r))}))}return e}function l(e,r){if(null==e)return{};var a,i,t=function(e,r){if(null==e)return{};var a,i,t={},n=Object.keys(e);for(i=0;i<n.length;i++)a=n[i],r.indexOf(a)>=0||(t[a]=e[a]);return t}(e,r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)a=n[i],r.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var d=i.createContext({}),s=function(e){var r=i.useContext(d),a=r;return e&&(a="function"==typeof e?e(r):u(u({},r),e)),a},c=function(e){var r=s(e.components);return i.createElement(d.Provider,{value:r},e.children)},p="mdxType",o={inlineCode:"code",wrapper:function(e){var r=e.children;return i.createElement(i.Fragment,{},r)}},m=i.forwardRef((function(e,r){var a=e.components,t=e.mdxType,n=e.originalType,d=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=s(a),m=t,g=p["".concat(d,".").concat(m)]||p[m]||o[m]||n;return a?i.createElement(g,u(u({ref:r},c),{},{components:a})):i.createElement(g,u({ref:r},c))}));function g(e,r){var a=arguments,t=r&&r.mdxType;if("string"==typeof e||t){var n=a.length,u=new Array(n);u[0]=m;var l={};for(var d in r)hasOwnProperty.call(r,d)&&(l[d]=r[d]);l.originalType=e,l[p]="string"==typeof e?e:t,u[1]=l;for(var s=2;s<n;s++)u[s]=a[s];return i.createElement.apply(null,u)}return i.createElement.apply(null,a)}m.displayName="MDXCreateElement"},4584:(e,r,a)=>{a.r(r),a.d(r,{assets:()=>d,contentTitle:()=>u,default:()=>o,frontMatter:()=>n,metadata:()=>l,toc:()=>s});var i=a(8168),t=(a(6540),a(5680));const n={},u="Moduri de adresare",l={unversionedId:"Laboratoare/9 Calculator Didactic/Moduri de adresare/Teorie/README",id:"Laboratoare/9 Calculator Didactic/Moduri de adresare/Teorie/README",title:"Moduri de adresare",description:"Modurile de adresare reprezint\u0103 modalitatea prin care se poate specifica adresa efectiv\u0103 a operanzilor. Instruc\u021biunile calculatorului didactic pot prelucra maxim doi operanzi ce se pot g\u0103si:",source:"@site/docs/Laboratoare/9 Calculator Didactic/Moduri de adresare/Teorie/README.md",sourceDirName:"Laboratoare/9 Calculator Didactic/Moduri de adresare/Teorie",slug:"/Laboratoare/9 Calculator Didactic/Moduri de adresare/Teorie/",permalink:"/computer-architecture/Laboratoare/9 Calculator Didactic/Moduri de adresare/Teorie/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Moduri de adresare",permalink:"/computer-architecture/Laboratoare/9 Calculator Didactic/Moduri de adresare/"}},d={},s=[{value:"Operandul nu se g\u0103se\u0219te \xeen memorie",id:"operandul-nu-se-g\u0103se\u0219te-\xeen-memorie",level:2},{value:"1. Adresare direct\u0103 la registru",id:"1-adresare-direct\u0103-la-registru",level:3},{value:"2. Adresare imediat\u0103",id:"2-adresare-imediat\u0103",level:3},{value:"3. Adresare direct\u0103",id:"3-adresare-direct\u0103",level:3},{value:"4. Adresare indirect\u0103",id:"4-adresare-indirect\u0103",level:3},{value:"Operandul e specificat doar prin registre",id:"operandul-e-specificat-doar-prin-registre",level:2},{value:"5. Adresare indirect\u0103 prin registru",id:"5-adresare-indirect\u0103-prin-registru",level:3},{value:"6. Adresare indirect\u0103 prin sum\u0103 de registre",id:"6-adresare-indirect\u0103-prin-sum\u0103-de-registre",level:3},{value:"7. Adresare indirect\u0103 prin sum\u0103 de registre cu autoincrementare",id:"7-adresare-indirect\u0103-prin-sum\u0103-de-registre-cu-autoincrementare",level:3},{value:"8. Adresare indirect\u0103 prin sum\u0103 de registre cu autodecrementare",id:"8-adresare-indirect\u0103-prin-sum\u0103-de-registre-cu-autodecrementare",level:3},{value:"Operandul e specificat prin registre \u0219i deplasament",id:"operandul-e-specificat-prin-registre-\u0219i-deplasament",level:2},{value:"9. Adresare bazat\u0103",id:"9-adresare-bazat\u0103",level:3},{value:"10. Adresare indexat\u0103",id:"10-adresare-indexat\u0103",level:3},{value:"11. Adresare bazat\u0103 indexat\u0103",id:"11-adresare-bazat\u0103-indexat\u0103",level:3},{value:"Calculatorul didactic",id:"calculatorul-didactic",level:2},{value:"Adresarea indirect\u0103 prin registru",id:"adresarea-indirect\u0103-prin-registru",level:3},{value:"Adresarea indirect\u0103 prin sum\u0103 de registre",id:"adresarea-indirect\u0103-prin-sum\u0103-de-registre",level:3},{value:"Implementare",id:"implementare",level:3}],c={toc:s},p="wrapper";function o(e){let{components:r,...n}=e;return(0,t.yg)(p,(0,i.A)({},c,n,{components:r,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"moduri-de-adresare"},"Moduri de adresare"),(0,t.yg)("p",null,"Modurile de adresare reprezint\u0103 modalitatea prin care se poate specifica adresa efectiv\u0103 a operanzilor. Instruc\u021biunile calculatorului didactic pot prelucra maxim doi operanzi ce se pot g\u0103si:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Ambii \xeen registrele generale RG;"),(0,t.yg)("li",{parentName:"ul"},"Unul \xeen registrele generale RG \u0219i altul \xeen memorie;"),(0,t.yg)("li",{parentName:"ul"},"Unul \xeen registrele generale RG \u0219i altul \xeen cadrul instruc\u021biunii respective (numit operand imediat);"),(0,t.yg)("li",{parentName:"ul"},"Unul \xeen memorie \u0219i altul imediat.")),(0,t.yg)("p",null,"Modurile de adresare permise de calculatorul didactic sunt tipice arhitecturilor CISC, fiind derivate din arhitectura standard x86. \xcen total, procesorul permite 11 moduri de adresare, ceea ce \xeei confer\u0103 o foarte bun\u0103 flexibilitate \xeen programare. Pentru o mai u\u0219oar\u0103 \xeen\u021belegere, le vom structura astfel:"),(0,t.yg)("table",null,(0,t.yg)("thead",{parentName:"table"},(0,t.yg)("tr",{parentName:"thead"},(0,t.yg)("th",{parentName:"tr",align:null},(0,t.yg)("strong",{parentName:"th"},"Specificarea operandului")),(0,t.yg)("th",{parentName:"tr",align:null},(0,t.yg)("strong",{parentName:"th"},"Moduri de adresare")))),(0,t.yg)("tbody",{parentName:"table"},(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"Operandul nu se g\u0103se\u015fte \xeen memorie"),(0,t.yg)("td",{parentName:"tr",align:null},"Adresare direct\u0103 la registru, Adresare imediat\u0103")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"Operandul e specificat doar prin deplasament"),(0,t.yg)("td",{parentName:"tr",align:null},"Adresare direct\u0103, Adresare indirect\u0103")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"Operandul e specificat doar prin registre"),(0,t.yg)("td",{parentName:"tr",align:null},"Adresare indirect\u0103 prin registru, Adresare indirect\u0103 prin suma de registre, Adresare indirect\u0103 prin suma de registre cu autoincrementare, Adresare indirect\u0103 prin suma de registre cu autodecrementare")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"Operandul e specificat prin registre \u0219i deplasament"),(0,t.yg)("td",{parentName:"tr",align:null},"Adresare Bazat\u0103, Adresare Indexat\u0103, Adresare Bazat\u0103 Indexat\u0103")))),(0,t.yg)("p",null,"\xcen continuare vor fi prezentate \u0219i discutate aceste moduri de adresare."),(0,t.yg)("h2",{id:"operandul-nu-se-g\u0103se\u0219te-\xeen-memorie"},"Operandul nu se g\u0103se\u0219te \xeen memorie"),(0,t.yg)("h3",{id:"1-adresare-direct\u0103-la-registru"},"1. Adresare direct\u0103 la registru"),(0,t.yg)("p",null,"Operandul se g\u0103se\u015fte \xeen RG."),(0,t.yg)("p",null,"Exemplu: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, RB")),(0,t.yg)("p",null,"Instruc\u021biunea are ca efect \xeenc\u0103rcarea \xeen registrul RA a valorii din registrul RB."),(0,t.yg)("h3",{id:"2-adresare-imediat\u0103"},"2. Adresare imediat\u0103"),(0,t.yg)("p",null,"Operandul este specificat \xeen instruc\u021biune."),(0,t.yg)("p",null,"Exemplu: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, 7")),(0,t.yg)("p",null,'Instruc\u021biunea va avea ca efect \xeencarcarea valorii "7" \xeen registrul RA. "7" poart\u0103 numele de operand imediat.'),(0,t.yg)("p",null,"###= Operandul e specificat doar prin deplasament ###="),(0,t.yg)("h3",{id:"3-adresare-direct\u0103"},"3. Adresare direct\u0103"),(0,t.yg)("p",null,"Adresa efectiv\u0103 este specificat\u0103 \xeen instruc\u021biune."),(0,t.yg)("p",null,"Exemplu: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [12]")),(0,t.yg)("p",null,'Instruc\u021biunea va \xeenc\u0103rca valorea aflat\u0103 \xeen memorie la adresa "12" \xeen registrul RA. "12" poarta numele de deplasament.'),(0,t.yg)("h3",{id:"4-adresare-indirect\u0103"},"4. Adresare indirect\u0103"),(0,t.yg)("p",null,"Adresa efectiv\u0103 se cite\u0219te din memorie, din loca\u021bia a c\u0103rei adres\u0103 este specificat\u0103 \xeen instruc\u021biune."),(0,t.yg)("p",null,"Exemplu: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [[12]]")),(0,t.yg)("p",null,'Instruc\u021biunea are ca efect \xeenc\u0103rcarea valorii aflat\u0103 la adresa ce se g\u0103se\u0219te \xeen memorie la adresa "12". Acest mod de adresare seaman\u0103 foarte bine cu pointerii din C. La adresa "12" se g\u0103se\u0219te pointer-ul c\u0103tre operand.'),(0,t.yg)("h2",{id:"operandul-e-specificat-doar-prin-registre"},"Operandul e specificat doar prin registre"),(0,t.yg)("h3",{id:"5-adresare-indirect\u0103-prin-registru"},"5. Adresare indirect\u0103 prin registru"),(0,t.yg)("p",null,"Adresa efectiv\u0103 se g\u0103se\u0219te \xeen unul din registrele XA, XB, BA, BB."),(0,t.yg)("p",null,"Exemplu: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [BA]")),(0,t.yg)("p",null,"Instruc\u021biunea va \xeenc\u0103rca \xeen RA valoarea aflat\u0103 \xeen memorie la adresa con\u021binut\u0103 \xeen BA."),(0,t.yg)("h3",{id:"6-adresare-indirect\u0103-prin-sum\u0103-de-registre"},"6. Adresare indirect\u0103 prin sum\u0103 de registre"),(0,t.yg)("p",null,"Adresa efectiv\u0103 se ob\u021bine ca sum\u0103 a con\u021binutului unui registru de baz\u0103 cu con\u021binutul unui registru index."),(0,t.yg)("p",null,"Exemplu: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [BA][XA]")," sau ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [BA+XA]")),(0,t.yg)("p",null,"Instruc\u021biunile \xeencarc\u0103 \xeen RA valoarea aflat\u0103 \xeen memorie la adresa ob\u021binut\u0103 prin adunarea con\u021binutului registrelor BA \u0219i XA. BA, BB poart\u0103 numele de registre de baz\u0103, iar XA, XB poart\u0103 numele de registre index. \xcentotdeauna suma se va face \xeentre un registru baz\u0103 \u0219i unul index."),(0,t.yg)("h3",{id:"7-adresare-indirect\u0103-prin-sum\u0103-de-registre-cu-autoincrementare"},"7. Adresare indirect\u0103 prin sum\u0103 de registre cu autoincrementare"),(0,t.yg)("p",null,"Fa\u021b\u0103 de modul precedent de adresare apare deosebirea c\u0103 registrele index se incrementeaz\u0103 dup\u0103 generarea adresei efective. Incrementarea registrului index (XA sau XB) are deci loc dup\u0103 participarea la calculul adresei efective."),(0,t.yg)("p",null,"Exemplu: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [BA][XA+]")," sau ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [BA+XA+]")),(0,t.yg)("p",null,"Aceste instruc\u021biuni sunt echivalente cu:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-asm"},"MOV RA, [BA][XA]\nINC XA\n")),(0,t.yg)("h3",{id:"8-adresare-indirect\u0103-prin-sum\u0103-de-registre-cu-autodecrementare"},"8. Adresare indirect\u0103 prin sum\u0103 de registre cu autodecrementare"),(0,t.yg)("p",null,"Adresa efectiv\u0103 se ob\u021bine prin suma unui registru de baz\u0103 cu continutul registrului XA. \xcenaintea gener\u0103rii adresei, registrul XA este decrementat."),(0,t.yg)("p",null,"Exemplu: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [BA][XA-]")," sau ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [BA+XA-]")),(0,t.yg)("p",null,"Aceste instruc\u021biuni sunt echivalente cu:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-asm"},"DEC XA\nMOV RA, [BA][XA]\n")),(0,t.yg)("p",null,"Observa\u021bii: Motivul pentru care XB nu poate fi utilizat \xeen acest mod de adresare nu este unul logic, ci unul tehnic: bi\u021bii din codul de instruc\u021biune nu au fost suficien\u021bi pentru a se putea codifica \u0219i acest mod."),(0,t.yg)("h2",{id:"operandul-e-specificat-prin-registre-\u0219i-deplasament"},"Operandul e specificat prin registre \u0219i deplasament"),(0,t.yg)("h3",{id:"9-adresare-bazat\u0103"},"9. Adresare bazat\u0103"),(0,t.yg)("p",null,"Adresa efectiv\u0103 se ob\u021bine prin adunarea unui registru de baz\u0103 cu un deplasament."),(0,t.yg)("p",null,"Exemplu: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [BA]+7")," sau ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [BA+7]")),(0,t.yg)("p",null,"Instruc\u021biunea \xeencarc\u0103 \xeen registrul RA valoarea aflat\u0103 \xeen memorie la adresa rezultat\u0103 \xeen urma adun\u0103rii con\u021binutului registrului de baz\u0103 cu deplasamentul (7)."),(0,t.yg)("h3",{id:"10-adresare-indexat\u0103"},"10. Adresare indexat\u0103"),(0,t.yg)("p",null,"Adresa efectiv\u0103 se ob\u021bine prin adunarea unui registru index cu un deplasament."),(0,t.yg)("p",null,"Exemplu: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [XA]+7")," sau ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [XA+7]")),(0,t.yg)("p",null,"Instruc\u021biunea \xeencarc\u0103 \xeen registrul RA valoarea aflat\u0103 \xeen memorie la adresa rezultat\u0103 \xeen urma adun\u0103rii con\u021binutului registrului de index cu deplasamentul (7)."),(0,t.yg)("h3",{id:"11-adresare-bazat\u0103-indexat\u0103"},"11. Adresare bazat\u0103 indexat\u0103"),(0,t.yg)("p",null,"Adresa efectiv\u0103 se ob\u021bine prin adunarea unui registru de baz\u0103 cu un registru index \u0219i cu un deplasament."),(0,t.yg)("p",null,"Exemplu: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [BA][XA]+7")," sau ",(0,t.yg)("inlineCode",{parentName:"p"},"asm MOV RA, [BA+XA+7]")),(0,t.yg)("p",null,"Instruc\u021biunea \xeencarc\u0103 \xeen registrul RA valoarea aflat\u0103 \xeen memorie la adresa rezultat\u0103 \xeen urma adun\u0103rii con\u021binutului registrului de baz\u0103 (BA) cu registrul index (XA) \u0219i cu deplasamentul (7)."),(0,t.yg)("h2",{id:"calculatorul-didactic"},"Calculatorul didactic"),(0,t.yg)("p",null,"Procesorul calculatorului didactic suport\u0103 mai multe moduri de adresare a operanzilor. P\xe2n\u0103 acum am tratat doar cazul operanzilor afla\u021bi \xeen registre (adresare direct\u0103 la registru), identificat prin c\xe2mpul ",(0,t.yg)("em",{parentName:"p"},"MOD")," av\xe2nd valoarea ",(0,t.yg)("em",{parentName:"p"},"11"),". Cu acest mod de adresare suntem \xeens\u0103 limita\u021bi la a lucra numai cu cele 8 registre generale. Pentru a putea lucra \u0219i cu date aflate \xeen memoria RAM, procesorul calculatorului didactic ofer\u0103 o serie de alte moduri de \xeenc\u0103rcare a operanzilor."),(0,t.yg)("p",null,"\xcenc\u0103rcarea unui operand din memoria RAM necesit\u0103 determinarea adresei la care se afl\u0103 stocat acel operand. Aceasta poate fi stocat\u0103 direct \xeen instruc\u021biune, cum se \xeent\xe2mpl\u0103 \xeen cazul adres\u0103rii directe, unde instruc\u021biunea este format\u0103 din 2 cuvinte (pe 16 bi\u021bi), iar al doilea cuv\xe2nt con\u021bine valoarea adresei (numit\u0103 \u0219i deplasament), sau poate fi calculat\u0103 folosind diferite combina\u021bii de registre cu/f\u0103r\u0103 deplasament. Calculul se face prin adunarea valorilor curente ale unor registre (nu toate combina\u021biile sunt suportate) \u0219i folosirea valorii rezultate ca o adres\u0103 pentru memorie."),(0,t.yg)("h3",{id:"adresarea-indirect\u0103-prin-registru"},"Adresarea indirect\u0103 prin registru"),(0,t.yg)("p",null,"Adresa efectiv\u0103 se g\u0103se\u0219te \xeentr-unul din registrele ",(0,t.yg)("em",{parentName:"p"},"XA"),", ",(0,t.yg)("em",{parentName:"p"},"XB"),", ",(0,t.yg)("em",{parentName:"p"},"BA")," sau ",(0,t.yg)("em",{parentName:"p"},"BB"),". Modul de determinare a acesteia este prezentat \xeen imaginea de mai jos."),(0,t.yg)("p",null,"Ex: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm mov RA, [BA]")),(0,t.yg)("p",null,(0,t.yg)("img",{alt:"Adresare indirect\u0103 prin registru",src:a(4902).A,width:"500",height:"207"})),(0,t.yg)("p",null,(0,t.yg)("em",{parentName:"p"},"Figure: Adresare indirect\u0103 prin registru")),(0,t.yg)("h3",{id:"adresarea-indirect\u0103-prin-sum\u0103-de-registre"},"Adresarea indirect\u0103 prin sum\u0103 de registre"),(0,t.yg)("p",null,"Adresa efectiv\u0103 se ob\u021bine prin sumarea con\u021binutului unui registru de baz\u0103 (",(0,t.yg)("em",{parentName:"p"},"BA")," sau ",(0,t.yg)("em",{parentName:"p"},"BB"),") cu con\u021binutul unui registru index (",(0,t.yg)("em",{parentName:"p"},"XA")," sau ",(0,t.yg)("em",{parentName:"p"},"XB"),"). Modul de determinare a acesteia este prezentat \xeen imaginea de mai jos. "),(0,t.yg)("p",null,"Ex: ",(0,t.yg)("inlineCode",{parentName:"p"},"asm mov RA, [BA + XA]")),(0,t.yg)("p",null,(0,t.yg)("img",{alt:"Adresare indirect\u0103 prin sum\u0103 de registre",src:a(5873).A,width:"500",height:"301"})),(0,t.yg)("p",null,(0,t.yg)("em",{parentName:"p"},"Figure: Adresare indirect\u0103 prin sum\u0103 de registre")),(0,t.yg)("h3",{id:"implementare"},"Implementare"),(0,t.yg)("p",null,"Automatul care trebuie implementat \xeen UC este descris \xeen diagrama de st\u0103ri din figura de mai jos."),(0,t.yg)("p",null,(0,t.yg)("img",{alt:"Diagrama de st\u0103ri a unit\u0103\u021bii de comand\u0103",src:a(1870).A,width:"1156",height:"1111"})),(0,t.yg)("p",null,(0,t.yg)("em",{parentName:"p"},"Figure: Diagrama de st\u0103ri a unit\u0103\u021bii de comand\u0103")),(0,t.yg)("p",null,"Dup\u0103 cum pute\u021bi observa, la st\u0103rile deja implementate \xeen laboratoarele anterioare au fost ad\u0103ugate o serie de st\u0103ri noi, necesare pentru adresarea indirect\u0103 prin registru sau sum\u0103 de registre. \xcen cadrul acestui laborator va trebui s\u0103 implementa\u021bi aceste noi st\u0103ri \u0219i s\u0103 completa\u021bi condi\u021biile corecte pentru decodificarea noilor moduri de adresare."),(0,t.yg)("p",null,"Memoria calculatorului didactic este implementat\u0103 cu ajutorul unui IP Core Xilinx de tipul Block Memory. Parametrii unui core sunt stoca\u021bi \xeentr-un fi\u0219ier ",(0,t.yg)("em",{parentName:"p"},".xco"),". Acest fi\u0219ier este folosit de utilitarul de generare a IP Core-urilor pentru a genera o instan\u021b\u0103 a core-ului selectat. Core-ul de tip Block Memory ofer\u0103 o serie de parametri care pot fi configura\u021bi, precum dimensiunea cuv\xe2ntului, num\u0103rul de cuvinte \u0219i semnalele disponibile. Block Memory ofer\u0103 \u0219i posibilitatea ini\u021bializ\u0103rii memoriei \xeen momentul gener\u0103rii. Con\u021binutul memoriei poate fi specificat \xeentr-un fi\u0219ier ",(0,t.yg)("em",{parentName:"p"},".coe")," referen\u021biat apoi de fi\u0219ierul ",(0,t.yg)("em",{parentName:"p"},".xco"),". \xcen figura de mai jos pute\u021bi observa formatul fi\u0219ierul ",(0,t.yg)("em",{parentName:"p"},".coe"),". Valorile din fi\u0219ier sunt mapate \xeen memoria generat\u0103 \xeencep\xe2nd de la adresa 0."),(0,t.yg)("p",null,(0,t.yg)("img",{alt:"Fi\u0219ierul ram.coe",src:a(8730).A,width:"437",height:"408"})),(0,t.yg)("p",null,(0,t.yg)("em",{parentName:"p"},"Figure: Fi\u0219ierul ram.coe")),(0,t.yg)("p",null,"Con\u021binutul ini\u021bial al memoriei calculatorului didactic se g\u0103se\u0219te \xeen cadrul acestui fi\u0219ier. Dup\u0103 fiecare modificare a fi\u0219ierului ",(0,t.yg)("em",{parentName:"p"},".coe"),", memoria care folose\u0219te acel fi\u0219ier trebuie regenerat\u0103. \xcen cazul nostru, dup\u0103 modificarea fi\u0219ierului ",(0,t.yg)("em",{parentName:"p"},"ram.coe")," trebuie regenerat modulul ",(0,t.yg)("em",{parentName:"p"},"ram")," pentru ca modific\u0103rile s\u0103 aib\u0103 efect. Pentru aceasta, se selecteaz\u0103 din fereastra ",(0,t.yg)("em",{parentName:"p"},"Sources")," modulul ",(0,t.yg)("em",{parentName:"p"},"ram"),", iar din fereastra ",(0,t.yg)("em",{parentName:"p"},"Processes")," se ini\u021biaz\u0103 regenerarea, cu op\u021biunea ",(0,t.yg)("em",{parentName:"p"},"Regenerate Core"),"."))}o.isMDXComponent=!0},4902:(e,r,a)=>{a.d(r,{A:()=>i});const i=a.p+"assets/images/addr_reg-9345cd189da054f2481dde18b1e7c96e.png"},5873:(e,r,a)=>{a.d(r,{A:()=>i});const i=a.p+"assets/images/addr_sum-b1da42eeb86dcf337e3616b3dee58682.png"},8730:(e,r,a)=>{a.d(r,{A:()=>i});const i=a.p+"assets/images/change_coe-029f22d80a716899f3da46c77a0a3089.png"},1870:(e,r,a)=>{a.d(r,{A:()=>i});const i=a.p+"assets/images/mod_00_states-7a54563a2ddfd79de61b0f62630cc8c1.png"}}]);