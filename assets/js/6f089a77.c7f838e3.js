"use strict";(globalThis.webpackChunkcomputer_architecture=globalThis.webpackChunkcomputer_architecture||[]).push([[9695],{5680:(e,a,t)=>{t.d(a,{xA:()=>s,yg:()=>g});var r=t(6540);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),t.push.apply(t,r)}return t}function u(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach(function(a){n(e,a,t[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})}return e}function l(e,a){if(null==e)return{};var t,r,n=function(e,a){if(null==e)return{};var t,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var o=r.createContext({}),c=function(e){var a=r.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):u(u({},a),e)),t},s=function(e){var a=c(e.components);return r.createElement(o.Provider,{value:a},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},m=r.forwardRef(function(e,a){var t=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),p=c(t),m=n,g=p["".concat(o,".").concat(m)]||p[m]||d[m]||i;return t?r.createElement(g,u(u({ref:a},s),{},{components:t})):r.createElement(g,u({ref:a},s))});function g(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var i=t.length,u=new Array(i);u[0]=m;var l={};for(var o in a)hasOwnProperty.call(a,o)&&(l[o]=a[o]);l.originalType=e,l[p]="string"==typeof e?e:n,u[1]=l;for(var c=2;c<i;c++)u[c]=t[c];return r.createElement.apply(null,u)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5848:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>u,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=t(8168),n=(t(6540),t(5680));const i={},u="Folosirea RHDL in Vivado",l={unversionedId:"Laboratoare AB/5 Sinteza/Vivado RHDL/README",id:"Laboratoare AB/5 Sinteza/Vivado RHDL/README",title:"Folosirea RHDL in Vivado",description:"In mare parte, noi cand scriem codul RHDL, o sa il convertim in Verilog, XDC si TCL. TCL-ul va fi rulat cu Vivado pentru a sintetiza codul in un bitstream si flashui placuta de laborator.",source:"@site/docs/Laboratoare AB/5 Sinteza/Vivado RHDL/README.md",sourceDirName:"Laboratoare AB/5 Sinteza/Vivado RHDL",slug:"/Laboratoare AB/5 Sinteza/Vivado RHDL/",permalink:"/computer-architecture/Laboratoare AB/5 Sinteza/Vivado RHDL/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Sinteza circuitelor digitale",permalink:"/computer-architecture/Laboratoare AB/5 Sinteza/Sintetizare/"},next:{title:"Exercitii",permalink:"/computer-architecture/Laboratoare AB/5 Sinteza/Exercitii/"}},o={},c=[{value:"Fixture",id:"fixture",level:2},{value:"Circuit",id:"circuit",level:3},{value:"Adapter",id:"adapter",level:4},{value:"Driver",id:"driver",level:3},{value:"rhdl_bsp",id:"rhdl_bsp",level:3},{value:"Constrangeri",id:"constrangeri",level:4},{value:"TCL",id:"tcl",level:4}],s={toc:c},p="wrapper";function d({components:e,...a}){return(0,n.yg)(p,(0,r.A)({},s,a,{components:e,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"folosirea-rhdl-in-vivado"},"Folosirea RHDL in Vivado"),(0,n.yg)("p",null,"In mare parte, noi cand scriem codul RHDL, o sa il convertim in Verilog, XDC si TCL. TCL-ul va fi rulat cu Vivado pentru a sintetiza codul in un bitstream si flashui placuta de laborator."),(0,n.yg)("h2",{id:"fixture"},"Fixture"),(0,n.yg)("p",null,"Un Fixture este un wrapper peste circuitele noastre. El ne da posibilitatea de a redenumi semnalele (dupa cum ati observat, pana acuma mereu erau in VCD puse toate semnalele la gramada in porturile input/output)"),(0,n.yg)("p",null,"Pentru a putea crea un Fixture, trebuie ca structura noastra sa implementeze ",(0,n.yg)("inlineCode",{parentName:"p"},"Circuit"),"."),(0,n.yg)("h3",{id:"circuit"},"Circuit"),(0,n.yg)("p",null,"Un trait care reprezinta cea mai pura forma a unui circuit RHDL. Acesta trebuie sa respecte anumite conditii, anume sa aibe inputuri si outputuri sa fie Timed. Acest trait il are doar tipul ",(0,n.yg)("inlineCode",{parentName:"p"},"Signal<T: Digital, D: Domain>")," by default. Interfetele Synchronous abstractizeaza inputurile si outputurile sale astfel incat sa fie nevoie doar de Digital, deoarece ele opereaza in acelasi Clock Domain. Totusi acestea nu implementeaza ",(0,n.yg)("inlineCode",{parentName:"p"},"Circuit"),"."),(0,n.yg)("p",null,"Pentru a face asta, ne trebuie un ",(0,n.yg)("inlineCode",{parentName:"p"},"Adapter")),(0,n.yg)("h4",{id:"adapter"},"Adapter"),(0,n.yg)("p",null,"Adapterul ia un circuit Synchronous si ne face sa il putem folosi in un context Asynchronous pe un domain oarecare."),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-rust"},"struct Adapter<T: Synchronous, D: Domain> { ... }\n")),(0,n.yg)("p",null,"unde T e circuitul nostru, si D e un clock domain. In general vom lucra cu un singur Clock Domain in toata ierarhia noastra de module."),(0,n.yg)("p",null,"Sintaxa de declarare este"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-rust"},"let x: Adapter<MyCircuit, Red> = Adapter::new(MyCircuit::default())\n")),(0,n.yg)("p",null,"unde Red e un Clock Domain oarecare declarat in prelude."),(0,n.yg)("h3",{id:"driver"},"Driver"),(0,n.yg)("p",null,"Un fixture poate sa aibe mai multe drivere. In general, un circuit inner\npoate sa aibe aceste valori redenumite, chiar si wrapped in functionalitate printr-un driver."),(0,n.yg)("p",null,"Acesta tine minte si constrangerile fiecarui pin imparte cu care are de a face."),(0,n.yg)("p",null,"Metodele de baza sunt"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-rust"},"// Adds a driver for an inner input\nfn pass_through_input(&mut self, name: &str, path: &Path);\n// Adds a driver for an inner output\nfn pass_through_output(&mut self, name: &str, path: &Path);\n// Drives an inner input with a constant value of choice\nfn constant_driver<S: Digital>(&mut self, val: S, path: &Path);\n// Adds a custom driver\nfn add_driver(&mut self, driver: Driver<T>);\n")),(0,n.yg)("p",null,"Drivere custom gasiti in ",(0,n.yg)("inlineCode",{parentName:"p"},"chapters/rhdl/nexys-a7")," pentru placuta noastra"),(0,n.yg)("p",null,"acestea se pot declara in felul urmator:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-rust"},'    // Driver de clock pentru nexys a7, stie exact ce pin se foloseste, se bazeaza ca dai clock mereu, altfel da RHDLError\n    fixture.add_driver(nexys_a7::drivers::sys_clk::sys_clock(\n        &path!(.clock_reset.val().clock),\n    )?);\n    fixture.constant_input(reset(false), &path!(.clock_reset.val().reset))?;\n    // Driver de output, primeste un name, path si optiuni, analog pentru input\n    fixture.add_driver(nexys_a7::drivers::output::build(\n        "rst",\n        &path!(.val()),\n        &lvcmos33_out(&LEDS, 0..8)\n    )?);\n')),(0,n.yg)("h3",{id:"rhdl_bsp"},"rhdl_bsp"),(0,n.yg)("p",null,"In acest crate, avem utilitare pentru a putea crea constrangeri si scripturi pentru Vivado. Dar pentru asta, trebuie sa intelegem workflow-ul acestuia"),(0,n.yg)("h4",{id:"constrangeri"},"Constrangeri"),(0,n.yg)("p",null,"Trebuie sa declaram intrarile si iesirile mapate la fire din design-ul nostru, acest lucru se face prin un fisier XDC care contine linii de genul acesta:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-tcl"},"set_property -dict { PACKAGE_PIN E1    IOSTANDARD LVCMOS33 } [get_ports { led0_b }]; #IO_L18N_T2_35 Sch=led0_b\n")),(0,n.yg)("p",null,"spre exemplu, led0_b este un fir de output din design-ul nostru top, E1 reprezinta placementul din ",(0,n.yg)("inlineCode",{parentName:"p"},"Ball Grid Array"),"-ul de pe spatele chipului FPGA. E e randul, 1 e coloana. Acesta se poate declara folosind macro-ul bga_pin!(E,1). Mai e si IOSTANDARD-ul, care in cazul nostru e LowVoltageCMOS3v3. Acesta reprezinta tehnologia folosita pentru IO."),(0,n.yg)("p",null,"Dupa cum a fost povestit in sectiunea anterioara, avem mai multe IO Bank-uri. Se doreste ca IOSTANDARD-ul pe un bank IO sa fie comun. Pe placuta noastra de dezvoltare, perifericele sunt proiectate cu LVCMOS33, deci nu vom schimba nimic aici. Exista un enum numit IOStandard care contine cateva standarde comune(toate le gasiti in datasheet)"),(0,n.yg)("h4",{id:"tcl"},"TCL"),(0,n.yg)("p",null,"Scurt pentru Tool Command Line, este limbajul de scripting folosit de Vivado. Pentru a nu fi nevoiti sa deschidem IDE-ul Vivado, putem rula un script tcl cu comanda ",(0,n.yg)("inlineCode",{parentName:"p"},"vivado -mode batch -source run.tcl")),(0,n.yg)("p",null,"Acest script este facut de Builder-ul de Vivado aflat tot in crate-ul rhdl_bsp, iar in schelet tot ce facem e sa cream un proiect, adaugam fixture-ul nostru si generam bitstreamul."))}d.isMDXComponent=!0}}]);