"use strict";(globalThis.webpackChunkcomputer_architecture=globalThis.webpackChunkcomputer_architecture||[]).push([[4412],{5680:(e,n,a)=>{a.d(n,{xA:()=>m,yg:()=>d});var t=a(6540);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach(function(n){r(e,n,a[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))})}return e}function u(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=t.createContext({}),p=function(e){var n=t.useContext(o),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},m=function(e){var n=p(e.components);return t.createElement(o.Provider,{value:n},e.children)},g="mdxType",s={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef(function(e,n){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,m=u(e,["components","mdxType","originalType","parentName"]),g=p(a),c=r,d=g["".concat(o,".").concat(c)]||g[c]||s[c]||i;return a?t.createElement(d,l(l({ref:n},m),{},{components:a})):t.createElement(d,l({ref:n},m))});function d(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=c;var u={};for(var o in n)hasOwnProperty.call(n,o)&&(u[o]=n[o]);u.originalType=e,u[g]="string"==typeof e?e:r,l[1]=u;for(var p=2;p<i;p++)l[p]=a[p];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}c.displayName="MDXCreateElement"},9805:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>s,frontMatter:()=>i,metadata:()=>u,toc:()=>p});var t=a(8168),r=(a(6540),a(5680));const i={},l="00 \u2013 Introducere \xeen Rust",u={unversionedId:"Laboratoare AB/1 Limbajul Rust/Intro to rust/Teorie/README",id:"Laboratoare AB/1 Limbajul Rust/Intro to rust/Teorie/README",title:"00 \u2013 Introducere \xeen Rust",description:"Vom folosi limbajul de programare Rust pentru laboratoare.",source:"@site/docs/Laboratoare AB/1 Limbajul Rust/Intro to rust/Teorie/README.md",sourceDirName:"Laboratoare AB/1 Limbajul Rust/Intro to rust/Teorie",slug:"/Laboratoare AB/1 Limbajul Rust/Intro to rust/Teorie/",permalink:"/computer-architecture/Laboratoare AB/1 Limbajul Rust/Intro to rust/Teorie/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Intro to rust",permalink:"/computer-architecture/Laboratoare AB/1 Limbajul Rust/Intro to rust/"},next:{title:"2 RHDL Combinational",permalink:"/computer-architecture/Laboratoare AB/2 RHDL Combinational/"}},o={},p=[{value:"Resurse",id:"resurse",level:2},{value:"Biblioteca standard",id:"biblioteca-standard",level:2},{value:"Func\u021bia <code>main</code>",id:"func\u021bia-main",level:2},{value:"Variabile \u0219i mutabilitate",id:"variabile-\u0219i-mutabilitate",level:2},{value:"Constante",id:"constante",level:2},{value:"Tipuri de date",id:"tipuri-de-date",level:2},{value:"Tipuri scalare",id:"tipuri-scalare",level:3},{value:"Structuri",id:"structuri",level:3},{value:"Implementarea structurii",id:"implementarea-structurii",level:4},{value:"Afi\u0219area structurilor",id:"afi\u0219area-structurilor",level:4},{value:"Structuri tuple",id:"structuri-tuple",level:3},{value:"Enumuri",id:"enumuri",level:3},{value:"Enumul <code>Option</code>",id:"enumul-option",level:4},{value:"<code>match</code>",id:"match",level:4},{value:"Enumul <code>Result</code>",id:"enumul-result",level:4},{value:"Operatorul <code>?</code>",id:"operatorul-",level:5},{value:"Func\u021bii",id:"func\u021bii",level:2},{value:"Parametri",id:"parametri",level:4},{value:"Func\u021bii cu valori de retur",id:"func\u021bii-cu-valori-de-retur",level:4},{value:"Flux de control",id:"flux-de-control",level:2},{value:"if\u2011else",id:"ifelse",level:3},{value:"loop",id:"loop",level:3},{value:"while",id:"while",level:3},{value:"for",id:"for",level:3},{value:"Tipuri de date complexe",id:"tipuri-de-date-complexe",level:2},{value:"Vec",id:"vec",level:3},{value:"String",id:"string",level:3},{value:"Crearea unui String nou",id:"crearea-unui-string-nou",level:4},{value:"Ad\u0103ugarea la un String",id:"ad\u0103ugarea-la-un-string",level:4},{value:"Metode de itera\u021bie pe String\u2011uri",id:"metode-de-itera\u021bie-pe-stringuri",level:4},{value:"Rularea programului",id:"rularea-programului",level:2},{value:"Exerci\u021bii",id:"exerci\u021bii",level:2},{value:"Ownership (De\u021binerea memoriei)",id:"ownership-de\u021binerea-memoriei",level:2},{value:"Reguli de ownership",id:"reguli-de-ownership",level:3},{value:"Scope",id:"scope",level:3},{value:"Ownership \xeen func\u021bii",id:"ownership-\xeen-func\u021bii",level:3},{value:"Valori returnate \u0219i scope",id:"valori-returnate-\u0219i-scope",level:3},{value:"Referin\u021be \u0219i \xeemprumuturi (Borrowing)",id:"referin\u021be-\u0219i-\xeemprumuturi-borrowing",level:3},{value:"Referin\u021be mutabile",id:"referin\u021be-mutabile",level:3},{value:"Tr\u0103s\u0103tura <code>Copy</code>",id:"tr\u0103s\u0103tura-copy",level:2},{value:"Bonus pentru acas\u0103",id:"bonus-pentru-acas\u0103",level:2}],m={toc:p},g="wrapper";function s({components:e,...n}){return(0,r.yg)(g,(0,t.A)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"00--introducere-\xeen-rust"},"00 \u2013 Introducere \xeen Rust"),(0,r.yg)("p",null,"Vom folosi limbajul de programare ",(0,r.yg)("a",{parentName:"p",href:"https://www.rust-lang.org/"},"Rust")," pentru laboratoare."),(0,r.yg)("h2",{id:"resurse"},"Resurse"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"The Rust Programming Language, capitolele ",(0,r.yg)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch01-00-getting-started.html"},"1"),", ",(0,r.yg)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html"},"2"),", ",(0,r.yg)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html"},"3"),", ",(0,r.yg)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html"},"4")," \u0219i ",(0,r.yg)("a",{parentName:"li",href:"https://doc.rust-lang.org/book/ch05-00-structs.html"},"5")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("a",{parentName:"li",href:"https://tourofrust.com"},"Tour of Rust")," \u2013 tutorial pas cu pas"),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("em",{parentName:"li"},"Let's Get Rusty")," \u2013 ",(0,r.yg)("a",{parentName:"li",href:"https://www.youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8"},"The Rust Lang Book"),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=n3bPhdiJm9I"},"Structuri \xeen Rust")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=DSZqIJhkNCM"},"Enum \u0219i Pattern Matching")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=wM6o70NAWUI"},"Gestionarea erorilor \xeen Rust")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=Zs-pS-egQSs"},"Colec\u021bii comune \xeen Rust")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=VFIOSWy93H0"},"\xcen\u021belegerea Ownership \xeen Rust"))))),(0,r.yg)("admonition",{type:"tip"},(0,r.yg)("p",{parentName:"admonition"},"Acest laborator este destul de lung, dar \xeencearc\u0103 s\u0103 fie o introducere rapid\u0103 \xeen Rust. \xce\u021bi suger\u0103m s\u0103 mergi direct la ",(0,r.yg)("a",{parentName:"p",href:"#exercises"},"Exerci\u021bii"),", s\u0103 le rezolvi pe r\xe2nd \u0219i s\u0103 cite\u0219ti documenta\u021bia necesar\u0103 pe parcurs.")),(0,r.yg)("h2",{id:"biblioteca-standard"},"Biblioteca standard"),(0,r.yg)("p",null,"Biblioteca standard este \xeemp\u0103r\u021bit\u0103 \xeen trei niveluri:"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Nivel"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Descriere"),(0,r.yg)("th",{parentName:"tr",align:"left"},"Necesit\u0103"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://doc.rust-lang.org/core/index.html"},(0,r.yg)("inlineCode",{parentName:"a"},"core"))),(0,r.yg)("td",{parentName:"tr",align:"left"},"Ofer\u0103 elementele esen\u021biale de limbaj necesare compil\u0103rii, precum tr\u0103s\u0103turile ",(0,r.yg)("a",{parentName:"td",href:"https://doc.rust-lang.org/core/fmt/trait.Display.html"},(0,r.yg)("inlineCode",{parentName:"a"},"Display"))," \u0219i ",(0,r.yg)("a",{parentName:"td",href:"https://doc.rust-lang.org/core/fmt/trait.Debug.html"},(0,r.yg)("inlineCode",{parentName:"a"},"Debug")),". Datele pot fi doar elemente globale (stocate \xeen ",(0,r.yg)("em",{parentName:"td"},".data"),") sau pe ",(0,r.yg)("em",{parentName:"td"},"stack"),"."),(0,r.yg)("td",{parentName:"tr",align:"left"},"Hardware")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://doc.rust-lang.org/alloc/index.html"},(0,r.yg)("inlineCode",{parentName:"a"},"alloc"))),(0,r.yg)("td",{parentName:"tr",align:"left"},"Include tot ce ofer\u0103 ",(0,r.yg)("inlineCode",{parentName:"td"},"core"),", plus structuri de date alocate pe ",(0,r.yg)("em",{parentName:"td"},"heap"),", precum ",(0,r.yg)("a",{parentName:"td",href:"https://doc.rust-lang.org/alloc/boxed/struct.Box.html"},(0,r.yg)("inlineCode",{parentName:"a"},"Box"))," \u0219i ",(0,r.yg)("a",{parentName:"td",href:"https://doc.rust-lang.org/std/vec/struct.Vec.html"},(0,r.yg)("inlineCode",{parentName:"a"},"Vec")),". Dezvoltatorul trebuie s\u0103 furnizeze un alocator de memorie, cum ar fi ",(0,r.yg)("a",{parentName:"td",href:"https://docs.rs/embedded-alloc/latest/embedded_alloc/"},"embedded_alloc"),"."),(0,r.yg)("td",{parentName:"tr",align:"left"},"Alocator de memorie")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://doc.rust-lang.org/std/index.html"},(0,r.yg)("inlineCode",{parentName:"a"},"std"))),(0,r.yg)("td",{parentName:"tr",align:"left"},"Include tot din ",(0,r.yg)("inlineCode",{parentName:"td"},"alloc"),", plus multe func\u021bionalit\u0103\u021bi dependente de platform\u0103, inclusiv fire (threads) \u0219i I/O. Acesta este nivelul implicit pentru aplica\u021bii pe Windows, Linux, macOS \u0219i sisteme similare."),(0,r.yg)("td",{parentName:"tr",align:"left"},"Sistem de operare")))),(0,r.yg)("p",null,"Implicit, Rust are un set de elemente definite \xeen biblioteca standard care sunt importate \xeen programul fiec\u0103rei aplica\u021bii. Acest set se nume\u0219te ",(0,r.yg)("em",{parentName:"p"},"prelude")," \u0219i \xeel po\u021bi consulta \xeen ",(0,r.yg)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/prelude/index.html"},"documenta\u021bie"),"."),(0,r.yg)("p",null,"Dac\u0103 un tip pe care vrei s\u0103 \xeel folose\u0219ti nu se afl\u0103 \xeen ",(0,r.yg)("em",{parentName:"p"},"prelude"),", trebuie s\u0103 \xeel aduci explicit \xeen ",(0,r.yg)("em",{parentName:"p"},"scope")," cu o instruc\u021biune ",(0,r.yg)("inlineCode",{parentName:"p"},"use"),".\nFolosirea modulului ",(0,r.yg)("inlineCode",{parentName:"p"},"std::io")," \xee\u021bi ofer\u0103 mai multe func\u021bionalit\u0103\u021bi utile, inclusiv posibilitatea de a accepta input de la utilizator."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"use std::io; \n")),(0,r.yg)("h2",{id:"func\u021bia-main"},"Func\u021bia ",(0,r.yg)("inlineCode",{parentName:"h2"},"main")),(0,r.yg)("p",null,"Func\u021bia ",(0,r.yg)("inlineCode",{parentName:"p"},"main")," este punctul de intrare al programului."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    println!("Hello, world!");\n}\n')),(0,r.yg)("p",null,"Folosim macro\u2011ul ",(0,r.yg)("inlineCode",{parentName:"p"},"println!")," pentru a afi\u0219a mesaje pe ecran."),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"Pentru a afi\u0219a variabile mai complexe, po\u021bi folosi ",(0,r.yg)("inlineCode",{parentName:"p"},"{:?}"),", care asigur\u0103 c\u0103 orice tip care implementeaz\u0103 tr\u0103s\u0103tura ",(0,r.yg)("inlineCode",{parentName:"p"},"Debug")," poate fi afi\u0219at.")),(0,r.yg)("p",null,"Pentru a insera un placeholder \xeen macro\u2011ul ",(0,r.yg)("inlineCode",{parentName:"p"},"println!"),", folose\u0219te o ",(0,r.yg)("em",{parentName:"p"},"pereche de acolade")," ",(0,r.yg)("inlineCode",{parentName:"p"},"{}"),". Variabila sau expresia care \xeenlocuie\u0219te placeholderul este furnizat\u0103 \xeen afara \u0219irului."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n\n    let name = "Mary";\n    let age = 26;\n\n    println!("Hello, {}. You are {} years old", name, age);\n    // dac\u0103 \xeenlocuirile sunt doar variabile, se poate folosi versiunea inline\n    println!("Hello, {name}. You are {age} years old");\n}\n')),(0,r.yg)("h2",{id:"variabile-\u0219i-mutabilitate"},"Variabile \u0219i mutabilitate"),(0,r.yg)("p",null,"Folosim cuv\xe2ntul cheie ",(0,r.yg)("inlineCode",{parentName:"p"},"let")," pentru a crea o variabil\u0103."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let a = 5;\n")),(0,r.yg)("p",null,"Implicit, \xeen Rust variabilele sunt ",(0,r.yg)("strong",{parentName:"p"},"imutabile"),", adic\u0103 odat\u0103 ce o valoare este legat\u0103 de un nume, nu po\u021bi schimba acea valoare."),(0,r.yg)("p",null,"Exemplu:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let x = 5;\n    println!("The value of x is: {x}");\n    x = 6;\n    println!("The value of x is: {x}");\n}\n')),(0,r.yg)("p",null,"\xcen acest caz, vom ob\u021bine o eroare de compilare deoarece \xeencerc\u0103m s\u0103 modific\u0103m valoarea lui ",(0,r.yg)("inlineCode",{parentName:"p"},"x")," din ",(0,r.yg)("inlineCode",{parentName:"p"},"5")," \xeen ",(0,r.yg)("inlineCode",{parentName:"p"},"6"),", \xeens\u0103 ",(0,r.yg)("inlineCode",{parentName:"p"},"x")," este imutabil, deci nu putem face aceast\u0103 modificare."),(0,r.yg)("p",null,"De\u0219i variabilele sunt imutabile \xeen mod implicit, le po\u021bi face ",(0,r.yg)("strong",{parentName:"p"},"mutabile")," ad\u0103ug\xe2nd ",(0,r.yg)("inlineCode",{parentName:"p"},"mut")," \xeen fa\u021ba numelui variabilei. Ad\u0103ugarea lui ",(0,r.yg)("inlineCode",{parentName:"p"},"mut")," transmite \u0219i inten\u021bia c\u0103tre cititorii viitori ai codului, indic\xe2nd c\u0103 alte p\u0103r\u021bi ale codului vor modifica valoarea acestei variabile."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut x = 5;\n    println!("The value of x is: {x}");\n    x = 6;\n    println!("The value of x is: {x}");\n}\n')),(0,r.yg)("p",null,"Acum valoarea lui ",(0,r.yg)("inlineCode",{parentName:"p"},"x")," poate deveni ",(0,r.yg)("inlineCode",{parentName:"p"},"6"),"."),(0,r.yg)("h2",{id:"constante"},"Constante"),(0,r.yg)("p",null,"La fel ca variabilele imutabile, constantele sunt valori asociate unui nume \u0219i au o ",(0,r.yg)("strong",{parentName:"p"},"valoare cunoscut\u0103 la momentul compil\u0103rii"),"."),(0,r.yg)("p",null,"Nu este permis s\u0103 folose\u0219ti ",(0,r.yg)("inlineCode",{parentName:"p"},"mut")," cu constante. Constantele nu sunt doar imutabile implicit \u2014 ele sunt \xeentotdeauna imutabile. Se declar\u0103 folosind cuv\xe2ntul cheie ",(0,r.yg)("inlineCode",{parentName:"p"},"const")," \xeen loc de ",(0,r.yg)("inlineCode",{parentName:"p"},"let"),".",(0,r.yg)("br",{parentName:"p"}),"\n","Tipul de date al constantei trebuie specificat la momentul declara\u021biei."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n")),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"Pentru o \xeen\u021belegere mai bun\u0103, cite\u0219te ",(0,r.yg)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html"},"capitolul 3")," din documenta\u021bie.")),(0,r.yg)("h2",{id:"tipuri-de-date"},"Tipuri de date"),(0,r.yg)("h3",{id:"tipuri-scalare"},"Tipuri scalare"),(0,r.yg)("p",null,"Un tip scalar reprezint\u0103 o singur\u0103 valoare. Rust are patru tipuri scalare principale: \xeentregi, numere \xeen virgul\u0103 mobil\u0103, valori booleene \u0219i caractere."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"\xcentregi")," \u2192 Fiecare variant\u0103 poate fi cu semn sau f\u0103r\u0103 semn \u0219i are o dimensiune explicit\u0103."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let x: i8 = -2;\nlet y: u16 = 25;\n")),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"center"},"Lungime"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Cu semn"),(0,r.yg)("th",{parentName:"tr",align:"center"},"F\u0103r\u0103 semn"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Echivalent Java"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Echivalent C",(0,r.yg)("sup",{parentName:"th",id:"fnref-c_equivalent"},(0,r.yg)("a",{parentName:"sup",href:"#fn-c_equivalent",className:"footnote-ref"},"c_equivalent"))))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"8-bit"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"i8")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"u8")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"byte")," / ",(0,r.yg)("inlineCode",{parentName:"td"},"Byte"),(0,r.yg)("sup",{parentName:"td",id:"fnref-java_unsigned"},(0,r.yg)("a",{parentName:"sup",href:"#fn-java_unsigned",className:"footnote-ref"},"java_unsigned"))),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"char")," / ",(0,r.yg)("inlineCode",{parentName:"td"},"unsigned char"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"16-bit"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"i16")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"u16")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"short")," / ",(0,r.yg)("inlineCode",{parentName:"td"},"Short"),(0,r.yg)("sup",{parentName:"td",id:"fnref-java_unsigned"},(0,r.yg)("a",{parentName:"sup",href:"#fn-java_unsigned",className:"footnote-ref"},"java_unsigned"))),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"short")," / ",(0,r.yg)("inlineCode",{parentName:"td"},"unsigned short"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"32-bit"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"i32")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"u32")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"int")," / ",(0,r.yg)("inlineCode",{parentName:"td"},"Integer"),(0,r.yg)("sup",{parentName:"td",id:"fnref-java_unsigned"},(0,r.yg)("a",{parentName:"sup",href:"#fn-java_unsigned",className:"footnote-ref"},"java_unsigned"))),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"int")," / ",(0,r.yg)("inlineCode",{parentName:"td"},"unsigned int"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"64-bit"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"i64")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"u64")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"long")," / ",(0,r.yg)("inlineCode",{parentName:"td"},"Long"),(0,r.yg)("sup",{parentName:"td",id:"fnref-java_unsigned"},(0,r.yg)("a",{parentName:"sup",href:"#fn-java_unsigned",className:"footnote-ref"},"java_unsigned"))),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"long long")," / ",(0,r.yg)("inlineCode",{parentName:"td"},"unsigned long long"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"128-bit"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"i128")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"u128")),(0,r.yg)("td",{parentName:"tr",align:"center"},"N/A"),(0,r.yg)("td",{parentName:"tr",align:"center"},"N/A")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"arch"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"isize")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"usize")),(0,r.yg)("td",{parentName:"tr",align:"center"},"N/A"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"intptr_t")," / ",(0,r.yg)("inlineCode",{parentName:"td"},"uintptr_t"))))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Numere \xeen virgul\u0103 mobil\u0103")," \u2192 Tipurile numerelor \xeen virgul\u0103 mobil\u0103 \xeen Rust sunt ",(0,r.yg)("inlineCode",{parentName:"p"},"f32")," \u0219i ",(0,r.yg)("inlineCode",{parentName:"p"},"f64"),", care au dimensiuni de 32, respectiv 64 de bi\u021bi. Tipul implicit este ",(0,r.yg)("inlineCode",{parentName:"p"},"f64"),", deoarece pe procesoarele moderne este la fel de rapid ca ",(0,r.yg)("inlineCode",{parentName:"p"},"f32"),", dar ofer\u0103 o precizie mai mare. Toate tipurile cu virgul\u0103 mobil\u0103 sunt ",(0,r.yg)("strong",{parentName:"p"},"cu semn"),"."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:"center"},"Lungime"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Tip"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Echivalent Java"),(0,r.yg)("th",{parentName:"tr",align:"center"},"Echivalent C"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"32-bit"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"f32")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"float")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"float"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"64-bit"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"f64")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"double")),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"double"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:"center"},"128-bit"),(0,r.yg)("td",{parentName:"tr",align:"center"},(0,r.yg)("inlineCode",{parentName:"td"},"f128")),(0,r.yg)("td",{parentName:"tr",align:"center"},"N/A"),(0,r.yg)("td",{parentName:"tr",align:"center"},"N/A")))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    let x = 2.0; // f64\n    let y1: f32 = 3.0; // f32\n    let y2 = 3.0f32; // f32\n}\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Boolean")," \u2192 Tipul boolean ocup\u0103 un octet. Tipul se specific\u0103 prin ",(0,r.yg)("inlineCode",{parentName:"p"},"bool"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let t = true;\nlet f: bool = false; // cu adnotare de tip explicit\u0103\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Caractere")," \u2192 Tipul ",(0,r.yg)("inlineCode",{parentName:"p"},"char")," din Rust este cel mai elementar tip pentru reprezentarea caracterelor alfabetice."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let c = 'z';\nlet z: char = '\u2124'; // cu adnotare explicit\u0103\nlet heart_eyed_cat = '\ud83d\ude3b';\n")),(0,r.yg)("h3",{id:"structuri"},"Structuri"),(0,r.yg)("p",null,"Structurile sunt un tip de date care con\u021bin alte tipuri de date sub form\u0103 de c\xe2mpuri. Structurile din Rust sunt similare cu structurile din C \u0219i cu clasele din Java."),(0,r.yg)("p",null,"Pentru a defini o structur\u0103, folosim cuv\xe2ntul cheie ",(0,r.yg)("inlineCode",{parentName:"p"},"struct")," urmat de numele structurii. Apoi, \xeentre acolade, definim numele \u0219i tipurile c\xe2mpurilor"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"struct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n")),(0,r.yg)("p",null,"Pentru a folosi o structur\u0103 dup\u0103 ce a fost definit\u0103, cre\u0103m o ",(0,r.yg)("strong",{parentName:"p"},"instan\u021b\u0103")," a acesteia, specific\xe2nd valori concrete pentru fiecare c\xe2mp. Cre\u0103m o instan\u021b\u0103 ",(0,r.yg)("strong",{parentName:"p"},"alocat\u0103 pe stack")," specific\xe2nd numele structurii, urmat de acolade ce con\u021bin perechi ",(0,r.yg)("inlineCode",{parentName:"p"},"cheie: valoare"),", unde cheile sunt numele c\xe2mpurilor, iar valorile sunt datele care vor fi stocate."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let user1 = User {\n        active: true,\n        username: String::from("someusername123"),\n        email: String::from("someone@example.com"),\n        sign_in_count: 1,\n    };\n}\n')),(0,r.yg)("p",null,"Pentru a accesa un anumit membru al structurii, folosim aceast\u0103 sintax\u0103:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut user1 = User {\n        active: true,\n        username: String::from("someusername123"),\n        email: String::from("someone@example.com"),\n        sign_in_count: 1,\n    };\n \n    user1.email = String::from("anotheremail@example.com")\n}\n')),(0,r.yg)("admonition",{type:"warning"},(0,r.yg)("p",{parentName:"admonition"},"Re\u021bine c\u0103 \xeentreaga instan\u021b\u0103 trebuie s\u0103 fie ",(0,r.yg)("strong",{parentName:"p"},"mutabil\u0103"),"; Rust ",(0,r.yg)("strong",{parentName:"p"},"nu permite")," marcarea doar a unor c\xe2mpuri ca mutabile!")),(0,r.yg)("h4",{id:"implementarea-structurii"},"Implementarea structurii"),(0,r.yg)("p",null,"Structurile \xeen Rust sunt similare cu clasele din programarea orientat\u0103 pe obiecte (OOP). Pe l\xe2ng\u0103 opera\u021biile de baz\u0103, structurile pot avea implement\u0103ri \u0219i metode specifice. Metodele sunt definite \xeen blocul ",(0,r.yg)("inlineCode",{parentName:"p"},"impl")," al structurii."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"struct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nimpl User {\n    // metod\u0103 static\u0103 (f\u0103r\u0103 parametru self)\n    // se apeleaz\u0103 cu User::new()\n    fn new() -> User {\n        // ...\n    }\n    // metod\u0103 de instan\u021b\u0103\n    // se apeleaz\u0103 cu user.is_active()\n    fn is_active(&self) -> bool {\n        return self.active;\n    }\n}\n")),(0,r.yg)("h4",{id:"afi\u0219area-structurilor"},"Afi\u0219area structurilor"),(0,r.yg)("p",null,"Dac\u0103 \xeencerc\u0103m s\u0103 afi\u0219\u0103m o instan\u021b\u0103 a structurii ",(0,r.yg)("inlineCode",{parentName:"p"},"User")," folosind macro-ul ",(0,r.yg)("inlineCode",{parentName:"p"},"println!")," ca mai devreme, nu va func\u021biona."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let user1 = User {\n        active: true,\n        username: String::from("someusername123"),\n        email: String::from("someone@example.com"),\n        sign_in_count: 1,\n    };\n \n    println!("User is: {}", user1);\n}\n')),(0,r.yg)("p",null,"Vom primi urm\u0103torul mesaj de eroare:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"error[E0277]: `User` doesn't implement `std::fmt::Display`\n")),(0,r.yg)("p",null,"Pentru a putea afi\u0219a o structur\u0103, trebuie s\u0103 folosim ",(0,r.yg)("inlineCode",{parentName:"p"},"{:?}")," \xeen loc de ",(0,r.yg)("inlineCode",{parentName:"p"},"{}")," \u0219i s\u0103 implement\u0103m tr\u0103s\u0103tura ",(0,r.yg)("inlineCode",{parentName:"p"},"Debug")," pentru structur\u0103, folosind ",(0,r.yg)("inlineCode",{parentName:"p"},"#[derive(Debug)]"),"."),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"Tr\u0103s\u0103tura ",(0,r.yg)("inlineCode",{parentName:"p"},"Debug")," este folosit\u0103 pentru a afi\u0219a structuri, tablouri, enumuri sau orice alt tip care nu implementeaz\u0103 ",(0,r.yg)("inlineCode",{parentName:"p"},"Display"),".")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'#[derive(Debug)]\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let user1 = User {\n        active: true,\n        username: String::from("someusername123"),\n        email: String::from("someone@example.com"),\n        sign_in_count: 1,\n    };\n \n    println!("User is: {:?}", user1);\n}\n')),(0,r.yg)("p",null,"Rezultat:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},'User is: User { active: true, username: "someusername123", email: "someone@example.com", sign_in_count: 1 }\n')),(0,r.yg)("admonition",{type:"tip"},(0,r.yg)("p",{parentName:"admonition"},"Pentru o formatare mai lizibil\u0103 a ",(0,r.yg)("inlineCode",{parentName:"p"},"Debug"),", folose\u0219te ",(0,r.yg)("inlineCode",{parentName:"p"},"{:#?}"),".")),(0,r.yg)("h3",{id:"structuri-tuple"},"Structuri tuple"),(0,r.yg)("p",null,"Structurile tuple sunt similare cu structurile obi\u0219nuite, dar \xeen loc de a folosi nume pentru c\xe2mpuri, folosesc indici (numere)."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'struct Color(i32, i32, i32);\nstruct Device(String, u8);\n \nfn main() {\n    let black = Color(0, 0, 0);\n    let device = Device(String::from("Raspberry Pi Pico"), 2);\n\n    println!("Tipul dispozitivului este {} \u0219i versiunea este {}", device.0, device.1);\n}\n')),(0,r.yg)("p",null,"Tuplurile pot fi ",(0,r.yg)("em",{parentName:"p"},"cu nume")," (ca \xeen exemplul de mai sus) sau ",(0,r.yg)("em",{parentName:"p"},"anonime"),".",(0,r.yg)("br",{parentName:"p"}),"\n","Exemplul urm\u0103tor arat\u0103 cum func\u021biile pot folosi tupluri anonime pentru a returna mai multe valori."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn get_item_and_index(value: &str) -> (String, usize) {\n    // de obicei se caut\u0103 valoarea aici\n    (String::from("the name"), 0)\n}\n\nlet value = get_item_and_index("...");\n// folose\u0219te value.0 \u0219i value.1\n')),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"Pentru o \xeen\u021belegere mai bun\u0103, cite\u0219te ",(0,r.yg)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch05-00-structs.html"},"capitolul 5")," din documenta\u021bie.")),(0,r.yg)("h3",{id:"enumuri"},"Enumuri"),(0,r.yg)("p",null,"Enumurile (enumerations) permit definirea unui tip prin enumerarea variantelor posibile.",(0,r.yg)("br",{parentName:"p"}),"\n","Cum definim un ",(0,r.yg)("inlineCode",{parentName:"p"},"enum"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"enum IpAddrKind {\n    V4,\n    V6,\n}\n")),(0,r.yg)("h4",{id:"enumul-option"},"Enumul ",(0,r.yg)("inlineCode",{parentName:"h4"},"Option")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"Option")," este un alt ",(0,r.yg)("inlineCode",{parentName:"p"},"enum")," definit \xeen biblioteca standard. Tipul ",(0,r.yg)("inlineCode",{parentName:"p"},"Option")," reprezint\u0103 scenariul comun \xeen care o valoare poate fi prezent\u0103 sau absent\u0103."),(0,r.yg)("p",null,"Rust ",(0,r.yg)("strong",{parentName:"p"},"nu are conceptul de null"),", a\u0219a cum au alte limbaje. Null reprezint\u0103 o valoare care \xeenseamn\u0103 \u201enu exist\u0103 valoare aici\u201d. \xcen limbajele care permit ",(0,r.yg)("inlineCode",{parentName:"p"},"null"),", variabilele pot fi fie ",(0,r.yg)("inlineCode",{parentName:"p"},"null"),", fie non\u2011null."),(0,r.yg)("p",null,"Rust nu are valori ",(0,r.yg)("inlineCode",{parentName:"p"},"null"),", dar ofer\u0103 o enumerare care poate reprezenta prezen\u021ba sau absen\u021ba unei valori. Aceasta este ",(0,r.yg)("inlineCode",{parentName:"p"},"Option<T>"),", definit\u0103 \xeen biblioteca standard astfel:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"enum Option<T> {\n    None,\n    Some(T),\n}\n")),(0,r.yg)("p",null,"Aici ",(0,r.yg)("inlineCode",{parentName:"p"},"<T>")," indic\u0103 faptul c\u0103 varianta ",(0,r.yg)("inlineCode",{parentName:"p"},"Some")," a enumului poate con\u021bine date de ",(0,r.yg)("strong",{parentName:"p"},"orice tip"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"fn integer_division(a: isize, b: isize) -> Option<isize> {\n    if b == 0 {\n        None\n    } else {\n        Some(a / b)\n    }\n}\n")),(0,r.yg)("p",null,"C\xe2nd avem o valoare ",(0,r.yg)("inlineCode",{parentName:"p"},"Some"),", \u0219tim c\u0103 exist\u0103 o valoare valid\u0103 \xeen interior. C\xe2nd avem ",(0,r.yg)("inlineCode",{parentName:"p"},"None"),", \xeenseamn\u0103 c\u0103 nu avem o valoare valid\u0103 \u2014 similar cu ",(0,r.yg)("inlineCode",{parentName:"p"},"null")," \xeen alte limbaje."),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"Trebuie s\u0103 converte\u0219ti un ",(0,r.yg)("inlineCode",{parentName:"p"},"Option<T>")," \xeentr-un ",(0,r.yg)("inlineCode",{parentName:"p"},"T")," \xeenainte de a putea efectua opera\u021bii specifice pe el.")),(0,r.yg)("h4",{id:"match"},(0,r.yg)("inlineCode",{parentName:"h4"},"match")),(0,r.yg)("p",null,"Rust ofer\u0103 o construc\u021bie de control foarte puternic\u0103 numit\u0103 ",(0,r.yg)("inlineCode",{parentName:"p"},"match"),", care permite compararea unei valori cu o serie de modele \u0219i executarea codului corespunz\u0103tor modelului potrivit.",(0,r.yg)("br",{parentName:"p"}),"\n","Modelele pot fi valori literale, nume de variabile, wildcard\u2011uri etc."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"enum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n \nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n")),(0,r.yg)("p",null,"C\xe2nd expresia ",(0,r.yg)("inlineCode",{parentName:"p"},"match")," ruleaz\u0103, valoarea este comparat\u0103 cu fiecare bra\u021b \xeen ordine. Dac\u0103 un model se potrive\u0219te, codul asociat acelui model este executat. Dac\u0103 nu, se continu\u0103 la urm\u0103torul bra\u021b."),(0,r.yg)("p",null,"Codul din fiecare bra\u021b este o ",(0,r.yg)("strong",{parentName:"p"},"expresie"),", iar valoarea rezultat\u0103 devine ",(0,r.yg)("strong",{parentName:"p"},"valoarea returnat\u0103")," a \xeentregii expresii ",(0,r.yg)("inlineCode",{parentName:"p"},"match"),"."),(0,r.yg)("p",null,"\xcen sec\u021biunea anterioar\u0103 am dorit s\u0103 extragem valoarea intern\u0103 ",(0,r.yg)("inlineCode",{parentName:"p"},"T")," din varianta ",(0,r.yg)("inlineCode",{parentName:"p"},"Some")," a lui ",(0,r.yg)("inlineCode",{parentName:"p"},"Option<T>"),". Putem face asta \u0219i folosind ",(0,r.yg)("inlineCode",{parentName:"p"},"match"),", exact ca \xeen exemplul cu ",(0,r.yg)("inlineCode",{parentName:"p"},"Coin"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let x = 120;\n    let y = 7;\n    match integer_division(x, y) {\n        Some(d) => println!("{}:{} = {}", x, y, d),\n        None => println!("division by 0")\n    };\n}\n')),(0,r.yg)("h4",{id:"enumul-result"},"Enumul ",(0,r.yg)("inlineCode",{parentName:"h4"},"Result")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"Result")," este un ",(0,r.yg)("inlineCode",{parentName:"p"},"enum")," folosit pentru a reprezenta rezultatul unei opera\u021bii care poate e\u0219ua."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Varianta ",(0,r.yg)("inlineCode",{parentName:"li"},"Ok")," indic\u0103 faptul c\u0103 opera\u021bia a fost reu\u0219it\u0103, iar valoarea se afl\u0103 \xeen ",(0,r.yg)("inlineCode",{parentName:"li"},"Ok"),"."),(0,r.yg)("li",{parentName:"ul"},"Varianta ",(0,r.yg)("inlineCode",{parentName:"li"},"Err")," indic\u0103 faptul c\u0103 a ap\u0103rut o eroare, iar \xeen interior se afl\u0103 informa\u021bii despre acea eroare.")),(0,r.yg)("p",null,"Defini\u021bia din biblioteca standard este:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"enum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n")),(0,r.yg)("p",null,"unde ",(0,r.yg)("inlineCode",{parentName:"p"},"T")," \u0219i ",(0,r.yg)("inlineCode",{parentName:"p"},"E")," sunt tipuri generice \u2014 ",(0,r.yg)("inlineCode",{parentName:"p"},"T")," pentru valoarea de succes, ",(0,r.yg)("inlineCode",{parentName:"p"},"E")," pentru eroare."),(0,r.yg)("p",null,"Exemplu:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'use std::fs::File;\n \nfn main() {\n    let greeting_file_result = File::open("hello.txt");\n \n    let greeting_file = match greeting_file_result {\n        Ok(file) => {\n            // utiliz\u0103m variabila file aici\n        }\n        Err(error) => panic!("Problem opening the file: {:?}", error),\n    };\n}\n')),(0,r.yg)("h5",{id:"operatorul-"},"Operatorul ",(0,r.yg)("inlineCode",{parentName:"h5"},"?")),(0,r.yg)("p",null,"Po\u021bi plasa ",(0,r.yg)("inlineCode",{parentName:"p"},"?")," dup\u0103 o expresie care returneaz\u0103 un ",(0,r.yg)("inlineCode",{parentName:"p"},"Result"),". Dac\u0103 rezultatul este ",(0,r.yg)("inlineCode",{parentName:"p"},"Err"),", eroarea este propagat\u0103 imediat c\u0103tre apelant; altfel, se continu\u0103 cu valoarea din ",(0,r.yg)("inlineCode",{parentName:"p"},"Ok"),"."),(0,r.yg)("p",null,"Exemplu:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'use std::fs::File;\nuse std::io::{self, Read};\n \nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut username = String::new();\n \n    File::open("hello.txt")?.read_to_string(&mut username)?;\n \n    Ok(username)\n}\n')),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"Pentru o \xeen\u021belegere mai bun\u0103, cite\u0219te ",(0,r.yg)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch06-00-enums.html"},"capitolul 6")," din documenta\u021bie.")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Tuple")," \u2192 Un tuple este o structur\u0103 folosit\u0103 pentru a grupa mai multe valori de tipuri diferite \xeentr-un singur tip compus. Tuplurile au o lungime ",(0,r.yg)("strong",{parentName:"p"},"fix\u0103"),": odat\u0103 declarate, dimensiunea lor nu se poate modifica."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let tup: (i32, f64, u8) = (500, 6.4, 1);\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Array")," \u2192 Spre deosebire de tuple, toate elementele unui array trebuie s\u0103 aib\u0103 ",(0,r.yg)("strong",{parentName:"p"},"acela\u0219i tip"),". \xcen plus, array\u2011urile \xeen Rust au o lungime ",(0,r.yg)("strong",{parentName:"p"},"fix\u0103"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let a = [1, 2, 3, 4, 5];\n")),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"Pentru o \xeen\u021belegere mai bun\u0103, cite\u0219te ",(0,r.yg)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html"},"capitolul 3")," din documenta\u021bie.")),(0,r.yg)("h2",{id:"func\u021bii"},"Func\u021bii"),(0,r.yg)("p",null,"Definim o func\u021bie \xeen Rust folosind cuv\xe2ntul cheie ",(0,r.yg)("inlineCode",{parentName:"p"},"fn"),", urmat de numele func\u021biei \u0219i paranteze. Acoladele definesc \xeenceputul \u0219i sf\xe2r\u0219itul corpului func\u021biei."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    println!("Hello, world!");\n \n    another_function();\n}\n \nfn another_function() {\n    println!("Another function.");\n}\n')),(0,r.yg)("h4",{id:"parametri"},"Parametri"),(0,r.yg)("p",null,"Putem defini func\u021bii cu parametri \u2014 variabile speciale care fac parte din semn\u0103tura func\u021biei. C\xe2nd o func\u021bie are parametri, \xeei putem furniza ",(0,r.yg)("em",{parentName:"p"},"valori concrete"),", numite ",(0,r.yg)("em",{parentName:"p"},"argumente"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    // apelul func\u021biei `another_function` are un singur argument, valoarea 5\n    another_function(5);\n}\n \n// func\u021bia `another_function` are un singur parametru `x` de tip `i32`\nfn another_function(x: i32) {\n    println!("The value of x is: {x}");\n}\n')),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"\xcen semn\u0103tura func\u021biilor trebuie declarat tipul fiec\u0103rui parametru!")),(0,r.yg)("h4",{id:"func\u021bii-cu-valori-de-retur"},"Func\u021bii cu valori de retur"),(0,r.yg)("p",null,"Func\u021biile pot returna valori c\u0103tre codul care le apeleaz\u0103. Nu este nevoie s\u0103 denumim valoarea returnat\u0103, dar trebuie s\u0103 \xeei declar\u0103m tipul dup\u0103 o ",(0,r.yg)("em",{parentName:"p"},"s\u0103geat\u0103")," (",(0,r.yg)("inlineCode",{parentName:"p"},"->"),").",(0,r.yg)("br",{parentName:"p"}),"\n","\xcen Rust, valoarea returnat\u0103 a func\u021biei este echivalent\u0103 cu valoarea ",(0,r.yg)("strong",{parentName:"p"},"ultimei expresii")," din corpul func\u021biei. Putem returna anticipat dintr-o func\u021bie folosind cuv\xe2ntul cheie ",(0,r.yg)("inlineCode",{parentName:"p"},"return"),", dar de obicei ultima expresie este suficient\u0103."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn five() -> i32 {\n    5\n}\n \nfn main() {\n    let x = five();\n    println!("The value of x is: {x}"); // "The value of x is: 5"\n}\n')),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"Pentru o \xeen\u021belegere mai bun\u0103, cite\u0219te ",(0,r.yg)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html"},"capitolul 3")," din documenta\u021bie.")),(0,r.yg)("h2",{id:"flux-de-control"},"Flux de control"),(0,r.yg)("h3",{id:"ifelse"},"if\u2011else"),(0,r.yg)("p",null,"Toate expresiile ",(0,r.yg)("inlineCode",{parentName:"p"},"if")," \xeencep cu cuv\xe2ntul cheie ",(0,r.yg)("inlineCode",{parentName:"p"},"if"),", urmat de o condi\u021bie. Op\u021bional, putem include \u0219i o ramur\u0103 ",(0,r.yg)("inlineCode",{parentName:"p"},"else"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let number = 3;\n \n    if number < 5 {\n        println!("condition was true");\n    } else {\n        println!("condition was false");\n    }\n}\n')),(0,r.yg)("p",null,"Putem combina mai multe condi\u021bii folosind ",(0,r.yg)("inlineCode",{parentName:"p"},"else if"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let number = 6;\n \n    if number % 4 == 0 {\n        println!("number is divisible by 4");\n    } else if number % 3 == 0 {\n        println!("number is divisible by 3");\n    } else if number % 2 == 0 {\n        println!("number is divisible by 2");\n    } else {\n        println!("number is not divisible by 4, 3, or 2");\n    }\n}\n')),(0,r.yg)("p",null,"Pentru c\u0103 ",(0,r.yg)("inlineCode",{parentName:"p"},"if")," este o expresie, o putem folosi ",(0,r.yg)("strong",{parentName:"p"},"\xeen partea dreapt\u0103")," a unei declara\u021bii ",(0,r.yg)("inlineCode",{parentName:"p"},"let")," pentru a atribui rezultatul unei variabile."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n \n    println!("The value of number is: {number}"); // "The value of number is: 5"\n}\n')),(0,r.yg)("h3",{id:"loop"},"loop"),(0,r.yg)("p",null,"Cuv\xe2ntul cheie ",(0,r.yg)("inlineCode",{parentName:"p"},"loop")," spune lui Rust s\u0103 ruleze un bloc de cod \xeen mod repetat, la infinit, p\xe2n\u0103 c\xe2nd \xeei spunem ",(0,r.yg)("strong",{parentName:"p"},"explicit")," s\u0103 se opreasc\u0103."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    loop {\n        println!("again!");\n    }\n}\n')),(0,r.yg)("p",null,"Un caz de utilizare al ",(0,r.yg)("inlineCode",{parentName:"p"},"loop")," este re\xeencercarea unei opera\u021bii care poate e\u0219ua, cum ar fi verificarea dac\u0103 un fir de execu\u021bie \u0219i\u2011a terminat munca.",(0,r.yg)("br",{parentName:"p"}),"\n","Putem de asemenea returna o valoare dintr\u2011un ",(0,r.yg)("inlineCode",{parentName:"p"},"loop")," folosind ",(0,r.yg)("inlineCode",{parentName:"p"},"break")," urmat de expresia dorit\u0103."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut counter = 0;\n \n    let result = loop {\n        counter += 1;\n \n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n \n    println!("The result is {result}");\n}\n')),(0,r.yg)("h3",{id:"while"},"while"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut number = 3;\n \n    while number != 0 {\n        println!("{number}!");\n \n        number -= 1;\n    }\n \n    println!("LIFTOFF!!!");\n}\n')),(0,r.yg)("h3",{id:"for"},"for"),(0,r.yg)("p",null,"\xcen Rust, structura ",(0,r.yg)("strong",{parentName:"p"},"for")," este folosit\u0103 pentru a itera peste o list\u0103 de elemente (de exemplu, un ",(0,r.yg)("inlineCode",{parentName:"p"},"vec"),").",(0,r.yg)("br",{parentName:"p"}),"\n","La fiecare itera\u021bie, se returneaz\u0103 o referin\u021b\u0103 c\u0103tre un element din list\u0103."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let a = [10, 20, 30, 40, 50];\n    \n    for element in a {\n        println!("the value is: {element}");\n    }\n}\n')),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"Pentru o \xeen\u021belegere mai bun\u0103, cite\u0219te ",(0,r.yg)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html"},"capitolul 3")," din documenta\u021bie.")),(0,r.yg)("h2",{id:"tipuri-de-date-complexe"},"Tipuri de date complexe"),(0,r.yg)("h3",{id:"vec"},"Vec"),(0,r.yg)("p",null,"Tipul de date pe care Rust \xeel ofer\u0103 pentru stocarea unei liste de date este ",(0,r.yg)("inlineCode",{parentName:"p"},"Vec"),". Este similar cu ",(0,r.yg)("inlineCode",{parentName:"p"},"vector")," din C++ sau ",(0,r.yg)("inlineCode",{parentName:"p"},"ArrayList")," din Java."),(0,r.yg)("p",null,"Tipul unui vector este ",(0,r.yg)("inlineCode",{parentName:"p"},"Vec<T>"),", unde ",(0,r.yg)("inlineCode",{parentName:"p"},"T")," poate fi orice tip de date."),(0,r.yg)("p",null,"Pentru a crea un vector nou, Rust ofer\u0103 macro\u2011ul ",(0,r.yg)("inlineCode",{parentName:"p"},"vec!"),". O form\u0103 mai lung\u0103 este ",(0,r.yg)("inlineCode",{parentName:"p"},"Vec::new()"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let v = vec![];\n// sau\nlet v = Vec::new();\n")),(0,r.yg)("p",null,"Tipul efectiv al lui ",(0,r.yg)("inlineCode",{parentName:"p"},"T")," este de obicei dedus de compilator."),(0,r.yg)("admonition",{type:"warning"},(0,r.yg)("p",{parentName:"admonition"},"Uneori compilatorul nu poate deduce tipul, \u0219i atunci trebuie s\u0103 \xeel specific\u0103m explicit."),(0,r.yg)("pre",{parentName:"admonition"},(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let v: Vec<String> = vec![];\n// sau\nlet v = Vec::<String>::new();\n"))),(0,r.yg)("p",null,"Tipul ",(0,r.yg)("inlineCode",{parentName:"p"},"Vec")," ofer\u0103 mai multe func\u021bii pentru a insera, accesa \u0219i elimina elemente."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Metod\u0103"),(0,r.yg)("th",{parentName:"tr",align:null},"Descriere"),(0,r.yg)("th",{parentName:"tr",align:null},"Tip de date returnat"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"len()")),(0,r.yg)("td",{parentName:"tr",align:null},"Num\u0103rul de elemente din vector"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"usize"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"push(t: T)")),(0,r.yg)("td",{parentName:"tr",align:null},"Adaug\u0103 un element de tip ",(0,r.yg)("inlineCode",{parentName:"td"},"T")," la finalul vectorului"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"()"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"get(index: usize)")),(0,r.yg)("td",{parentName:"tr",align:null},"Ob\u021bine o referin\u021b\u0103 c\u0103tre un element al vectorului"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Option<&T>"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"get_mut(index: usize)")),(0,r.yg)("td",{parentName:"tr",align:null},"Ob\u021bine o referin\u021b\u0103 mutabil\u0103 c\u0103tre un element al vectorului"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Option<&mut T>"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"remove(index: usize)")),(0,r.yg)("td",{parentName:"tr",align:null},"Elimin\u0103 elementul de la un anumit index"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"T"))))),(0,r.yg)("admonition",{type:"warning"},(0,r.yg)("p",{parentName:"admonition"},"Func\u021bia ",(0,r.yg)("inlineCode",{parentName:"p"},"remove")," va genera panic dac\u0103 ",(0,r.yg)("inlineCode",{parentName:"p"},"index")," este \xeen afara limitelor.")),(0,r.yg)("p",null,"Cel mai bun mod de a itera prin toate elementele unui ",(0,r.yg)("inlineCode",{parentName:"p"},"Vec")," este folosind un ",(0,r.yg)("inlineCode",{parentName:"p"},"for"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"for element in v {\n    // folose\u0219te element de tip &T\n}\n")),(0,r.yg)("h3",{id:"string"},"String"),(0,r.yg)("p",null,"Rust are doar un singur tip de \u0219ir \xeen nucleul limbajului: ",(0,r.yg)("em",{parentName:"p"},"slice\u2011ul de \u0219iruri")," ",(0,r.yg)("inlineCode",{parentName:"p"},"str"),", de obicei folosit sub forma \xeemprumutat\u0103 ",(0,r.yg)("inlineCode",{parentName:"p"},"&str"),"."),(0,r.yg)("p",null,"Tipul ",(0,r.yg)("inlineCode",{parentName:"p"},"String"),", care este oferit de biblioteca standard Rust, este un \u0219ir UTF\u20118 redimensionabil, mutabil \u0219i de\u021binut (owned)."),(0,r.yg)("h4",{id:"crearea-unui-string-nou"},"Crearea unui String nou"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let mut s = String::new();\n")),(0,r.yg)("p",null,"Aceast\u0103 linie creeaz\u0103 un nou \u0219ir gol numit ",(0,r.yg)("inlineCode",{parentName:"p"},"s"),", \xeen care putem \xeenc\u0103rca ulterior date."),(0,r.yg)("p",null,"Putem folosi func\u021bia ",(0,r.yg)("inlineCode",{parentName:"p"},"String::from")," sau metoda ",(0,r.yg)("inlineCode",{parentName:"p"},"to_string")," pentru a crea un \u0219ir dintr\u2011un literal:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'let s = String::from("initial contents");\n')),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'let data = "initial contents";\n \nlet s = data.to_string();\n\n// metoda func\u021bioneaz\u0103 \u0219i direct pe literal:\nlet s = "initial contents".to_string();\n')),(0,r.yg)("h4",{id:"ad\u0103ugarea-la-un-string"},"Ad\u0103ugarea la un String"),(0,r.yg)("p",null,"Putem extinde un \u0219ir folosind metoda ",(0,r.yg)("inlineCode",{parentName:"p"},"push_str"),", care adaug\u0103 un ",(0,r.yg)("em",{parentName:"p"},"slice")," de \u0219iruri."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'let mut s = String::from("foo");\ns.push_str("bar");\n')),(0,r.yg)("p",null,"Metoda ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("inlineCode",{parentName:"strong"},"push"))," prime\u0219te ",(0,r.yg)("strong",{parentName:"p"},"un singur caracter")," \u0219i \xeel adaug\u0103 la finalul \u0219irului."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let mut s = String::from(\"lo\");\ns.push('l');\n")),(0,r.yg)("h4",{id:"metode-de-itera\u021bie-pe-stringuri"},"Metode de itera\u021bie pe String\u2011uri"),(0,r.yg)("p",null,"Cea mai bun\u0103 modalitate de a opera pe fragmente de \u0219iruri este s\u0103 specific\u0103m clar dac\u0103 dorim caractere sau octe\u021bi.",(0,r.yg)("br",{parentName:"p"}),"\n","Pentru valori Unicode individuale, folosim metoda ",(0,r.yg)("inlineCode",{parentName:"p"},"chars"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'for c in "\u0417\u0434".chars() {\n    println!("{}", c);\n}\n')),(0,r.yg)("h2",{id:"rularea-programului"},"Rularea programului"),(0,r.yg)("p",null,"Pentru a rula programul, ne putem afla oriunde \xeen directorul proiectului (crate) \u0219i putem executa comanda:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"cargo run\n")),(0,r.yg)("h2",{id:"exerci\u021bii"},"Exerci\u021bii"),(0,r.yg)("admonition",{type:"tip"},(0,r.yg)("p",{parentName:"admonition"},"Dac\u0103 nu ai instalat Rust, po\u021bi folosi ",(0,r.yg)("a",{parentName:"p",href:"https://play.rust-lang.org/"},"Rust Playground")," pentru a rezolva exerci\u021biile. ")),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"\xcenainte de a \xeencepe exerci\u021biile, parcurge capitolele ",(0,r.yg)("a",{parentName:"p",href:"https://tourofrust.com/chapter_1_en.html"},"1"),", ",(0,r.yg)("a",{parentName:"p",href:"https://tourofrust.com/chapter_2_en.html"},"2")," \u0219i ",(0,r.yg)("a",{parentName:"p",href:"https://tourofrust.com/chapter_3_en.html"},"3")," din tutorialele ",(0,r.yg)("a",{parentName:"p",href:"https://tourofrust.com/"},"Tour of Rust"),".")),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Scrie o func\u021bie care prime\u0219te numele t\u0103u ca parametru \u0219i te salut\u0103 \xeen ",(0,r.yg)("inlineCode",{parentName:"li"},"stdout")," (afi\u0219eaz\u0103 pe ecran). Ce tip ar trebui s\u0103 aib\u0103 parametrul \u0219i de ce? (",(0,r.yg)("strong",{parentName:"li"},"1p"),")"),(0,r.yg)("li",{parentName:"ol"},"Scrie o func\u021bie care prime\u0219te un num\u0103r \xeentreg f\u0103r\u0103 semn ",(0,r.yg)("inlineCode",{parentName:"li"},"N")," \u0219i afi\u0219eaz\u0103 primele ",(0,r.yg)("inlineCode",{parentName:"li"},"N")," numere impare (",(0,r.yg)("strong",{parentName:"li"},"1p"),")."),(0,r.yg)("li",{parentName:"ol"},"Scrie o func\u021bie care returneaz\u0103 primul num\u0103r par dintr-un ",(0,r.yg)("em",{parentName:"li"},"slice")," de array. Asigur\u0103-te c\u0103 tratezi cazul \xeen care nu exist\u0103 niciun num\u0103r par. (",(0,r.yg)("strong",{parentName:"li"},"1p"),")",(0,r.yg)("br",{parentName:"li"}),(0,r.yg)("em",{parentName:"li"},"Indica\u021bie:")," un slice este o parte a unui array, ",(0,r.yg)("inlineCode",{parentName:"li"},"&a[first..end]"),". Arunc\u0103 o privire la ",(0,r.yg)("a",{parentName:"li",href:"#for"},(0,r.yg)("inlineCode",{parentName:"a"},"for"))," \u0219i ",(0,r.yg)("a",{parentName:"li",href:"#option-enum"},(0,r.yg)("inlineCode",{parentName:"a"},"Option")),". \u021aine minte c\u0103 ",(0,r.yg)("inlineCode",{parentName:"li"},"for")," ofer\u0103 o referin\u021b\u0103 c\u0103tre fiecare element din list\u0103."),(0,r.yg)("li",{parentName:"ol"},"Scrie o func\u021bie care caut\u0103 \xeentr-un vector de string\u2011uri \u0219i returneaz\u0103 primul element care are mai mult de 4 caractere (",(0,r.yg)("strong",{parentName:"li"},"1p"),").",(0,r.yg)("br",{parentName:"li"}),(0,r.yg)("em",{parentName:"li"},"Indica\u021bie:")," vezi ",(0,r.yg)("a",{parentName:"li",href:"#for"},(0,r.yg)("inlineCode",{parentName:"a"},"for")),", ",(0,r.yg)("a",{parentName:"li",href:"#option-enum"},(0,r.yg)("inlineCode",{parentName:"a"},"Option"))," \u0219i func\u021biile ",(0,r.yg)("a",{parentName:"li",href:"#string"},(0,r.yg)("inlineCode",{parentName:"a"},"from()"),", ",(0,r.yg)("inlineCode",{parentName:"a"},"len()")," \u0219i ",(0,r.yg)("inlineCode",{parentName:"a"},"to_string()")),"."),(0,r.yg)("li",{parentName:"ol"},"Define\u0219te un vector de tranzac\u021bii care pot fi \xeen Ron, Dolari, Euro, Lire sau Bitcoin. Creeaz\u0103 o func\u021bie care calculeaz\u0103 valoarea total\u0103 \xeen Ron a vectorului.",(0,r.yg)("br",{parentName:"li"}),"(presupune: Ron = 1, Dolar = 4.5, Euro = 5, Lir\u0103 = 6, Bitcoin = 100000) (",(0,r.yg)("strong",{parentName:"li"},"2p"),")",(0,r.yg)("br",{parentName:"li"}),(0,r.yg)("em",{parentName:"li"},"Indica\u021bie:")," vezi ",(0,r.yg)("a",{parentName:"li",href:"#enums"},(0,r.yg)("inlineCode",{parentName:"a"},"enum"))," \u0219i ",(0,r.yg)("a",{parentName:"li",href:"#structures"},(0,r.yg)("inlineCode",{parentName:"a"},"structuri")),"."),(0,r.yg)("li",{parentName:"ol"},"Scrie o func\u021bie care transform\u0103 un ",(0,r.yg)("em",{parentName:"li"},"string slice")," ",(0,r.yg)("inlineCode",{parentName:"li"},"&str")," \xeentr-un num\u0103r \xeentreg f\u0103r\u0103 semn, return\xe2nd fie valoarea, fie un cod de eroare. Creeaz\u0103 un tip de eroare care gestioneaz\u0103 cazurile: ",(0,r.yg)("em",{parentName:"li"},"\u0219irul este gol"),", ",(0,r.yg)("em",{parentName:"li"},"\u0219irul con\u021bine un caracter invalid")," (\u0219i la ce pozi\u021bie) \u0219i ",(0,r.yg)("em",{parentName:"li"},"num\u0103rul este negativ"),". (",(0,r.yg)("strong",{parentName:"li"},"2p"),")",(0,r.yg)("br",{parentName:"li"}),(0,r.yg)("em",{parentName:"li"},"Indica\u021bie:")," vezi ",(0,r.yg)("a",{parentName:"li",href:"#option-enum"},(0,r.yg)("inlineCode",{parentName:"a"},"Option"))," \u0219i ",(0,r.yg)("a",{parentName:"li",href:"#result-enum"},(0,r.yg)("inlineCode",{parentName:"a"},"Result")),"."),(0,r.yg)("li",{parentName:"ol"},"Define\u0219te o structur\u0103 ",(0,r.yg)("inlineCode",{parentName:"li"},"Complex")," cu numere reale de tip ",(0,r.yg)("inlineCode",{parentName:"li"},"float"),". (",(0,r.yg)("strong",{parentName:"li"},"2p"),")",(0,r.yg)("br",{parentName:"li"}),"a. Implementeaz\u0103 o func\u021bie static\u0103 ",(0,r.yg)("inlineCode",{parentName:"li"},"new")," pentru aceast\u0103 structur\u0103.",(0,r.yg)("br",{parentName:"li"}),"b. Implementeaz\u0103 2 opera\u021bii posibile pentru ea (inclusiv valoarea absolut\u0103 \u0219i \xeenmul\u021birea).",(0,r.yg)("br",{parentName:"li"}),"c. Implementeaz\u0103 o metod\u0103 ",(0,r.yg)("inlineCode",{parentName:"li"},"display")," care afi\u0219eaz\u0103 num\u0103rul.")),(0,r.yg)("h2",{id:"ownership-de\u021binerea-memoriei"},"Ownership (De\u021binerea memoriei)"),(0,r.yg)("p",null,"Ownership este un set de reguli care guverneaz\u0103 modul \xeen care un program Rust gestioneaz\u0103 memoria. Toate programele trebuie s\u0103 gestioneze memoria calculatorului \xeen timpul execu\u021biei."),(0,r.yg)("p",null,"Unele limbaje au ",(0,r.yg)("strong",{parentName:"p"},"garbage collection"),", care caut\u0103 periodic memoria nefolosit\u0103. \xcen alte limbaje, programatorul trebuie s\u0103 aloce \u0219i s\u0103 elibereze memoria manual."),(0,r.yg)("p",null,"Rust folose\u0219te o a treia abordare: memoria este gestionat\u0103 printr-un ",(0,r.yg)("strong",{parentName:"p"},"sistem de proprietate (ownership)"),", bazat pe un set de ",(0,r.yg)("strong",{parentName:"p"},"reguli")," verificate de compilator. Dac\u0103 una dintre reguli este \xeenc\u0103lcat\u0103, programul nu se va compila. Aceste reguli nu \xeencetinesc execu\u021bia programului."),(0,r.yg)("h3",{id:"reguli-de-ownership"},"Reguli de ownership"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Fiecare valoare \xeen Rust are un ",(0,r.yg)("strong",{parentName:"li"},"proprietar"),"."),(0,r.yg)("li",{parentName:"ol"},"O valoare nu poate avea mai mult de un ",(0,r.yg)("strong",{parentName:"li"},"proprietar")," simultan."),(0,r.yg)("li",{parentName:"ol"},"C\xe2nd proprietarul iese din ",(0,r.yg)("em",{parentName:"li"},"scope"),", valoarea este eliberat\u0103 (dropped).")),(0,r.yg)("h3",{id:"scope"},"Scope"),(0,r.yg)("p",null,"Un ",(0,r.yg)("strong",{parentName:"p"},"scope")," este zona de cod \xeen care un element este valid."),(0,r.yg)("p",null,"Exemplu pentru \xeen\u021belegere:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'{\n    // aici s este invalid\n    let s = "hello";   // s devine valid de aici\n} // dup\u0103 acest punct, valoarea s este eliberat\u0103\n')),(0,r.yg)("h3",{id:"ownership-\xeen-func\u021bii"},"Ownership \xeen func\u021bii"),(0,r.yg)("p",null,"Mecanismul prin care se transmit valori c\u0103tre o func\u021bie este similar cu atribuirea unei valori unei variabile.",(0,r.yg)("br",{parentName:"p"}),"\n","Transmiterea unei variabile c\u0103tre o func\u021bie va realiza o ",(0,r.yg)("strong",{parentName:"p"},"mutare (move)")," sau o ",(0,r.yg)("strong",{parentName:"p"},"copiere (copy)"),", la fel ca o atribuire."),(0,r.yg)("p",null,"Exemplu (cite\u0219te comentariile):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s = String::from("hello");  // s intr\u0103 \xeen scope\n \n    takes_ownership(s);             // valoarea lui s este mutat\u0103 \xeen func\u021bie...\n                                    // ... deci nu mai este valid\u0103 aici\n \n    let x = 5;                      // x intr\u0103 \xeen scope\n \n    makes_copy(x);                  // o copie a lui x este transmis\u0103 func\u021biei,\n                                    // dar i32 are tr\u0103s\u0103tura Copy, deci putem\n                                    // folosi x \u0219i dup\u0103 aceea\n \n} // aici x iese din scope, apoi s. Dar cum s a fost mutat, nu se elibereaz\u0103 nimic.\n \nfn takes_ownership(some_string: String) { // some_string intr\u0103 \xeen scope\n    println!("{}", some_string);\n} // aici some_string iese din scope \u0219i `drop` este apelat. Memoria este eliberat\u0103.\n \nfn makes_copy(some_integer: i32) { // some_integer intr\u0103 \xeen scope\n    println!("{}", some_integer);\n} // aici some_integer iese din scope. Nu se \xeent\xe2mpl\u0103 nimic special.\n')),(0,r.yg)("p",null,"Dac\u0103 am \xeencerca s\u0103 folosim ",(0,r.yg)("inlineCode",{parentName:"p"},"s")," dup\u0103 apelul ",(0,r.yg)("inlineCode",{parentName:"p"},"take_ownership"),", Rust ar returna o eroare de compilare. Aceste verific\u0103ri statice ne protejeaz\u0103 de erori."),(0,r.yg)("h3",{id:"valori-returnate-\u0219i-scope"},"Valori returnate \u0219i scope"),(0,r.yg)("p",null,"Valorile returnate pot, de asemenea, transfera ownership-ul."),(0,r.yg)("p",null,"Proprietatea unei variabile urmeaz\u0103 acela\u0219i tipar: atribuirea unei valori unei alte variabile o mut\u0103.",(0,r.yg)("br",{parentName:"p"}),"\n","C\xe2nd o variabil\u0103 care con\u021bine date pe heap iese din scope, valoarea este eliberat\u0103 prin ",(0,r.yg)("inlineCode",{parentName:"p"},"drop"),", dac\u0103 proprietatea nu a fost transferat\u0103."),(0,r.yg)("p",null,"Exemplu:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s1 = gives_ownership();         // gives_ownership mut\u0103 valoarea returnat\u0103 \xeen s1\n \n    let s2 = String::from("hello");     // s2 intr\u0103 \xeen scope\n \n    let s3 = takes_and_gives_back(s2);  // s2 este mutat \xeen func\u021bie,\n                                        // care returneaz\u0103 o valoare mutat\u0103 \xeen s3\n} // aici s3 iese din scope \u0219i este eliberat. s2 a fost mutat, deci nimic nu se \xeent\xe2mpl\u0103. s1 este eliberat.\n \nfn gives_ownership() -> String {        // mut\u0103 valoarea returnat\u0103 c\u0103tre apelant\n    let some_string = String::from("yours");\n    some_string // se returneaz\u0103, mut\xe2nd proprietatea\n}\n \nfn takes_and_gives_back(a_string: String) -> String {\n    a_string // se returneaz\u0103 \u0219i mut\u0103 valoarea c\u0103tre apelant\n}\n')),(0,r.yg)("h3",{id:"referin\u021be-\u0219i-\xeemprumuturi-borrowing"},"Referin\u021be \u0219i \xeemprumuturi (Borrowing)"),(0,r.yg)("p",null,"O ",(0,r.yg)("strong",{parentName:"p"},"referin\u021b\u0103")," este similar\u0103 cu un pointer \u2014 este o adres\u0103 care permite accesul la datele stocate acolo, dar datele apar\u021bin altei variabile.",(0,r.yg)("br",{parentName:"p"}),"\n","Spre deosebire de pointere, o referin\u021b\u0103 este garantat\u0103 s\u0103 indice c\u0103tre o valoare valid\u0103 de un anumit tip pe durata vie\u021bii sale."),(0,r.yg)("p",null,"Simbolul ",(0,r.yg)("inlineCode",{parentName:"p"},"&")," marcheaz\u0103 o referin\u021b\u0103, fie \xeenaintea numelui unei variabile, fie \xeen tipul unui parametru. Acesta permite referirea unei valori f\u0103r\u0103 a-i lua proprietatea."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let x: u16 = 10;\nlet y = &x;\n")),(0,r.yg)("p",null,"Exemplu de func\u021bie care prime\u0219te o referin\u021b\u0103 la un obiect \xeen loc s\u0103 preia proprietatea asupra lui:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s1 = String::from("hello");\n    let len = calculate_length(&s1);\n    println!("The length of \'{}\' is {}.", s1, len);\n}\n \nfn calculate_length(s: &String) -> usize { // s este o referin\u021b\u0103 la un String\n    s.len()\n} // aici s iese din scope, dar nu de\u021bine valoarea, deci nu este eliberat\u0103\n')),(0,r.yg)("p",null,"Sintaxa ",(0,r.yg)("inlineCode",{parentName:"p"},"&s1")," creeaz\u0103 o referin\u021b\u0103 c\u0103tre valoarea lui ",(0,r.yg)("inlineCode",{parentName:"p"},"s1"),", f\u0103r\u0103 a o muta. Astfel, ",(0,r.yg)("inlineCode",{parentName:"p"},"s1")," r\u0103m\xe2ne valid\u0103 \u0219i dup\u0103 apel.",(0,r.yg)("br",{parentName:"p"}),"\n","\xcen semn\u0103tura func\u021biei, ",(0,r.yg)("inlineCode",{parentName:"p"},"&String")," indic\u0103 faptul c\u0103 parametrul este o referin\u021b\u0103."),(0,r.yg)("p",null,"Ac\u021biunea de a crea o referin\u021b\u0103 se nume\u0219te ",(0,r.yg)("strong",{parentName:"p"},"\xeemprumut (borrowing)"),". A\u0219a cum \xeen via\u021ba real\u0103 \xeemprumu\u021bi ceva f\u0103r\u0103 a deveni proprietar, la final trebuie s\u0103 returnezi acel obiect.",(0,r.yg)("br",{parentName:"p"}),"\n","Referin\u021ba nu este proprietar \u2014 doar folose\u0219te temporar valoarea."),(0,r.yg)("p",null,"La fel ca variabilele, referin\u021bele sunt ",(0,r.yg)("strong",{parentName:"p"},"imutabile")," implicit. Nu putem modifica valoarea c\u0103tre care indic\u0103 o referin\u021b\u0103 imutabil\u0103."),(0,r.yg)("h3",{id:"referin\u021be-mutabile"},"Referin\u021be mutabile"),(0,r.yg)("p",null,"Dac\u0103 vrem s\u0103 modific\u0103m valoarea unei referin\u021be, trebuie s\u0103 spunem explicit compilatorului acest lucru, folosind cuv\xe2ntul cheie ",(0,r.yg)("inlineCode",{parentName:"p"},"mut"),".",(0,r.yg)("br",{parentName:"p"}),"\n","Referin\u021bele mutabile au o restric\u021bie important\u0103: dac\u0103 exist\u0103 o referin\u021b\u0103 mutabil\u0103 c\u0103tre o valoare, nu pot exista alte referin\u021be c\u0103tre aceea\u0219i valoare."),(0,r.yg)("p",null,"De asemenea, nu putem avea o referin\u021b\u0103 mutabil\u0103 \xeen timp ce exist\u0103 o referin\u021b\u0103 imutabil\u0103 la aceea\u0219i valoare."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut s = String::from("hello");\n    change(&mut s);\n}\n \nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n')),(0,r.yg)("admonition",{type:"warning"},(0,r.yg)("p",{parentName:"admonition"},"Reguli pentru referin\u021be:"),(0,r.yg)("ol",{parentName:"admonition"},(0,r.yg)("li",{parentName:"ol"},"\xcen orice moment, po\u021bi avea fie o singur\u0103 referin\u021b\u0103 mutabil\u0103, fie oric\xe2te referin\u021be imutabile \u2014 dar nu ambele simultan."),(0,r.yg)("li",{parentName:"ol"},"Referin\u021bele trebuie s\u0103 fie \xeentotdeauna ",(0,r.yg)("strong",{parentName:"li"},"valide"),"."))),(0,r.yg)("h2",{id:"tr\u0103s\u0103tura-copy"},"Tr\u0103s\u0103tura ",(0,r.yg)("inlineCode",{parentName:"h2"},"Copy")),(0,r.yg)("p",null,"S\u0103 lu\u0103m un exemplu similar cu cel de mai devreme:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'let mut x: i32 = 0;\nlet mut y = x;\ny = 5;\nprintln!("{x}"); // Afi\u0219eaz\u0103 0\n')),(0,r.yg)("p",null,"De data aceasta, compilatorul nu a mutat variabila ",(0,r.yg)("inlineCode",{parentName:"p"},"x")," \xeen ",(0,r.yg)("inlineCode",{parentName:"p"},"y"),". De ce?",(0,r.yg)("br",{parentName:"p"}),"\n","Pentru c\u0103 ",(0,r.yg)("inlineCode",{parentName:"p"},"i32")," implementeaz\u0103 tr\u0103s\u0103tura ",(0,r.yg)("a",{parentName:"p",href:"https://doc.rust-lang.org/core/marker/trait.Copy.html"},(0,r.yg)("inlineCode",{parentName:"a"},"Copy")),".",(0,r.yg)("br",{parentName:"p"}),"\n","Aceasta este o tr\u0103s\u0103tur\u0103 folosit\u0103 pentru tipurile care pot fi copiate eficient bit\u2011cu\u2011bit \u0219i care nu permit existen\u021ba a dou\u0103 referin\u021be mutabile c\u0103tre aceea\u0219i loca\u021bie de memorie."),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Tip"),(0,r.yg)("th",{parentName:"tr",align:null},"Implementeaz\u0103 ",(0,r.yg)("inlineCode",{parentName:"th"},"Copy")),(0,r.yg)("th",{parentName:"tr",align:null},"Motiv"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"i32")),(0,r.yg)("td",{parentName:"tr",align:null},"Da"),(0,r.yg)("td",{parentName:"tr",align:null})),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"f64")),(0,r.yg)("td",{parentName:"tr",align:null},"Da"),(0,r.yg)("td",{parentName:"tr",align:null})),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"bool")),(0,r.yg)("td",{parentName:"tr",align:null},"Da"),(0,r.yg)("td",{parentName:"tr",align:null})),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"String")),(0,r.yg)("td",{parentName:"tr",align:null},"Nu"),(0,r.yg)("td",{parentName:"tr",align:null},"Con\u021bine un pointer c\u0103tre un buffer intern. Bufferul ar trebui duplicat la copiere, lucru pe care o copiere bit\u2011cu\u2011bit nu \xeel poate face.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"Vec<_>")),(0,r.yg)("td",{parentName:"tr",align:null},"Nu"),(0,r.yg)("td",{parentName:"tr",align:null},"La fel ca ",(0,r.yg)("inlineCode",{parentName:"td"},"String"),", de\u021bine un buffer intern care ar trebui duplicat.")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"&str")),(0,r.yg)("td",{parentName:"tr",align:null},"Da"),(0,r.yg)("td",{parentName:"tr",align:null})),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("inlineCode",{parentName:"td"},"&mut str")),(0,r.yg)("td",{parentName:"tr",align:null},"Nu"),(0,r.yg)("td",{parentName:"tr",align:null},"Copierea ar crea o alt\u0103 referin\u021b\u0103 mutabil\u0103 c\u0103tre aceea\u0219i valoare.")))),(0,r.yg)("p",null,"Po\u021bi implementa tr\u0103s\u0103tura ",(0,r.yg)("inlineCode",{parentName:"p"},"Copy")," pentru propriile structuri \u0219i enumuri folosind:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"#[derive(Clone, Copy)]\n")),(0,r.yg)("admonition",{type:"warning"},(0,r.yg)("p",{parentName:"admonition"},"Trebuie s\u0103 implementezi \u0219i tr\u0103s\u0103tura ",(0,r.yg)("inlineCode",{parentName:"p"},"Clone")," pentru a putea deriva ",(0,r.yg)("inlineCode",{parentName:"p"},"Copy"),".",(0,r.yg)("br",{parentName:"p"}),"\n","De asemenea, toate c\xe2mpurile structurii trebuie s\u0103 aib\u0103 tipuri care implementeaz\u0103 ",(0,r.yg)("inlineCode",{parentName:"p"},"Copy"),".")),(0,r.yg)("h2",{id:"bonus-pentru-acas\u0103"},"Bonus pentru acas\u0103"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Rescrie func\u021bia de la exerci\u021biul 2, dar de data aceasta implementeaz-o folosind ",(0,r.yg)("a",{parentName:"li",href:"https://www.geeksforgeeks.org/sieve-of-eratosthenes/"},"Sita lui Eratostene"),"."),(0,r.yg)("li",{parentName:"ol"},"Define\u0219te o structur\u0103 numit\u0103 ",(0,r.yg)("inlineCode",{parentName:"li"},"MiniTuring"),", cu un buffer de 256 valori booleene \u0219i un cursor.  ",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Scrie o func\u021bie static\u0103 ",(0,r.yg)("inlineCode",{parentName:"li"},"new")," care creeaz\u0103 o instan\u021b\u0103 a structurii.  "),(0,r.yg)("li",{parentName:"ul"},"Scrie o metod\u0103 ",(0,r.yg)("inlineCode",{parentName:"li"},"display")," care afi\u0219eaz\u0103 banda cu 1 \u0219i 0 \xeen loc de ",(0,r.yg)("inlineCode",{parentName:"li"},"true")," \u0219i ",(0,r.yg)("inlineCode",{parentName:"li"},"false"),", f\u0103r\u0103 spa\u021bii sau newline\u2011uri.  "),(0,r.yg)("li",{parentName:"ul"},"Cite\u0219te de la tastatur\u0103 p\xe2n\u0103 c\xe2nd se prime\u0219te \u201eh\u201d. \u201el\u201d mut\u0103 cursorul la st\xe2nga (cu revenire circular\u0103), \u201er\u201d la dreapta, \u201e1\u201d seteaz\u0103 valoarea la ",(0,r.yg)("inlineCode",{parentName:"li"},"true"),", \u201e0\u201d la ",(0,r.yg)("inlineCode",{parentName:"li"},"false"),", \u201ep\u201d afi\u0219eaz\u0103 valoarea curent\u0103, \u201eh\u201d afi\u0219eaz\u0103 \xeentreaga band\u0103."))),(0,r.yg)("li",{parentName:"ol"},"Creeaz\u0103 un parser de expresii aritmetice simple cu numere \xeentregi care accept\u0103 ",(0,r.yg)("inlineCode",{parentName:"li"},"+"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"-"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"*"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"/"),". Presupune c\u0103 nu exist\u0103 operator unar (ex: ",(0,r.yg)("inlineCode",{parentName:"li"},"5*-3"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"-2+7"),").  ",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Define\u0219te un ",(0,r.yg)("inlineCode",{parentName:"li"},"enum")," numit ",(0,r.yg)("inlineCode",{parentName:"li"},"Expression")," cu variante potrivite (indica\u021bie: folose\u0219te ",(0,r.yg)("a",{parentName:"li",href:"https://doc.rust-lang.org/alloc/boxed/struct.Box.html"},(0,r.yg)("inlineCode",{parentName:"a"},"Box")),").  "),(0,r.yg)("li",{parentName:"ul"},"Creeaz\u0103 o func\u021bie care returneaz\u0103 un ",(0,r.yg)("inlineCode",{parentName:"li"},"Expression")," pe baza unui \u0219ir dat, respect\xe2nd regulile de prioritate ale operatorilor.  "),(0,r.yg)("li",{parentName:"ul"},"Creeaz\u0103 o func\u021bie care prime\u0219te un ",(0,r.yg)("inlineCode",{parentName:"li"},"Expression")," \u0219i \xeel evalueaz\u0103 \xeentr-un ",(0,r.yg)("inlineCode",{parentName:"li"},"i32"),".  "),(0,r.yg)("li",{parentName:"ul"},"Cite\u0219te o expresie de la stdin \u0219i afi\u0219eaz\u0103 rezultatul.")))))}s.isMDXComponent=!0}}]);