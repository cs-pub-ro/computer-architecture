"use strict";(globalThis.webpackChunkcomputer_architecture=globalThis.webpackChunkcomputer_architecture||[]).push([[8353],{214:(e,a,i)=>{i.d(a,{A:()=>r});const r=i.p+"assets/images/counter.drawio-1c6d519d617e123f6fa20a5889ddaff4.png"},3398:(e,a,i)=>{i.d(a,{A:()=>r});const r=i.p+"assets/images/propagation-b8893b950745e1ad5741678f6cdf1479.png"},5680:(e,a,i)=>{i.d(a,{xA:()=>s,yg:()=>m});var r=i(6540);function t(e,a,i){return a in e?Object.defineProperty(e,a,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[a]=i,e}function n(e,a){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),i.push.apply(i,r)}return i}function l(e){for(var a=1;a<arguments.length;a++){var i=null!=arguments[a]?arguments[a]:{};a%2?n(Object(i),!0).forEach(function(a){t(e,a,i[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):n(Object(i)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(i,a))})}return e}function u(e,a){if(null==e)return{};var i,r,t=function(e,a){if(null==e)return{};var i,r,t={},n=Object.keys(e);for(r=0;r<n.length;r++)i=n[r],a.indexOf(i)>=0||(t[i]=e[i]);return t}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)i=n[r],a.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(t[i]=e[i])}return t}var c=r.createContext({}),o=function(e){var a=r.useContext(c),i=a;return e&&(i="function"==typeof e?e(a):l(l({},a),e)),i},s=function(e){var a=o(e.components);return r.createElement(c.Provider,{value:a},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},g=r.forwardRef(function(e,a){var i=e.components,t=e.mdxType,n=e.originalType,c=e.parentName,s=u(e,["components","mdxType","originalType","parentName"]),p=o(i),g=t,m=p["".concat(c,".").concat(g)]||p[g]||d[g]||n;return i?r.createElement(m,l(l({ref:a},s),{},{components:i})):r.createElement(m,l({ref:a},s))});function m(e,a){var i=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var n=i.length,l=new Array(n);l[0]=g;var u={};for(var c in a)hasOwnProperty.call(a,c)&&(u[c]=a[c]);u.originalType=e,u[p]="string"==typeof e?e:t,l[1]=u;for(var o=2;o<n;o++)l[o]=i[o];return r.createElement.apply(null,l)}return r.createElement.apply(null,i)}g.displayName="MDXCreateElement"},7799:(e,a,i)=>{i.d(a,{A:()=>r});const r=i.p+"assets/images/sync.drawio-defe5478a1e616c7374c81adba39df1f.png"},7922:(e,a,i)=>{i.r(a),i.d(a,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>n,metadata:()=>u,toc:()=>o});var r=i(8168),t=(i(6540),i(5680));const n={},l="Design reportat la descriere hardware",u={unversionedId:"Laboratoare/8 Verilog Design \u0219i Verificare/Design/Teorie/README",id:"Laboratoare/8 Verilog Design \u0219i Verificare/Design/Teorie/README",title:"Design reportat la descriere hardware",description:"Domeniul cu care se ocup\u0103 materia Arhitectura Calculatoarelor este una din ramurile importante aferente Computer Science-ului, mai exact este cel mai de jos nivel, de unde pleac\u0103 partea de descriere a hardware-ului care mai t\xe2rziu ajunge s\u0103 fie programat: CPU, GPU, microcontrolere, \u0219i alte circuite dedicate unei aplica\u021bii specifice (ASIC).",source:"@site/docs/Laboratoare/8 Verilog Design \u0219i Verificare/Design/Teorie/README.md",sourceDirName:"Laboratoare/8 Verilog Design \u0219i Verificare/Design/Teorie",slug:"/Laboratoare/8 Verilog Design \u0219i Verificare/Design/Teorie/",permalink:"/computer-architecture/Laboratoare/8 Verilog Design \u0219i Verificare/Design/Teorie/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Design",permalink:"/computer-architecture/Laboratoare/8 Verilog Design \u0219i Verificare/Design/"},next:{title:"9 Calculator Didactic",permalink:"/computer-architecture/Laboratoare/9 Calculator Didactic/"}},c={},o=[{value:"La ce ne referim prin design?",id:"la-ce-ne-referim-prin-design",level:3},{value:"Cum descriem hardware-ul?",id:"cum-descriem-hardware-ul",level:3},{value:"Exemplu de descriere de circuit",id:"exemplu-de-descriere-de-circuit",level:3},{value:"Bonus: sincroniz\u0103ri de ceas",id:"bonus-sincroniz\u0103ri-de-ceas",level:2}],s={toc:o},p="wrapper";function d({components:e,...a}){return(0,t.yg)(p,(0,r.A)({},s,a,{components:e,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"design-reportat-la-descriere-hardware"},"Design reportat la descriere hardware"),(0,t.yg)("p",null,"Domeniul cu care se ocup\u0103 materia Arhitectura Calculatoarelor este una din ramurile importante aferente Computer Science-ului, mai exact este cel mai de jos nivel, de unde pleac\u0103 partea de descriere a hardware-ului care mai t\xe2rziu ajunge s\u0103 fie programat: CPU, GPU, microcontrolere, \u0219i alte circuite dedicate unei aplica\u021bii specifice (ASIC)."),(0,t.yg)("p",null,"\xcen general, aceast\u0103 munc\u0103 se \xeemparte \xeen mai multe echipe, fiecare cu responsabilit\u0103\u021bile ei \u0219i expertiza ei:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"arhitect de specifica\u021bii (cel care se ocup\u0103 de descrierea tehnic\u0103 a produsului);"),(0,t.yg)("li",{parentName:"ul"},"inginer de design/descriere (cel care implementeaz\u0103 arhitectura descris\u0103 de mai sus);"),(0,t.yg)("li",{parentName:"ul"},"inginer de verificare (cel care se ocup\u0103 ca acel design respect\u0103 specifica\u021biile).")),(0,t.yg)("p",null,"\xcen continuare, vom discuta despre responsabilit\u0103\u021bile inginerului de design \u0219i ce ar trebui s\u0103 \u0219tie acesta."),(0,t.yg)("h3",{id:"la-ce-ne-referim-prin-design"},"La ce ne referim prin design?"),(0,t.yg)("p",null,"Lec\u021biile de p\xe2n\u0103 acum s-au folosit de 2 tipuri de fi\u0219iere ca s\u0103 putem compila \u0219i observa efectele modulelor descrise:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"RTL")," (register-transfer layer): sunt tipurile de fi\u0219iere ce con\u021bin descrierea hardware a circuitului dorit, la nivel de logic\u0103 combina\u021bional\u0103 (por\u021bi logice, multiplexoare, demultiplexoare \u0219i decodoare) \u0219i secven\u021bial\u0103 (registrii, celule de memorie \u0219i latch-uri);"),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Test-bench"),": fi\u0219ierele care descriu cum acele module construite anterior sunt stimulate pentru a testa toat\u0103 func\u021bionalitatea acestora.")),(0,t.yg)("p",null,"Inginerul de design este responsabil de scrierea RTL-ului, dar implementeaz\u0103 \u0219i test-bench-uri cu care poate verifica func\u021bionalitatea de baz\u0103 a hardware-ului."),(0,t.yg)("h3",{id:"cum-descriem-hardware-ul"},"Cum descriem hardware-ul?"),(0,t.yg)("p",null,"HDL-urile sunt limbaje care se diferen\u021biaz\u0103 de cele de programare precum C, Java, Python, etc. prin faptul c\u0103 acestea au fost concepute cu scopul de a le fi u\u0219or inginerilor s\u0103 poat\u0103 transpune circuitele electronice \xeen text, sau \xeentr-un cod ce mai t\xe2rziu poate fi compilat \xeen por\u021bi logice."),(0,t.yg)("blockquote",null,(0,t.yg)("p",{parentName:"blockquote"},"Prin ",(0,t.yg)("strong",{parentName:"p"},"RTL")," \xeen\u021belegem codul sintetizabil care este compus din totalitatea registriilor \u0219i logica ce le leag\u0103 pentru a descrie circuitul dorit.")),(0,t.yg)("blockquote",null,(0,t.yg)("p",{parentName:"blockquote"},(0,t.yg)("strong",{parentName:"p"},"Sintetizabilitatea")," se refer\u0103 la abilitatea codului HDL de a putea fi tradus sub forma unor por\u021bi logice, elemente de memorie \u0219i leg\u0103turile dintre acestea.")),(0,t.yg)("p",null,"\xcen Verilog nu toate elementele de cod sunt sintetizabile (de exemplu ",(0,t.yg)("inlineCode",{parentName:"p"},"initial"),"), a\u0219a c\u0103 trebuie s\u0103 avem grij\u0103 de modul \xeen care scriem codul \xeen RTL."),(0,t.yg)("p",null,"Scopul final al codului RTL este traducerea sa sub forma unor construc\u021bii fizice (bistabili, por\u021bi logice) care se reg\u0103sesc \xeen bibliotecile tehnologiei foloste (prin tehnologie, se refer\u0103 aici la m\u0103rimea nodului, ex. 14nm ca Intel Coffee Lake sau 800 microni ca Intel Pentium)."),(0,t.yg)("p",null,"\xcen test bench, nu se pune problema asta, c\u0103ci are un alt scop \u0219i nu va fi present \xeen procesul de fabrica\u021bie."),(0,t.yg)("p",null,"Exist\u0103 c\xe2teva reguli de baz\u0103 dup\u0103 care ne putem ghida \xeen acest caz:"),(0,t.yg)("blockquote",null,(0,t.yg)("ol",{parentName:"blockquote"},(0,t.yg)("li",{parentName:"ol"},"Orice primitiv\u0103 sau operator se poate sintetiza. Totu\u0219i, trebuie men\u021bionat c\u0103 aceste opera\u021bii nu vor fi neap\u0103rat direct traduse \xeen unit\u0103\u021bi care func\u021bioneaz\u0103 la nivel general, ci compilatorul va \xeencerca s\u0103 simplifice func\u021bia logic\u0103."))),(0,t.yg)("blockquote",null,(0,t.yg)("ol",{parentName:"blockquote",start:2},(0,t.yg)("li",{parentName:"ol"},"\xcen HDL, exist\u0103 \xeen general 2 tipuri de variabile care se suprapun cu concepte din electronic\u0103: fire sau semnale de leg\u0103tur\u0103 \u0219i structuri ce pot memora valori. \xcen Verilog, acestea sunt descrise de ",(0,t.yg)("inlineCode",{parentName:"li"},"wire"),", respectiv ",(0,t.yg)("inlineCode",{parentName:"li"},"reg"),". A nu se confunda ",(0,t.yg)("inlineCode",{parentName:"li"},"reg")," cu registrul \ud83e\udd14."))),(0,t.yg)("blockquote",null,(0,t.yg)("ol",{parentName:"blockquote",start:3},(0,t.yg)("li",{parentName:"ol"},"Construc\u021bia ",(0,t.yg)("inlineCode",{parentName:"li"},"always@(*)")," se refer\u0103 la o grupare de logic\u0103 combina\u021bional\u0103, \xeen general folosit\u0103 pentru a descrie automatele pe st\u0103ri definite (sau FSM-uri) sau pentru gruparea a mai multor semnale schimbate asincron. \xcen general, acestea se comport\u0103 similar cu semnalele ce sunt atribuite cu constructul ",(0,t.yg)("inlineCode",{parentName:"li"},"assign"),", diferen\u021ba o face faptul c\u0103 ",(0,t.yg)("inlineCode",{parentName:"li"},"always@(*)")," cere folosirea variabilelor de tip ",(0,t.yg)("inlineCode",{parentName:"li"},"reg"),". Aceast\u0103 diferen\u021b\u0103 este important\u0103, \xeentruc\xe2t structurile ",(0,t.yg)("inlineCode",{parentName:"li"},"always@(*)")," se pot sintetiza \xeen celule de tip latch:"))),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"}," reg[1:0] a;\n always@(*) begin: latch\n     if (a == 2'b01)\n         a = 2b'00;\n     else if (a == 2'b10)\n         a = 2'b01;\n     else if(a == 2'b00)\n         a == 2'b11;\n // La un moment dat ceva ajunge 2'b11 \u0219i valoarea va r\u0103m\xe2ne blocat\u0103\n // p\xe2n\u0103 la un reset hardware.\n end: latch\n")),(0,t.yg)("blockquote",null,(0,t.yg)("ol",{parentName:"blockquote",start:4},(0,t.yg)("li",{parentName:"ol"},"\xcen general nu este de dorit a avea latch-uri \xeen RTL, pentru c\u0103 este greu de verificat starea acestei variabile pe durata func\u021bion\u0103rii circuitului."))),(0,t.yg)("blockquote",null,(0,t.yg)("ol",{parentName:"blockquote",start:5},(0,t.yg)("li",{parentName:"ol"},"Circuitele secven\u021biale sunt cele de tip ",(0,t.yg)("inlineCode",{parentName:"li"},"always@(posedge clk or negedge rst)"),', care sunt structurile principale de memorie \xeentr-un circuit, \u0219i pot fi asociate cu bistabilii (flip-flops). Ele re\u021bin valoarea din interior p\xe2n\u0103 la "c\u0103derea" reset-ului sau stimularea intr\u0103rilor bistabilului. Ace\u0219tia, \xeen cele din urm\u0103, pot fi asocia\u021bi cu registrii, dar ',(0,t.yg)("inlineCode",{parentName:"li"},"reg")," are sens de variabil\u0103 ce re\u021bine valoarea dat\u0103."))),(0,t.yg)("h3",{id:"exemplu-de-descriere-de-circuit"},"Exemplu de descriere de circuit"),(0,t.yg)("p",null,"\xcen cadrul laboratorului de ast\u0103zi, vom implementa un modul des \xeent\xe2lnit \xeen circuite integrate, acesta fiind num\u0103r\u0103torul (sau counter). Acesta este des \xeent\xe2lnit \xeen procesoare pentru a crea tick-ul de milisecund\u0103 \xeen watchdog-uri, sau pentru generarea semnalelor de PWM (pulse width modulation)."),(0,t.yg)("p",null,"Prima etap\u0103 \xeen elaborarea RTL-ului este de a citi \u0219i \xeen\u021belege arhitectura pe care inginerul de arhitectur\u0103 a g\xe2ndit-o pentru acesta:"),(0,t.yg)("div",{align:"center"},(0,t.yg)("p",null,(0,t.yg)("img",{alt:"Diagrama modulului counter",src:i(214).A,width:"612",height:"593"})),(0,t.yg)("p",null,(0,t.yg)("em",{parentName:"p"},"Figure: Diagrama \xeempreun\u0103 cu I/O pentru modulul counter"))),(0,t.yg)("p",null,"Pe l\xe2ng\u0103 diagram\u0103, exist\u0103 \u0219i un tabel cu semnifica\u021bia semnalelor \u0219i cum ar trebui s\u0103 func\u021bioneze modulul (care e practic specifica\u021bia arhitecturii)."),(0,t.yg)("table",null,(0,t.yg)("thead",{parentName:"table"},(0,t.yg)("tr",{parentName:"thead"},(0,t.yg)("th",{parentName:"tr",align:null},(0,t.yg)("strong",{parentName:"th"},"Nume semnal")),(0,t.yg)("th",{parentName:"tr",align:null},(0,t.yg)("strong",{parentName:"th"},"Direc\u021bie")),(0,t.yg)("th",{parentName:"tr",align:null},(0,t.yg)("strong",{parentName:"th"},"M\u0103rime")),(0,t.yg)("th",{parentName:"tr",align:null},(0,t.yg)("strong",{parentName:"th"},"Descriere")))),(0,t.yg)("tbody",{parentName:"table"},(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"WIDTH"),(0,t.yg)("td",{parentName:"tr",align:null},"parameter"),(0,t.yg)("td",{parentName:"tr",align:null},"-"),(0,t.yg)("td",{parentName:"tr",align:null},"L\u0103\u021bimea de band\u0103 a datelor din num\u0103r\u0103tor")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"RESET_VAL"),(0,t.yg)("td",{parentName:"tr",align:null},"parameter"),(0,t.yg)("td",{parentName:"tr",align:null},"[WIDTH-1:0]"),(0,t.yg)("td",{parentName:"tr",align:null},"Valoarea cu care num\u0103r\u0103torul poate fi instan\u021biat la ",(0,t.yg)("inlineCode",{parentName:"td"},"soft_rst"))),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"clk"),(0,t.yg)("td",{parentName:"tr",align:null},"input"),(0,t.yg)("td",{parentName:"tr",align:null},"1"),(0,t.yg)("td",{parentName:"tr",align:null},"Ceasul num\u0103r\u0103torului")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"rst_n"),(0,t.yg)("td",{parentName:"tr",align:null},"input"),(0,t.yg)("td",{parentName:"tr",align:null},"1"),(0,t.yg)("td",{parentName:"tr",align:null},"Reset asincron (activ pe low)")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"soft_rst"),(0,t.yg)("td",{parentName:"tr",align:null},"input"),(0,t.yg)("td",{parentName:"tr",align:null},"1"),(0,t.yg)("td",{parentName:"tr",align:null},"Reset soft (activ pe high), reseteaz\u0103 la ",(0,t.yg)("inlineCode",{parentName:"td"},"RESET_VAL")," doar starea intern\u0103 a num\u0103r\u0103torului; are prioritate fa\u021b\u0103 de ",(0,t.yg)("inlineCode",{parentName:"td"},"ena")," \u0219i ",(0,t.yg)("inlineCode",{parentName:"td"},"set"))),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"set"),(0,t.yg)("td",{parentName:"tr",align:null},"input"),(0,t.yg)("td",{parentName:"tr",align:null},"1"),(0,t.yg)("td",{parentName:"tr",align:null},"Seteaz\u0103 valoarea num\u0103r\u0103torului cu cea provenit\u0103 din ",(0,t.yg)("inlineCode",{parentName:"td"},"setcount"),"; are prioritate fa\u021b\u0103 de ",(0,t.yg)("inlineCode",{parentName:"td"},"ena"))),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"setcount"),(0,t.yg)("td",{parentName:"tr",align:null},"input"),(0,t.yg)("td",{parentName:"tr",align:null},"[WIDTH-1:0]"),(0,t.yg)("td",{parentName:"tr",align:null},"Valoarea ce poate fi atribuit\u0103 num\u0103r\u0103torului prin semnalul de ",(0,t.yg)("inlineCode",{parentName:"td"},"set"))),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"ena"),(0,t.yg)("td",{parentName:"tr",align:null},"input"),(0,t.yg)("td",{parentName:"tr",align:null},"1"),(0,t.yg)("td",{parentName:"tr",align:null},"Actualizeaz\u0103 valoarea num\u0103r\u0103torului \xeen func\u021bie de ",(0,t.yg)("inlineCode",{parentName:"td"},"upnotdown")," la fiecare ciclu de ceas")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"count"),(0,t.yg)("td",{parentName:"tr",align:null},"output"),(0,t.yg)("td",{parentName:"tr",align:null},"[WIDTH-1:0]"),(0,t.yg)("td",{parentName:"tr",align:null},"Valoarea memorat\u0103 a num\u0103r\u0103torului")))),(0,t.yg)("p",null,"Cu ajutorul tabelului \u0219i a diagramei, putem implementa modulul counter care se poate reg\u0103si \xeen ",(0,t.yg)("inlineCode",{parentName:"p"},"counter.v"),"."),(0,t.yg)("h2",{id:"bonus-sincroniz\u0103ri-de-ceas"},"Bonus: sincroniz\u0103ri de ceas"),(0,t.yg)("p",null,"Un aspect destul de important al descrierii hardware, mai ales c\xe2nd vine vorba de sisteme complexe precum CPU-uri, microcontrolere sau SoC-uri (",(0,t.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/System_on_a_chip"},"System on a Chip"),"), este problema sincroniz\u0103rii datelor dintr-un domeniu de ceas \xeen altul, \xeen momentul \xeen care diferite por\u021biuni folosesc ceasuri cu frecven\u021be diferite (fie pentru economisire de energie, fie din alte motive)."),(0,t.yg)("blockquote",null,(0,t.yg)("p",{parentName:"blockquote"},"Dac\u0103 v\u0103 aminti\u021bi de la Electronic\u0103 Digital\u0103, circuitele digitale sunt compuse din ",(0,t.yg)("strong",{parentName:"p"},"tranzistori")," care, din construc\u021bia lor, se comport\u0103 asemenea unor circuite de tip RC.")),(0,t.yg)("p",null,"Acestea nu comut\u0103 instantaneu, ci au un timp de cre\u0219tere \u0219i de c\u0103dere ce, la frecven\u021be foarte mari, pot ridica probleme vis-a-vis de transmisia datelor."),(0,t.yg)("p",null,"C\xe2nd 2 circuite la frecven\u021be diferite vor s\u0103 comunice, acestea trebuie s\u0103 respecte timpul de propagare a semnalului, astfel \xeenc\xe2t datele s\u0103 nu se modifice \xeen circuitul sincron undeva pe muchia ceasului pe care aceste date vor s\u0103 fie scrise."),(0,t.yg)("div",{align:"center"},(0,t.yg)("p",null,(0,t.yg)("img",{alt:"Grafic propagare a schimb\u0103rii unui semnal pe tranzistor",src:i(3398).A,width:"763",height:"425"})),(0,t.yg)("p",null,(0,t.yg)("em",{parentName:"p"},"Figure: Grafic propagare a schimb\u0103rii unui semnal pe tranzistor, cu rise \u0219i fall time"))),(0,t.yg)("p",null,"Regula general\u0103 este c\u0103 aceste date trebuie s\u0103 se stabilizeze undeva dup\u0103 muchia ascendent\u0103 a ceasului, \xeen cazul cel mai bun chiar la jum\u0103tatea perioadei ceasului (sau muchia descendent\u0103)."),(0,t.yg)("p",null,"Tehnica folosit\u0103 pentru a reu\u0219i acest lucru este folosirea unor sincronizatoare \xeen 2 etape, care arat\u0103 asa."),(0,t.yg)("div",{align:"center"},(0,t.yg)("p",null,(0,t.yg)("img",{alt:"Diagrama unui sincronizator \xeen 2 etape folosind bistabili D",src:i(7799).A,width:"717",height:"303"})),(0,t.yg)("p",null,(0,t.yg)("em",{parentName:"p"},"Figure: Diagrama unui sincronizator \xeen 2 etape folosind bistabili D"))),(0,t.yg)("p",null,"Sunt de precizat c\xe2teva reguli legat de sincroniz\u0103rile de date:"),(0,t.yg)("blockquote",null,(0,t.yg)("ol",{parentName:"blockquote"},(0,t.yg)("li",{parentName:"ol"},"\xcen general, aceste sincroniz\u0103ri func\u021bioneaz\u0103 pentru semnale de 1 bit. La mai mul\u021bi bi\u021bi, pentru c\u0103 ",(0,t.yg)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Metastability_(electronics)"},"nu \u0219tim cu certitudine")," cum primul bistabil din circuit va interpreta semnalul incert (a c\u0103rui schimbare pic\u0103 fix pe muchia ascendent\u0103 a ceasului domeniului B), este foarte posibil ca datele sincronizate s\u0103 nu aib\u0103 valoarea la care ne-am a\u0219teptat."))),(0,t.yg)("blockquote",null,(0,t.yg)("ol",{parentName:"blockquote",start:2},(0,t.yg)("li",{parentName:"ol"},"Pentru a sincroniza magistrale, se merge pe principiul sincroniz\u0103rii unui semnal auxiliar care las\u0103 datele s\u0103 schimbe registrul din domeniul B odat\u0103 ce acesta este sincronizat cu succes."))),(0,t.yg)("blockquote",null,(0,t.yg)("ol",{parentName:"blockquote",start:3},(0,t.yg)("li",{parentName:"ol"},"De asemenea, nu se pot sincroniza cu certitudine semnalele de tip puls \xeentre domenii de ceasuri diferite, deoarece un puls provenit dintr-un ceas mai rapid nu \xeei poate fi detectat\u0103 schimbarea \xeen domeniul mai lent. Pentru asta, se folosesc module de tip ",(0,t.yg)("a",{parentName:"li",href:"https://fpgacpu.ca/fpga/CDC_Pulse_Synchronizer_2phase.html"},"sincropuls"),"."))),(0,t.yg)("p",null,"Pute\u021bi s\u0103 accesa\u021bi link-urile date \xeen acest material pentru a aprofunda subiectul. Acesta nu intr\u0103 \xeen programa materiei, dar este deseori important \xeen munca de design \u0219i v\u0103 poate util in cadrul interviurilor."))}d.isMDXComponent=!0}}]);