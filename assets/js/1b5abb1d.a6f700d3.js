"use strict";(self.webpackChunkcomputer_architecture=self.webpackChunkcomputer_architecture||[]).push([[943],{5680:(e,a,r)=>{r.d(a,{xA:()=>p,yg:()=>d});var t=r(6540);function i(e,a,r){return a in e?Object.defineProperty(e,a,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[a]=r,e}function n(e,a){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),r.push.apply(r,t)}return r}function l(e){for(var a=1;a<arguments.length;a++){var r=null!=arguments[a]?arguments[a]:{};a%2?n(Object(r),!0).forEach((function(a){i(e,a,r[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(r,a))}))}return e}function o(e,a){if(null==e)return{};var r,t,i=function(e,a){if(null==e)return{};var r,t,i={},n=Object.keys(e);for(t=0;t<n.length;t++)r=n[t],a.indexOf(r)>=0||(i[r]=e[r]);return i}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(t=0;t<n.length;t++)r=n[t],a.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var u=t.createContext({}),m=function(e){var a=t.useContext(u),r=a;return e&&(r="function"==typeof e?e(a):l(l({},a),e)),r},p=function(e){var a=m(e.components);return t.createElement(u.Provider,{value:a},e.children)},c="mdxType",s={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},g=t.forwardRef((function(e,a){var r=e.components,i=e.mdxType,n=e.originalType,u=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=m(r),g=i,d=c["".concat(u,".").concat(g)]||c[g]||s[g]||n;return r?t.createElement(d,l(l({ref:a},p),{},{components:r})):t.createElement(d,l({ref:a},p))}));function d(e,a){var r=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var n=r.length,l=new Array(n);l[0]=g;var o={};for(var u in a)hasOwnProperty.call(a,u)&&(o[u]=a[u]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var m=2;m<n;m++)l[m]=r[m];return t.createElement.apply(null,l)}return t.createElement.apply(null,r)}g.displayName="MDXCreateElement"},7085:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>u,contentTitle:()=>l,default:()=>s,frontMatter:()=>n,metadata:()=>o,toc:()=>m});var t=r(8168),i=(r(6540),r(5680));const n={},l="Exerci\u021bii",o={unversionedId:"Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103/README",id:"Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103/README",title:"Exerci\u021bii",description:"Seven-segment display",source:"@site/docs/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103/README.md",sourceDirName:"Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103",slug:"/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103/",permalink:"/computer-architecture/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Descrierea comportamental\u0103",permalink:"/computer-architecture/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Teorie/"},next:{title:"4 Verilog Secven\u021bial",permalink:"/computer-architecture/Laboratoare/4 Verilog Secven\u021bial/"}},u={},m=[{value:"Seven-segment display",id:"seven-segment-display",level:2}],p={toc:m},c="wrapper";function s(e){let{components:a,...n}=e;return(0,i.yg)(c,(0,t.A)({},p,n,{components:a,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"exerci\u021bii"},"Exerci\u021bii"),(0,i.yg)("h2",{id:"seven-segment-display"},"Seven-segment display"),(0,i.yg)("p",null,"Acest tip de dispozitiv de afi\u0219are este alc\u0103tuit, a\u0219a cum v\u0103 pute\u021bi da seama \u0219i din numele acestuia, din 7 segmente controlabile individual. A\u0219adar, putem aprinde (1 logic) sau stinge (0 logic) fiecare segment din componen\u021ba acestuia."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Reprezentarea numerelor \xeen format hexazecimal consider\xe2nd un afi\u0219aj cu 7 segmente",src:r(6197).A,width:"506",height:"512"})),(0,i.yg)("p",null,(0,i.yg)("em",{parentName:"p"},"Figure: Reprezentarea numerelor \xeen format hexazecimal consider\xe2nd un afi\u0219aj cu 7 segmente")),(0,i.yg)("p",null,"De exemplu, dac\u0103 dorim s\u0103 afi\u0219\u0103m cifra 6, ie\u0219irea noastr\u0103 va avea valoarea ''7\u2019b111_1101''."),(0,i.yg)("p",null,"Pentru mai multe detalii asupra acestui tip de modul, consulta\u021bi pagina de ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Seven-segment_display"},"Wiki"),"."),(0,i.yg)("p",null,"  Solu\u021bia se afl\u0103 \xeen repo-ul materiei ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/cs-pub-ro/computer-architecture/tree/main/chapters/verilog/behavioral/drills/tasks"},"GitHub"),". "),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Implementa\u021bi \u0219i simula\u021bi un ",(0,i.yg)("strong",{parentName:"li"},"multiplicator pe 4 bi\u021bi")," f\u0103r\u0103 a folosi operatorul * (\xeenmul\u021bire).",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Hint"),": Folosi\u021bi conven\u021bia Verilog pentru interfa\u021ba modulului. C\xe2\u021bi bi\u021bi are ie\u0219irea? "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Hint"),": \xcenmul\u021bi\u021bi pe h\xe2rtie, \xeen baza 2, numerele 1001 \u0219i 1011. Transpune\u021bi \xeen limbajul Verilog algoritmul folosit."))),(0,i.yg)("li",{parentName:"ol"},"Implementa\u021bi \u0219i simula\u021bi un modul de ",(0,i.yg)("strong",{parentName:"li"},"afi\u0219aj cu 7 segmente")," pentru numere \xeen baza 10.",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Hint"),": Exist\u0103 o ie\u0219ire valid\u0103 pentru fiecare intrare? Nu uita\u021bi de cazul ''default''. "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Hint"),": Se vor testa doar cifrele de la 0 la 9."))),(0,i.yg)("li",{parentName:"ol"},"Implementa\u021bi o ",(0,i.yg)("strong",{parentName:"li"},"unitate aritmetico-logic\u0103")," simpl\u0103 (UAL), pe ",(0,i.yg)("strong",{parentName:"li"},"4")," bi\u021bi, cu 2 opera\u021bii: adunare \u0219i \xeenmul\u021bire. Folosi\u021bi o intrare de selec\u021bie de 1 bit pentru a alege \xeentre cele dou\u0103 opera\u021bii astfel: 0 - adunare, 1 - \xeenmul\u021bire.",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Hint"),": C\xe2\u021bi bi\u021bi au ie\u0219irea sumatorului \u0219i a multiplicatorului? Dar a UAL-ului? "),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Hint"),": Pentru selec\u021bia dintre ie\u0219irea sumatorului \u0219i cea a multiplicatorului se poate folosi atribuirea continu\u0103 sau se poate implementa un modul multiplexor 2:1 "),(0,i.yg)("li",{parentName:"ul"},"Pentru o utilizare mai general\u0103, implementa\u021bi un UAL cu operatori cu dimensiune variabil\u0103. ",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Hint"),": Pentru a-l implementa, este necesar\u0103 implementarea unui multiplicator parametrizat - aten\u021bie la dimensiunea semnalelor!")))))))}s.isMDXComponent=!0},6197:(e,a,r)=>{r.d(a,{A:()=>t});const t=r.p+"assets/images/7seg-40188e007b1db4de8a3ea7e696a21be7.png"}}]);