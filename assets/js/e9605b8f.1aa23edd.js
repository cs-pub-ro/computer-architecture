"use strict";(globalThis.webpackChunkcomputer_architecture=globalThis.webpackChunkcomputer_architecture||[]).push([[7948],{731:(e,a,i)=>{i.r(a),i.d(a,{assets:()=>o,contentTitle:()=>l,default:()=>s,frontMatter:()=>n,metadata:()=>u,toc:()=>c});var t=i(8168),r=(i(6540),i(5680));const n={},l="Parametrizare",u={unversionedId:"Laboratoare AB/3 RHDL Secvential/Parametrizare/Teorie/README",id:"Laboratoare AB/3 RHDL Secvential/Parametrizare/Teorie/README",title:"Parametrizare",description:"Pana acuma, noi am facut doar circuite de marime statica. Un adder care este hardcodat la 4 biti poate avea o utilitate nisata, doar ca in general nu este util daca vrem sa adunam numere de N biti.",source:"@site/docs/Laboratoare AB/3 RHDL Secvential/Parametrizare/Teorie/README.md",sourceDirName:"Laboratoare AB/3 RHDL Secvential/Parametrizare/Teorie",slug:"/Laboratoare AB/3 RHDL Secvential/Parametrizare/Teorie/",permalink:"/computer-architecture/Laboratoare AB/3 RHDL Secvential/Parametrizare/Teorie/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Parametrizare",permalink:"/computer-architecture/Laboratoare AB/3 RHDL Secvential/Parametrizare/"},next:{title:"Circuite Secventiale",permalink:"/computer-architecture/Laboratoare AB/3 RHDL Secvential/Circuite Secventiale/"}},o={},c=[{value:"Parametrizare derivata",id:"parametrizare-derivata",level:2},{value:"Macro-ul op!()",id:"macro-ul-op",level:3},{value:"Crate-ul bitops_rhdl",id:"crate-ul-bitops_rhdl",level:2},{value:"Motivatie",id:"motivatie",level:3},{value:"Usage",id:"usage",level:3},{value:"Indexing",id:"indexing",level:3},{value:"Packing",id:"packing",level:3}],p={toc:c},m="wrapper";function s({components:e,...a}){return(0,r.yg)(m,(0,t.A)({},p,a,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"parametrizare"},"Parametrizare"),(0,r.yg)("p",null,"Pana acuma, noi am facut doar circuite de marime statica. Un adder care este hardcodat la 4 biti poate avea o utilitate nisata, doar ca in general nu este util daca vrem sa adunam numere de N biti."),(0,r.yg)("p",null,"Pentru a putea reutiliza circuitele pe care le scriem, pentru mai multe cazuri de utilizare, este o idee bun\u0103 s\u0103 le facem parametrizabile.\nAcest lucru \xeel putem face folosindu-ne de ",(0,r.yg)("em",{parentName:"p"},"generics"),". "),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"#[kernel]\nfn my_parameterized_circuit<U: Unsigned>(_cr: ClockReset, i: (Bits<U>, Bits<U>)) -> Bits<U>\nwhere\n    U: Unsigned + BitWidth + Eq + Copy,\n{\n    // your logic here\n}\n\ntype MyParameterizedCircuit<U> = Func<(Bits<U>, Bits<U>), Bits<U>>;\n\nfn new<U>() -> Result<MyParameterizedCircuit<U>, RHDLError>\nwhere\n    U: Unsigned + BitWidth + Eq + Copy,\n{\n    Func::try_new::<my_parameterized_circuit<U>>()\n}\n")),(0,r.yg)("p",null,"Pentru a crea instan\u021be pentru aceste circuite:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"let circuit4: MyParameterizedCircuit<U4> = new::<U4>()?;\nlet circuit8: MyParameterizedCircuit<U8> = new::<U8>()?;\n")),(0,r.yg)("p",null,"Sunt de mentionat 2 fapte totusi,\nin primul rand, parametrii generici, mai ales care vor fi folositi la width-ul unei structuri ",(0,r.yg)("inlineCode",{parentName:"p"},"Bits"),", va fi obligatorie sa fie un ",(0,r.yg)("inlineCode",{parentName:"p"},"Type")," (in cazul la ",(0,r.yg)("inlineCode",{parentName:"p"},"Bits")," acel type va fi si obligat sa implementeze ",(0,r.yg)("inlineCode",{parentName:"p"},"BitWidth"),").\nIn al 2lea rand, orice semnatura de functie trebuie sa poata sa aibe lungimile\ndeduse la compile-time."),(0,r.yg)("h2",{id:"parametrizare-derivata"},"Parametrizare derivata"),(0,r.yg)("admonition",{type:"warning"},(0,r.yg)("p",{parentName:"admonition"},(0,r.yg)("em",{parentName:"p"},"NU")," putem face operatii de genul ",(0,r.yg)("inlineCode",{parentName:"p"},"Bits<U+T>"),", cel putin nu cu metode conventionale. Putem totusi sa emulam asftel de operatii cu wrappere de type")),(0,r.yg)("p",null,"In ",(0,r.yg)("inlineCode",{parentName:"p"},"rhdl_typenum")," avem mai multe tipuri auxiliare care ne pot ajuta sa facem operatii la nivel generic, spre exemplu:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"Add1")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"Sum")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"Diff")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"Maximum")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"Minimum"))),(0,r.yg)("p",null,"E de mentionat ca fiecare are conditii aditionale, spre exemplu pe langa ca toate trebuie sa fie BitWidth, trebuie ca"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"La ",(0,r.yg)("inlineCode",{parentName:"li"},"Add1<T>")," trebuie ca ",(0,r.yg)("inlineCode",{parentName:"li"},"T: Add<U1>")),(0,r.yg)("li",{parentName:"ul"},"La ",(0,r.yg)("inlineCode",{parentName:"li"},"Sum<T1,T2>")," trebuie ca ",(0,r.yg)("inlineCode",{parentName:"li"},"T1: Add<T2>")),(0,r.yg)("li",{parentName:"ul"},"La ",(0,r.yg)("inlineCode",{parentName:"li"},"Diff<T1,T2>")," trebuie ca ",(0,r.yg)("inlineCode",{parentName:"li"},"T1: Sub<T2>"),"\nsi asa mai departe...")),(0,r.yg)("p",null,"Daca vreau sa implementez un adder generic, stim ca\noutputul mereu va da cu 1 bit mai mult decat inputurile, spre exemplu"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"#[kernel]\nfn adder_param<T:BitWidth>(_cr:ClockReset, i:(Bits<T>,Bits<T>)) -> Add1<T>\nwhere\n    T: Add<U1>,\n    Add1<T>: BitWidth; // Nu are cum sa isi dea seama rustc ca se implementeaza BitWidth automat pentru orice caz posibil folosit ulterior de aceasta functie, trebuie noi sa ii explicam manual ca este asa\n")),(0,r.yg)("p",null,"In prelude la rhdl, avem toate aceste tipuri auxiliare, mai putin ",(0,r.yg)("inlineCode",{parentName:"p"},"Diff"),", acesta trebuie sa il importam in mod special din rhdl_typenum"),(0,r.yg)("h3",{id:"macro-ul-op"},"Macro-ul op!()"),(0,r.yg)("p",null,"exista posibilitatea sa se foloseasca macro-ul ",(0,r.yg)("inlineCode",{parentName:"p"},"op!()"),", care mapeaza spre exemplu ",(0,r.yg)("inlineCode",{parentName:"p"},"op!(U5+U3)")," in ",(0,r.yg)("inlineCode",{parentName:"p"},"Sum<U5,U3>")," sau ",(0,r.yg)("inlineCode",{parentName:"p"},"op!(U5-U3)")," in `",(0,r.yg)("inlineCode",{parentName:"p"},"Diff<U5,U3>"),". Desi acest macro pare ca ne face viata mai usoara,\ndin pacate tot trebuie sa stim ce se intampla in spate pentru a ii da compilatorului hinturi despre trait implementation se fac."),(0,r.yg)("h2",{id:"crate-ul-bitops_rhdl"},"Crate-ul bitops_rhdl"),(0,r.yg)("admonition",{type:"warning"},(0,r.yg)("p",{parentName:"admonition"},"Acest crate e inca work in progress, orice vi se pare ca ar fi trebuit sa mearga si\nnu merge, anuntati asistentul de laborator sau faceti un issue pe ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/cs-pub-ro/computer-architecture"},"Github"))),(0,r.yg)("p",null,"Este un crate auxiliar creat pentru a emula 2 operatii din verilog cu o sintaxa comoda, acelea fiind bit selection si bit packing"),(0,r.yg)("h3",{id:"motivatie"},"Motivatie"),(0,r.yg)("p",null,"Daca ati explorat un pic, ati observat probabil ca nu exista vreo cale comoda de a indexa un bit sau o sectiune de biti anume din structura Bits, analog pentru a le concatena."),(0,r.yg)("h3",{id:"usage"},"Usage"),(0,r.yg)("p",null,"deasupra fiecarei functie kernel la care vrei sa folosesti helperele, pune"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"#[bitops] // Mereu se pune aceasta prima\n#[kernel]\nfn my_ker(...) -> ...\n")),(0,r.yg)("h3",{id:"indexing"},"Indexing"),(0,r.yg)("p",null,"Se poate folosi in felul acesta sintaxa de a indexa un bit, sau un slice de biti:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"#[bitops] // Mereu se pune aceasta prima\n#[kernel]\nfn my_ker(_cr: ClockReset, i: Bits<U8>) -> ... {\n    ...\n    let u = i[3..0]; // Ultimii 4 biti, va da un Bits<U4>\n    let u2 = i[3]; // Al 4lea bit\n    let u3 = i[0..3]; // Nepermis, in i[a..b] va trebui ca a >= b\n}\n")),(0,r.yg)("h3",{id:"packing"},"Packing"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},"#[bitops] // Mereu se pune aceasta prima\n#[kernel]\nfn my_ker(_cr: ClockReset, i: (Bits<U8>,Bits<U8>)) -> ... {\n    ...\n    // Orice tuplu care are numai indexari in el poate fi folosit\n    let u = (i.0[7], i.0[1..0], i.1[7..0]);  // u va fi Bits<U11>, si va avea ca MSB = MSB-ul lui i.0\n    let u = (i.0[7], i.0); // Nu are doar indexari, deci va fi pastrat ca atare\n}\n")))}s.isMDXComponent=!0},5680:(e,a,i)=>{i.d(a,{xA:()=>p,yg:()=>g});var t=i(6540);function r(e,a,i){return a in e?Object.defineProperty(e,a,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[a]=i,e}function n(e,a){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),i.push.apply(i,t)}return i}function l(e){for(var a=1;a<arguments.length;a++){var i=null!=arguments[a]?arguments[a]:{};a%2?n(Object(i),!0).forEach(function(a){r(e,a,i[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):n(Object(i)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(i,a))})}return e}function u(e,a){if(null==e)return{};var i,t,r=function(e,a){if(null==e)return{};var i,t,r={},n=Object.keys(e);for(t=0;t<n.length;t++)i=n[t],a.indexOf(i)>=0||(r[i]=e[i]);return r}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(t=0;t<n.length;t++)i=n[t],a.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var o=t.createContext({}),c=function(e){var a=t.useContext(o),i=a;return e&&(i="function"==typeof e?e(a):l(l({},a),e)),i},p=function(e){var a=c(e.components);return t.createElement(o.Provider,{value:a},e.children)},m="mdxType",s={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},d=t.forwardRef(function(e,a){var i=e.components,r=e.mdxType,n=e.originalType,o=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),m=c(i),d=r,g=m["".concat(o,".").concat(d)]||m[d]||s[d]||n;return i?t.createElement(g,l(l({ref:a},p),{},{components:i})):t.createElement(g,l({ref:a},p))});function g(e,a){var i=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var n=i.length,l=new Array(n);l[0]=d;var u={};for(var o in a)hasOwnProperty.call(a,o)&&(u[o]=a[o]);u.originalType=e,u[m]="string"==typeof e?e:r,l[1]=u;for(var c=2;c<n;c++)l[c]=i[c];return t.createElement.apply(null,l)}return t.createElement.apply(null,i)}d.displayName="MDXCreateElement"}}]);