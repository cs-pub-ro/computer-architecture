"use strict";(globalThis.webpackChunkcomputer_architecture=globalThis.webpackChunkcomputer_architecture||[]).push([[492],{3418:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>c,contentTitle:()=>u,default:()=>m,frontMatter:()=>n,metadata:()=>l,toc:()=>s});var i=r(8168),t=(r(6540),r(5680));const n={},u="Arhitectura Calculatorului Didactic",l={unversionedId:"Laboratoare/9 Calculator Didactic/Arhitectura/Teorie/README",id:"Laboratoare/9 Calculator Didactic/Arhitectura/Teorie/README",title:"Arhitectura Calculatorului Didactic",description:"Caracteristici ale calculatorului didactic",source:"@site/docs/Laboratoare/9 Calculator Didactic/Arhitectura/Teorie/README.md",sourceDirName:"Laboratoare/9 Calculator Didactic/Arhitectura/Teorie",slug:"/Laboratoare/9 Calculator Didactic/Arhitectura/Teorie/",permalink:"/computer-architecture/Laboratoare/9 Calculator Didactic/Arhitectura/Teorie/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Arhitectura",permalink:"/computer-architecture/Laboratoare/9 Calculator Didactic/Arhitectura/"},next:{title:"10 Calculator Didactic",permalink:"/computer-architecture/Laboratoare/10 Calculator Didactic/"}},c={},s=[{value:"Caracteristici ale calculatorului didactic",id:"caracteristici-ale-calculatorului-didactic",level:2},{value:"Resursele calculatorului didactic",id:"resursele-calculatorului-didactic",level:2},{value:"Magistrala MAG",id:"magistrala-mag",level:3},{value:"Registrele Generale RG",id:"registrele-generale-rg",level:3},{value:"Unitatea aritmetic\u0103 logic\u0103 UAL",id:"unitatea-aritmetic\u0103-logic\u0103-ual",level:3},{value:"Memoria M",id:"memoria-m",level:3},{value:"Registrul AM",id:"registrul-am",level:3},{value:"Registrul Contor Program CP",id:"registrul-contor-program-cp",level:3},{value:"Registrul de instruc\u021biuni RI",id:"registrul-de-instruc\u021biuni-ri",level:3},{value:"Indicatorii de condi\u021bii IND",id:"indicatorii-de-condi\u021bii-ind",level:3},{value:"Registrele temporare T1,T2",id:"registrele-temporare-t1t2",level:3},{value:"Subsistemul de Intr\u0103ri/Ie\u0219iri",id:"subsistemul-de-intr\u0103riie\u0219iri",level:3},{value:"Registrul de adrese de intrare/ie\u0219ire AIE",id:"registrul-de-adrese-de-intrareie\u0219ire-aie",level:3},{value:"Unitatea de comand\u0103",id:"unitatea-de-comand\u0103",level:3}],o={toc:s},p="wrapper";function m({components:e,...a}){return(0,t.yg)(p,(0,i.A)({},o,a,{components:e,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"arhitectura-calculatorului-didactic"},"Arhitectura Calculatorului Didactic"),(0,t.yg)("h2",{id:"caracteristici-ale-calculatorului-didactic"},"Caracteristici ale calculatorului didactic"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"Arhitectura bazat\u0103 pe Registre Generale"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Calculatorul dispune de 8 Registre Generale"))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"Arhitectura pe 16 bi\u0163i:"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Registrele generale au dimensiunea de 16 bi\u0163i"),(0,t.yg)("li",{parentName:"ul"},"Unitatea aritmetico-logic\u0103 (UAL) prelucreaz\u0103 operanzi pe 16 bi\u0163i"),(0,t.yg)("li",{parentName:"ul"},"Magistrala procesorului (MAG) este pe 16 bi\u0163i"),(0,t.yg)("li",{parentName:"ul"},"Spa\u0163iul de adresare este de ",(0,t.yg)("span",{parentName:"li",className:"math math-inline"},(0,t.yg)("span",{parentName:"span",className:"katex"},(0,t.yg)("span",{parentName:"span",className:"katex-mathml"},(0,t.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,t.yg)("semantics",{parentName:"math"},(0,t.yg)("mrow",{parentName:"semantics"},(0,t.yg)("msup",{parentName:"mrow"},(0,t.yg)("mn",{parentName:"msup"},"2"),(0,t.yg)("mn",{parentName:"msup"},"16"))),(0,t.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"2^{16}")))),(0,t.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,t.yg)("span",{parentName:"span",className:"base"},(0,t.yg)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,t.yg)("span",{parentName:"span",className:"mord"},(0,t.yg)("span",{parentName:"span",className:"mord"},"2"),(0,t.yg)("span",{parentName:"span",className:"msupsub"},(0,t.yg)("span",{parentName:"span",className:"vlist-t"},(0,t.yg)("span",{parentName:"span",className:"vlist-r"},(0,t.yg)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,t.yg)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,t.yg)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,t.yg)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,t.yg)("span",{parentName:"span",className:"mord mtight"},(0,t.yg)("span",{parentName:"span",className:"mord mtight"},"16")))))))))))))," Cuvinte, adic\u0103 64 Kcuvinte"))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"UAL pentru \xeentregi reprezenta\u0163i \xeen cod complementar"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Procesorul dispune de o singur\u0103 unitate aritmetic\u0103-logic\u0103 ce opereaz\u0103 cu \xeentregi cu semn pe 16 bi\u0163i"))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("p",{parentName:"li"},"Moduri de adresare complexe"),(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Setul de instruc\u0163iuni \u015fi modurile de adresare deriv\u0103 din arhitectura x86"),(0,t.yg)("li",{parentName:"ul"},"Modurile de adresare sunt specifice procesoarelor CISC",(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},"Lucrul cu operanzi din memorie, f\u0103r\u0103 \xeenc\u0103rcare prealabil\u0103 \xeen registrele generale"),(0,t.yg)("li",{parentName:"ul"},"Modurile de adresare sunt numeroase \u015fi foarte flexibile")))))),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Arhitectura setului de instruc\u0163iuni (ISA - Instruction Set Architecture)")," este folosit\u0103 pentru a abstractiza func\u0163ionarea intern\u0103 a unui procesor. ISA define\u015fte \u201cpersonalitatea\u201d unui procesor: cum func\u0163ioneaz\u0103 procesorul d.p.d.v. al programatorului, ce fel de instruc\u0163iuni execut\u0103, care este semantica acestora. ISA este cea mai important\u0103 parte a design-ului unui procesor; alte aspecte cum sunt componentele de calcul \u0219i stocare, interac\u0163iunea cu memoriile, pipeline-ul, fluxul de date \xeen procesor put\xe2nd fi schimbate de la o versiune la alta a procesorului.\nLa ora actual\u0103 exist\u0103 dou\u0103 filozofii de design pentru un procesor: ",(0,t.yg)("em",{parentName:"p"},"Complex Instruction Set Computer (CISC)")," \u015fi ",(0,t.yg)("em",{parentName:"p"},"Reduced Instruction Set Computer (RISC)"),". \xcen afar\u0103 de acestea exist\u0103 \u015fi ISA-uri pentru procesoare specializate, cum sunt GPU-urile pentru pl\u0103ci grafice si DSP-urile pentru procesare de semnal."),(0,t.yg)("p",null,"Principalele categorii de instruc\u021biuni sunt cele aritmetico-logice, de control secven\u021bial, \u0219i respectiv de acces la memorie. Formatul instruc\u021biunilor RISC are o lungime fix\u0103, cu lungimea unei instruc\u021biuni \xeen general egal\u0103 cu lungimea cuvantului de memorie; \xeen cazul CISC, lungimea unei instruc\u021biuni variaz\u0103 \xeen func\u021bie de formatul instruc\u021biunii. RISC are un num\u0103r mic de moduri de adresare, spre deosebire de CISC, care are un num\u0103r mare de moduri de adresare (dar care nu sunt totdeauna utilizate)."),(0,t.yg)("p",null,"Setul de instruc\u021biuni RISC este orientat pe registre (peste 32 de registre). Pentru c\u0103 accesul la memorie e mult mai lent dec\xe2t lucrul cu registrele, RISC \xeencurajeaz\u0103 lucrul cu ace\u0219tia. Face acest lucru prin cre\u0219terea num\u0103rului de registre\u0219i prin limitarea explicit\u0103 a acceselor la memorie. \xcen general instruc\u021biunile au 2 operanzi (registre) \u0219i un registru destina\u021bie. Ca principiu, arhitectura RISC are mai multe registre generale, \xeen timp ce CISC are mai mul\u021bi speciali. Practic toate procesoarele moderne \xeemprumut\u0103 at\xe2t caracteristici CISC, c\xe2t \u0219i RISC. "),(0,t.yg)("p",null,"\xcen cadrul arhitecturilor RISC exist\u0103 o limitare explicit\u0103, \u0219i anume: singurul mod de acces la memorie este prin ",(0,t.yg)("em",{parentName:"p"},"load")," \u0219i ",(0,t.yg)("em",{parentName:"p"},"store"),". Aceasta se deosebe\u0219te fundamental de CISC care are instruc\u021biuni cu operanzi loca\u021bii de memorie. Totu\u0219i, de\u0219i RISC impune aceast\u0103 disciplin\u0103 de lucru cu memoria, doar 20-25% din codul unui program e reprezentat de loads & stores. "),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Observa\u0163ii")),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Procesorul didactic este consistent din punctul de vedere al dimensiunii: 16 bi\u0163i"),". Procesoarele reale, \xeen marea lor majoritate, nu respect\u0103 aceasta regul\u0103. Spre exemplu, Pentium 4 cu arhitectura pe 32 de bi\u0163i (IA-32) include registre pe 128 de bi\u0163i \u015fi dispune de o magistral\u0103 de adrese pe 36 de bi\u0163i (spa\u0163iul total de adresare este de 64 TB). \xcen consecin\u0163\u0103 p\u0103rerile sunt imp\u0103r\u0163ite \xeen leg\u0103tur\u0103 cu care ar fi o defini\u0163ie corect\u0103 pentru dimensiunea procesorului. Cea mai frecvent\u0103 defini\u0163ie spune c\u0103 dimensiunea unui procesor este dat\u0103 de dimensiunea registrelor \u015fi a unit\u0103\u0163ilor aritmetico-logice."),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Spa\u0163iul de adresare pentru un procesor pe N bi\u0163i este de 2",(0,t.yg)("sup",null,"N")," loca\u0163ii de memorie"),". \xcen func\u0163ie de organizarea acesteia \xeens\u0103, aceste loca\u0163ii pot fi octe\u0163i sau cuvinte de mai multi octe\u0163i. Memoria calculatorului didactic este organizat\u0103 ca un ",(0,t.yg)("strong",{parentName:"li"},"spa\u0163iu contiguu de 64 Kcuvinte de 16 bi\u0163i fiecare"),". A\u015fadar spa\u0163iul total de adresare  pentru calculatorul didactic este de 128 Kbytes. Memoria din calculatoarele voastre \xeens\u0103 este adresabil\u0103 la nivel de octet. Dac\u0103 calculatorul didactic ar fi fost echipat cu o astfel de memorie, spa\u0163iul de adresare ar fi fost de 64 KB, deoarece la fiecare loca\u0163ie se poate stoca fix un byte."),(0,t.yg)("li",{parentName:"ul"},"Prin faptul ca procesorul permite lucrul cu operanzi direct din memorie se \xeen\u0163elege c\u0103 ei nu trebuie adu\u015fi \xeen prealabil de c\u0103tre programator \xeentr-un registru general. Cu toate acestea ",(0,t.yg)("strong",{parentName:"li"},"nu se poate lucra cu ambii operanzi direct din memorie"),". Acest tip de procesare specific arhitecturilor CISC poart\u0103 numele de procesare Registru-Memorie. Spre deosebire de aceasta, arhitecturile RISC tipice necesit\u0103 \xeenc\u0103rcarea prealabil\u0103 a operanzilor \xeen registrele generale. De aceea, aceste procesoare se mai numesc Registru-Registru sau Load/Store. Arhitecturile Memorie-Memorie sunt foarte rare, datorit\u0103 complexit\u0103\u0163ii hardware-ului \u015fi performan\u0163elor sc\u0103zute.")),(0,t.yg)("h2",{id:"resursele-calculatorului-didactic"},"Resursele calculatorului didactic"),(0,t.yg)("p",null,(0,t.yg)("img",{alt:"Arhitectura calculatorului didactic",src:r(3446).A,width:"766",height:"826"})),(0,t.yg)("p",null,(0,t.yg)("em",{parentName:"p"},"Figure: Arhitectura calculatorului didactic")),(0,t.yg)("h3",{id:"magistrala-mag"},"Magistrala MAG"),(0,t.yg)("p",null,"Interconectarea tuturor resurselor se realizeaz\u0103 prin intermediul unei magistrale, MAG, care constituie suportul fizic de comunica\u021bie \xeentre aceste resurse. Dimensiunea magistralei este de 16 linii. Deoarece magistrala este \xeen totalitate pasiv\u0103 (este un set de conductori), ",(0,t.yg)("strong",{parentName:"p"},"un singur cuv\xe2nt de informa\u021bie poate exista pe magistral\u0103 la un moment dat"),"."),(0,t.yg)("h3",{id:"registrele-generale-rg"},"Registrele Generale RG"),(0,t.yg)("p",null,"Deoarece timpul de acces la memoria M este relativ mare (de ordinul zecilor de nanosecunde) procesorul dispune de 8 registre generale de c\xe2te 16 bi\u021bi, fiecare ce lucreaz\u0103 la frecven\u021ba de ceas a procesorului. \xcen tabelul de mai jos sunt sumarizate func\u021biile acestora:"),(0,t.yg)("table",null,(0,t.yg)("thead",{parentName:"table"},(0,t.yg)("tr",{parentName:"thead"},(0,t.yg)("th",{parentName:"tr",align:null},"Registrul"),(0,t.yg)("th",{parentName:"tr",align:null},"Func\u021bia"))),(0,t.yg)("tbody",{parentName:"table"},(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"RA, RB, RC"),(0,t.yg)("td",{parentName:"tr",align:null},"La dispozi\u021bia programatorului pentru stocarea operanzilor. RA este folosit \xeen lucrul cu porturile.")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"IS"),(0,t.yg)("td",{parentName:"tr",align:null},"Indicatorul de stiv\u0103.")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"XA, XB"),(0,t.yg)("td",{parentName:"tr",align:null},"Se pot folosi pentru stocarea operanzilor. Sunt folosi\u021bi pentru adresarea memoriei ca \u0219i registre index.")),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},"BA, BB"),(0,t.yg)("td",{parentName:"tr",align:null},"Se pot folosi pentru stocarea operanzilor. Sunt folosi\u021bi pentru adresarea memoriei ca \u0219i registre de baz\u0103.")))),(0,t.yg)("h3",{id:"unitatea-aritmetic\u0103-logic\u0103-ual"},"Unitatea aritmetic\u0103 logic\u0103 UAL"),(0,t.yg)("p",null,"Unitatea aritmetic\u0103 logic\u0103 (UAL) realizeaz\u0103 opera\u021biile aritmetice \u0219i logice ale calculatorului didactic. Ea este utilizat\u0103 pentru prelucrarea datelor \u0219i pentru calculul adresei efective. Unitatea aritmetic\u0103 logic\u0103 prelucreaz\u0103 operanzi pe 16 bi\u021bi reprezenta\u021bi \xeen cod complementar. Caracteristicile rezultatului (zero, par, transport \u0219i dep\u0103\u0219ire) sunt depuse \xeentr-un registru de indicatori IND, \xeen urma execu\u021biei oric\u0103rei instruc\u021biuni aritmetice-logice."),(0,t.yg)("h3",{id:"memoria-m"},"Memoria M"),(0,t.yg)("p",null,"Memoria este utilizat\u0103 pentru a p\u0103stra informa\u021bii reprezent\xe2nd date sau instruc\u021biuni. Memoria M este o matrice de elemente de memorare organizat\u0103 \xeentr-un spa\u021biu de adresare unic de 65536 cuvinte a c\xe2te 16 bi\u021bi fiecare. Astfel, capacitatea memoriei este de 64Kcuvinte x 2 octeti = 128 KB."),(0,t.yg)("h3",{id:"registrul-am"},"Registrul AM"),(0,t.yg)("p",null,"Registrul de adresare a memoriei, AM, p\u0103streaz\u0103 adresa celulei de memorie la care se face acces la un moment dat. C\xe2nd se dore\u0219te realizarea unei opera\u021bii de citire din memorie, adresa solicitat\u0103 va fi depus\u0103 \xeen acest registru, iar unitatea de comand\u0103 va lansa comanda \xabMemory Read\xbb. Dup\u0103 un anumit timp, memoria va furniza pe magistral\u0103 cuvantul de la adresa solicitat\u0103. Analog, c\xe2nd se dore\u0219te s\u0103 se scrie la o anumit\u0103 adres\u0103 din memorie un cuvant, aceasta este depus\u0103 \xeen registrul AM, datele de scris sunt activate pe magistral\u0103, iar unitatea de comand\u0103 va lansa comanda \xabMemory Write\xbb."),(0,t.yg)("h3",{id:"registrul-contor-program-cp"},"Registrul Contor Program CP"),(0,t.yg)("p",null,"Registrul contor program CP este utilizat pentru p\u0103strarea adresei instruc\u021biunii ce urmeaz\u0103 s\u0103 se execute dup\u0103 terminarea execu\u021biei instruc\u021biunii curente. Registrul CP va fi ini\u021bializat cu o valoare dat\u0103 la pornirea sau resetarea sistemului. Dup\u0103 \xeenc\u0103rcarea fiecarei instruc\u021biuni, el se va incrementa pentru a marca avansul la urm\u0103toarea instruc\u021biune. \xcen cazul \xeen care instruc\u021biunea executat\u0103 este una de salt, adresa de salt va fi \xeenc\u0103rcata \xeen CP \xeen urma execu\u021biei instruc\u021biunii."),(0,t.yg)("h3",{id:"registrul-de-instruc\u021biuni-ri"},"Registrul de instruc\u021biuni RI"),(0,t.yg)("p",null,"Registrul de instruc\u021biuni RI p\u0103streaz\u0103 instruc\u021biunea \xeen curs de execu\u021bie. Con\u021binutul s\u0103u este folosit de unitatea de comand\u0103 \xeen vederea gener\u0103rii semnalelor de comand\u0103 pentru toate resursele."),(0,t.yg)("p",null,"Prin activarea ie\u0219irii lui RI, cu ri_oe, doar deplasamentul este pus pe magistral\u0103 pentru a putea fi folosit \xeen calcule (bi\u021bii 8:15 sunt inversa\u021bi \u0219i extin\u0219i la 16 bi\u021bi prin multiplicarea bitului de semn pentru calculul adresei \xeen instruc\u021biunile de salt condi\u021bionat)."),(0,t.yg)("h3",{id:"indicatorii-de-condi\u021bii-ind"},"Indicatorii de condi\u021bii IND"),(0,t.yg)("p",null,"Registrul de indicatori constituie o grupare a unor flag-uri provenite din rezultatele instruc\u021biunilor de tip aritmetico-logic. Registrul IND permite unei instruc\u021biuni s\u0103 foloseasc\u0103 informa\u021bii rezultate \xeen urma execu\u021biei unei instruc\u021biuni anterioare."),(0,t.yg)("p",null,"Spre exemplu, dac\u0103 se dore\u0219te efectuarea unei sume cu operanzi pe 32 de bi\u021bi, din moment ce dimensiunea procesorului este 16 bi\u021bi, este nevoie s\u0103 se prelucreze pe r\xe2nd octe\u021bii inferiori, apoi octe\u021bii superiori. Cei doi operanzi vor ocupa dou\u0103 adrese consecutive de memorie, fie ele 0xA16, 0xA17 pentru primul, respectiv 0xA18, 0xA19 pentru cel de-al doilea. Suma va fi depus\u0103 la adresele 0xA20, 0xA21. "),(0,t.yg)("p",null,"Iat\u0103 programul \xeen assembler pentru situa\u021bia prezentat\u0103 anterior:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-asm"},"MOV RA, [0xA16]\nMOV RB, [0xA18]\nADD RA, RB\nMOV [0xA20],RA\nMOV RA, [0xA17]\nMOV RB, [0xA19]\nADC RA, RB\nMOV [0xA21],RA\n")),(0,t.yg)("p",null,"Dup\u0103 cum se poate observa, cea de-a doua opera\u021bie aritmetic\u0103 este ADC, adic\u0103 adunare cu transport (carry). Semnifica\u021bia este urm\u0103toarea: dac\u0103 de la opera\u021bia anterioar\u0103 de adunare a ap\u0103rut transport, acest transport va trebui propagat \xeen octe\u021bii superiori. Astfel, opera\u021bia ADD, \xeen cazul \xeen care a ap\u0103rut transport, seteaz\u0103 bitul T din registrul IND. Opera\u021bia ADC realizeaz\u0103 suma \xeentre operanzi, dar include \xeen calcul \u0219i acest bit de transport. "),(0,t.yg)("p",null,"Un alt exemplu este saltul condi\u021bionat. O instruc\u021biune de tip \xabif (a==2)\xbb se va implementa astfel:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-asm"},"CMP RA,2\nJNE etichet\u0103\n")),(0,t.yg)("p",null,"Prima instruc\u021biune are ca efect sc\u0103derea con\u021binutului registrului RA cu 2. Rezultatul acestei opera\u021bii nu se stocheaz\u0103, \xeens\u0103, ca orice opera\u021bie aritmetico-logic\u0103, ",(0,t.yg)("strong",{parentName:"p"},"va afecta registrul de indicatori"),". Astfel, dac\u0103 rezultatul a fost zero (continutul lui RA a fost 2), se va seta flagul Z (zero) din registrul IND. Urm\u0103toarea instruc\u021biune, JNE (jump if not equal) ",(0,t.yg)("strong",{parentName:"p"},"va testa acest flag")," \u0219i \xeen functie de valoarea sa va realiza sau nu saltul."),(0,t.yg)("h3",{id:"registrele-temporare-t1t2"},"Registrele temporare T1,T2"),(0,t.yg)("p",null,"Registrele temporare T1 \u0219i T2 sunt utilizate pentru a p\u0103stra operanzii unei opera\u021bii executate \xeen unitatea aritmetic\u0103 logic\u0103, precum \u0219i rezultate intermediare la calcularea adresei efective. Ele nu sunt accesibile \xeen mod explicit programatorului."),(0,t.yg)("p",null,"Pentru a explica necesitatea existen\u021bei acestor registre, s\u0103 consideram c\u0103 ele nu ar fi existat. \xcen acest caz, am fi ob\u021binut urm\u0103toarea schem\u0103:"),(0,t.yg)("p",null,(0,t.yg)("img",{alt:"UAL f\u0103r\u0103 registre temporare",src:r(4277).A,width:"851",height:"385"})),(0,t.yg)("p",null,(0,t.yg)("em",{parentName:"p"},"Figure: UAL f\u0103r\u0103 registre temporare")),(0,t.yg)("p",null,"\xcen acest caz, ambii operanzi precum \u0219i rezultatul opera\u021biei ar trebui s\u0103 se g\u0103seasc\u0103 simultan pe magistral\u0103, ceea ce este imposibil."),(0,t.yg)("h3",{id:"subsistemul-de-intr\u0103riie\u0219iri"},"Subsistemul de Intr\u0103ri/Ie\u0219iri"),(0,t.yg)("p",null,"Subsistemul de intr\u0103ri \u0219i ie\u0219iri permite procesorului comunica\u021bia cu mediul extern prin intermediul dispozitivelor periferice. Subsistemul este format din interfe\u021be (spre exemplu interfa\u021bele serial\u0103, paralel\u0103, IDE, USB, etc.) capabile s\u0103 comunice cu dispozitivele periferice \xeen conformitate cu un standard. Aceste interfe\u021be includ un set de registre (de date/st\u0103ri/comenzi) pentru comunica\u021bia cu procesorul. De exemplu, c\xe2nd procesorul dore\u0219te s\u0103 transmit\u0103 un cuv\xe2nt de date prin interfa\u021ba USB, el va depune \xeen registrul de date asociat interfe\u021bei USB cuv\xe2ntul respectiv, apoi va scrie \xeen registrul de comenzi comanda de transmisie. Fiecare astfel de registru este identificat printr-o adres\u0103 unic\u0103 \xeen sistem \u0219i poart\u0103 numele de port de intrare/ie\u0219ire. A\u0219adar, totalitatea registrelor asociate interfe\u021belor din sistem (porturilor) este echivalent\u0103 cu o memorie \xeen care fiecare adres\u0103 este asociat\u0103 unei interfe\u021be."),(0,t.yg)("h3",{id:"registrul-de-adrese-de-intrareie\u0219ire-aie"},"Registrul de adrese de intrare/ie\u0219ire AIE"),(0,t.yg)("p",null,"\xcentruc\xe2t subsistemul de intr\u0103ri/ie\u0219iri apare procesorului ca o memorie \xeen care fiecare loca\u021bie reprezint\u0103 un port asociat unei interfe\u021be, ca \u0219i \xeen cazul memoriei este nevoie de un registru de adrese. Acesta va fi folosit pentru a stoca adresa portului cu care se dore\u0219te s\u0103 se comunice. Spre exemplu, atunci c\xe2nd procesorul vrea s\u0103 transmit\u0103 ceva pe interfa\u021ba paralel\u0103, el va depune \xeen registrul AIE valoarea 0x378 (ce identific\u0103 portul asociat interfe\u021bei paralele), va activa pe magistral\u0103 cuvantul de date ce se dore\u0219te a fi transmis, iar unitatea de comand\u0103 va lansa semnalul \xabI/O Write\xbb ce va determina \xeenc\u0103rcarea cuv\xe2ntului \xeen registrul interfe\u021bei paralele."),(0,t.yg)("h3",{id:"unitatea-de-comand\u0103"},"Unitatea de comand\u0103"),(0,t.yg)("p",null,"Toate resursele prezentate p\xe2n\u0103 \xeen acest punct formeaz\u0103 unitatea de execu\u021bie. Unitatea de comand\u0103 dirijeaz\u0103 aceste resurse pentru a executa o instruc\u021biune sau o alta. Spre exemplu, \xeen cazul instruc\u021biunii ADD RA, RB unitatea de comand\u0103 va genera urmatoarea secven\u021b\u0103 de semnale:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Semnal c\u0103tre blocul de registre generale pentru a determina activarea con\u021binutului lui RA pe magistral\u0103."),(0,t.yg)("li",{parentName:"ul"},"Semnal c\u0103tre T1 pentru a \xeenc\u0103rca valoarea aflata \xeen acest moment pe magistral\u0103."),(0,t.yg)("li",{parentName:"ul"},"Semnal c\u0103tre blocul de registre generale pentru a determina activarea con\u021binutului lui RB pe magistral\u0103."),(0,t.yg)("li",{parentName:"ul"},"Semnal c\u0103tre T2 pentru a \xeenc\u0103rca valoarea aflat\u0103 \xeen acest moment pe magistral\u0103."),(0,t.yg)("li",{parentName:"ul"},"Semnal c\u0103tre UAL ce indic\u0103 opera\u021bia de adunare."),(0,t.yg)("li",{parentName:"ul"},"Semnal c\u0103tre IND pentru a seta flag-urile Z, S, D, T, P."),(0,t.yg)("li",{parentName:"ul"},"Semnal c\u0103tre blocul de registre generale pentru a \xeenc\u0103rca \xeen RA valoarea de pe magistral\u0103.")),(0,t.yg)("p",null,"Cu alte cuvinte, unitatea de comand\u0103 este cea care controleaz\u0103 func\u021bionarea procesorului. Ea dirijeaz\u0103 \xeentreg procesul de citire-interpretare-execu\u021bie a instruc\u021biunilor."))}m.isMDXComponent=!0},3446:(e,a,r)=>{r.d(a,{A:()=>i});const i=r.p+"assets/images/arhitectura_calculatorului_didactic-a09534ce9f1256adac4597cf366ee6a6.png"},4277:(e,a,r)=>{r.d(a,{A:()=>i});const i=r.p+"assets/images/ual_fara_registre_temporare-1800ebe9312db2eb192c38c2f3bbb2ec.png"},5680:(e,a,r)=>{r.d(a,{xA:()=>o,yg:()=>g});var i=r(6540);function t(e,a,r){return a in e?Object.defineProperty(e,a,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[a]=r,e}function n(e,a){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);a&&(i=i.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),r.push.apply(r,i)}return r}function u(e){for(var a=1;a<arguments.length;a++){var r=null!=arguments[a]?arguments[a]:{};a%2?n(Object(r),!0).forEach(function(a){t(e,a,r[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(r,a))})}return e}function l(e,a){if(null==e)return{};var r,i,t=function(e,a){if(null==e)return{};var r,i,t={},n=Object.keys(e);for(i=0;i<n.length;i++)r=n[i],a.indexOf(r)>=0||(t[r]=e[r]);return t}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)r=n[i],a.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var c=i.createContext({}),s=function(e){var a=i.useContext(c),r=a;return e&&(r="function"==typeof e?e(a):u(u({},a),e)),r},o=function(e){var a=s(e.components);return i.createElement(c.Provider,{value:a},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return i.createElement(i.Fragment,{},a)}},d=i.forwardRef(function(e,a){var r=e.components,t=e.mdxType,n=e.originalType,c=e.parentName,o=l(e,["components","mdxType","originalType","parentName"]),p=s(r),d=t,g=p["".concat(c,".").concat(d)]||p[d]||m[d]||n;return r?i.createElement(g,u(u({ref:a},o),{},{components:r})):i.createElement(g,u({ref:a},o))});function g(e,a){var r=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var n=r.length,u=new Array(n);u[0]=d;var l={};for(var c in a)hasOwnProperty.call(a,c)&&(l[c]=a[c]);l.originalType=e,l[p]="string"==typeof e?e:t,u[1]=l;for(var s=2;s<n;s++)u[s]=r[s];return i.createElement.apply(null,u)}return i.createElement.apply(null,r)}d.displayName="MDXCreateElement"}}]);