"use strict";(globalThis.webpackChunkcomputer_architecture=globalThis.webpackChunkcomputer_architecture||[]).push([[9509],{3628:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>c,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=r(8168),n=(r(6540),r(5680));const i={},c="Debouncer",o={unversionedId:"Laboratoare AA AC/4 Verilog Secven\u021bial/Debouncer/Teorie/README",id:"Laboratoare AA AC/4 Verilog Secven\u021bial/Debouncer/Teorie/README",title:"Debouncer",description:"Elementele de memorare (stare) ale circuitului se modeleaz\u0103 printr-un bloc activ pe frontului semnalului de ceas. \xcen blocul combina\u021bional trebuie tratate toate st\u0103rile posibile ale automatului, semnalele de ie\u0219ire \u0219i tranzi\u021biile din aceste st\u0103ri.",source:"@site/docs/Laboratoare AA AC/4 Verilog Secven\u021bial/Debouncer/Teorie/README.md",sourceDirName:"Laboratoare AA AC/4 Verilog Secven\u021bial/Debouncer/Teorie",slug:"/Laboratoare AA AC/4 Verilog Secven\u021bial/Debouncer/Teorie/",permalink:"/computer-architecture/Laboratoare AA AC/4 Verilog Secven\u021bial/Debouncer/Teorie/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Debouncer",permalink:"/computer-architecture/Laboratoare AA AC/4 Verilog Secven\u021bial/Debouncer/"},next:{title:"5 Verilog Secven\u021bial",permalink:"/computer-architecture/Laboratoare AA AC/5 Verilog Secven\u021bial/"}},u={},l=[{value:"Expresii regulate",id:"expresii-regulate",level:2},{value:"Exemple:",id:"exemple",level:3},{value:"Debouncing",id:"debouncing",level:2}],s={toc:l},p="wrapper";function m({components:e,...t}){return(0,n.yg)(p,(0,a.A)({},s,t,{components:e,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"debouncer"},"Debouncer"),(0,n.yg)("p",null,"Elementele de memorare (stare) ale circuitului se modeleaz\u0103 printr-un bloc activ pe frontului semnalului de ceas. \xcen blocul combina\u021bional trebuie tratate toate st\u0103rile posibile ale automatului, semnalele de ie\u0219ire \u0219i tranzi\u021biile din aceste st\u0103ri."),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-verilog"},"module fsm(output reg out, input in, clk, reset_n);\nreg [2:0] state, next_state;\n\n// partea secven\u021bial\u0103\nalways @(posedge clk) begin\n    if (reset_n == 0) state <= 0;\n    else state <= next_state;\nend\n\n// partea combinationala\nalways @(*) begin\n    out = 0;\n    case (state)\n        0:   if (in == 0) begin \n                 next_state = 1;\n                 out = 1;\n             end\n             else next_state = 2;\n        1:   if (in == 0) begin\n                 next_state = 3;\n                 out = 1;\n             end\n             else next_state = 4;         \n    ...\n    endcase\nend\nendmodule\n")),(0,n.yg)("note",{important:!0},'Nu combina\u021bi blocurile secven\u021biale cu cele combina\u021bionale (e.g. "always @(posedge clk, state, in)") deoarece majoritatea utilitarelor nu vor sintetiza corect un astfel de circuit.'),(0,n.yg)("h2",{id:"expresii-regulate"},"Expresii regulate"),(0,n.yg)("p",null,"Expresiile Regulate sunt secven\u021be de caractere ce definesc un tipar de c\u0103utare, folosite \xeen multe cazuri pentru identificarea \u0219irurilor sau sub-\u0219irurilor de caractere ce se potrivesc cu expresia.\nCea mai simpl\u0103 metod\u0103 de vizualizare a unei expresii regulate este prin intermediul Automatelor Finite de st\u0103ri."),(0,n.yg)("p",null,'Pentru a descrie un tipar care con\u021bine un sub-\u0219ir \xeentre zero \u0219i nelimitate ori, este utilizat cuantificatorul "*", iar pentru a descrie un tipar care con\u021bine un sub-\u0219ir \xeentre una \u0219i nelimitate ori, este utilizat cuantificatorul "+".'),(0,n.yg)("p",null,'Parantezele "(" ")" sunt folosite pentru a delimita grupuri de caractere. Dac\u0103 acestea nu sunt specificate, cuantificatorul va avea efect asupra caracterului anterior.'),(0,n.yg)("h3",{id:"exemple"},"Exemple:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre"},"a(bc)*  -  se va potrivi cu \u0219irurile de caractere 'a', 'abc', 'abcbc', 'abcbcbc' etc.\n(ab)+c  -  se va potrivi cu \u0219irurile de caractere 'abc', 'ababc', 'abababc' etc.\nab+a    -  se va potrivi cu \u0219irurile de caractere 'aba', 'abba', 'abbba' etc.\n")),(0,n.yg)("note",{important:!0},'Nu confunda\u021bi operatorii "*" \u0219i "+" cu \xeenmul\u021bire \u0219i adunare. \xcen contextul expresiilor regulate, ace\u0219tia sunt folosi\u021bi pentru a descrie tipare de c\u0103utare \u0219i **NU** sunt folosi\u021bi pentru a scrie cod Verilog.'),(0,n.yg)("h2",{id:"debouncing"},"Debouncing"),(0,n.yg)("p",null,"Atunci c\xe2nd un buton este ap\u0103sat sau un switch este comutat, dou\u0103 p\u0103r\u021bi metalice intr\u0103 \xeen contact pentru a permite curentului s\u0103 treac\u0103. Cu toate acestea, ele nu se conecteaz\u0103 instantaneu, ci se conecteaz\u0103 \u0219i deconecteaz\u0103 de c\xe2teva ori \xeenainte de realizarea conexiunii propriu-zise. Acela\u0219i lucru se \xeent\xe2mpl\u0103 \u0219i \xeen momentul eliber\u0103rii unui buton (c\xe2nd acesta nu mai este ap\u0103sat). Acest fenomen poate conduce la comut\u0103ri false sau modific\u0103ri multiple nedorite asupra semnalului \u0219i este denumit ",(0,n.yg)("strong",{parentName:"p"},"bouncing"),"."),(0,n.yg)("p",null,'Prin urmare, se poate spune c\u0103 fenomenul de "bouncing" nu este un comportament ideal pentru niciun switch care execut\u0103 mai multe tranzi\u021bii ale unei singure intr\u0103ri. Aceasta nu este o problem\u0103 major\u0103 c\xe2nd avem de-a face cu circuite de putere, dar poate cauza probleme atunci c\xe2nd avem de-a face cu circuitele logice sau digitale. A\u0219adar, pentru a elimina oscila\u021biile din semnal cauzate de acest fenomen se folose\u0219te principiul de ',(0,n.yg)("strong",{parentName:"p"},"Switch Debouncing"),"."))}m.isMDXComponent=!0},5680:(e,t,r)=>{r.d(t,{xA:()=>s,yg:()=>b});var a=r(6540);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,a)}return r}function c(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach(function(t){n(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}function o(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var u=a.createContext({}),l=function(e){var t=a.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):c(c({},t),e)),r},s=function(e){var t=l(e.components);return a.createElement(u.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef(function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,u=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),p=l(r),d=n,b=p["".concat(u,".").concat(d)]||p[d]||m[d]||i;return r?a.createElement(b,c(c({ref:t},s),{},{components:r})):a.createElement(b,c({ref:t},s))});function b(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,c=new Array(i);c[0]=d;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o[p]="string"==typeof e?e:n,c[1]=o;for(var l=2;l<i;l++)c[l]=r[l];return a.createElement.apply(null,c)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"}}]);