"use strict";(self.webpackChunkcomputer_architecture=self.webpackChunkcomputer_architecture||[]).push([[9569],{5680:(e,a,r)=>{r.d(a,{xA:()=>m,yg:()=>f});var t=r(6540);function i(e,a,r){return a in e?Object.defineProperty(e,a,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[a]=r,e}function n(e,a){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),r.push.apply(r,t)}return r}function l(e){for(var a=1;a<arguments.length;a++){var r=null!=arguments[a]?arguments[a]:{};a%2?n(Object(r),!0).forEach((function(a){i(e,a,r[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(r,a))}))}return e}function o(e,a){if(null==e)return{};var r,t,i=function(e,a){if(null==e)return{};var r,t,i={},n=Object.keys(e);for(t=0;t<n.length;t++)r=n[t],a.indexOf(r)>=0||(i[r]=e[r]);return i}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(t=0;t<n.length;t++)r=n[t],a.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var u=t.createContext({}),c=function(e){var a=t.useContext(u),r=a;return e&&(r="function"==typeof e?e(a):l(l({},a),e)),r},m=function(e){var a=c(e.components);return t.createElement(u.Provider,{value:a},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},s=t.forwardRef((function(e,a){var r=e.components,i=e.mdxType,n=e.originalType,u=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=c(r),s=i,f=p["".concat(u,".").concat(s)]||p[s]||d[s]||n;return r?t.createElement(f,l(l({ref:a},m),{},{components:r})):t.createElement(f,l({ref:a},m))}));function f(e,a){var r=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var n=r.length,l=new Array(n);l[0]=s;var o={};for(var u in a)hasOwnProperty.call(a,u)&&(o[u]=a[u]);o.originalType=e,o[p]="string"==typeof e?e:i,l[1]=o;for(var c=2;c<n;c++)l[c]=r[c];return t.createElement.apply(null,l)}return t.createElement.apply(null,r)}s.displayName="MDXCreateElement"},1030:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>u,contentTitle:()=>l,default:()=>d,frontMatter:()=>n,metadata:()=>o,toc:()=>c});var t=r(8168),i=(r(6540),r(5680));const n={},l="Parametrizarea modulelor",o={unversionedId:"Lab2 - Verilog/Parametri/Lectura/README",id:"Lab2 - Verilog/Parametri/Lectura/README",title:"Parametrizarea modulelor",description:"Parameter",source:"@site/docs/Lab2 - Verilog/Parametri/Lectura/README.md",sourceDirName:"Lab2 - Verilog/Parametri/Lectura",slug:"/Lab2 - Verilog/Parametri/Lectura/",permalink:"/computer-architecture/Lab2 - Verilog/Parametri/Lectura/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Parametri",permalink:"/computer-architecture/Lab2 - Verilog/Parametri/"},next:{title:"Practice: Parameters",permalink:"/computer-architecture/Lab2 - Verilog/Parametri/Exercitii/"}},u={},c=[{value:"Parameter",id:"parameter",level:2},{value:"Construirea \u0219i instan\u021bierea modulelor parametrizabile",id:"construirea-\u0219i-instan\u021bierea-modulelor-parametrizabile",level:2},{value:"Macro: `define",id:"macro-define",level:2}],m={toc:c},p="wrapper";function d(e){let{components:a,...r}=e;return(0,i.yg)(p,(0,t.A)({},m,r,{components:a,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"parametrizarea-modulelor"},"Parametrizarea modulelor"),(0,i.yg)("h2",{id:"parameter"},"Parameter"),(0,i.yg)("p",null,"Cuv\xe2ntul rezervat ''parameter'' este o construc\u021bie de limbaj \xeen verilog care permite unui modul s\u0103 fie reutilizat cu specifica\u021bii diferite. Spre exemplu, un sumator poate fi parametrizat s\u0103 accepte o valoare pentru num\u0103rul de bi\u021bi care poate s\u0103 fie configurat\u0103 diferit de la o simulare la alta. Comportamentul lor este similar cu cel al argumentelor unor func\u021bii \xeen alte limbaje de programare cunoscute. Folosind  ''parameter'' este declarat\u0103 o valoare constant\u0103, prin urmare este ilegal\u0103 modificarea valorii acesteia \xeen timpul simul\u0103rii. De asemenea, este ilegal ca un alt tip de dat\u0103 s\u0103 aib\u0103 acela\u0219i nume ca unul dintre parametri."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-verilog"},"parameter MSB = 7;       // MSB este un parametru cu valoarea constant\u0103 7\nparameter [7:0] number = 2\u2019b11;    // o valoare de 2 bi\u021bi este convertit\u0103\n                                   // \xeentr-o valoare de 8 bi\u021bi \n")),(0,i.yg)("p",null,"O variabil\u0103 de tip parametru este vizibil\u0103 local, \xeen modulul ce a fost declarat\u0103."),(0,i.yg)("h2",{id:"construirea-\u0219i-instan\u021bierea-modulelor-parametrizabile"},"Construirea \u0219i instan\u021bierea modulelor parametrizabile"),(0,i.yg)("p",null,"Instan\u021bierea modulelor a fost folosit\u0103 \u0219i \xeen laboratorul anterior pentru a invoca logica implementat\u0103 \xeentr-un alt modul. \xcen acel context, era necesar s\u0103 cunoa\u0219tem dimensiunea semnalelor din interfa\u021b\u0103 pentru a le potrivi cu variabilele conectate la instan\u021b\u0103. \xcen cazul \xeen care un modul are dimensiunile porturilor parametrizate, acesta poate fi instan\u021biat  cu valori particulare ale parametrilor (diferite de cele predefinite). S\u0103 consider\u0103m ca exemplu un modul de mai jos:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-verilog"},"module my_beautiful_module (out, a, b);\n    output [7:0] out;\n    input [3:0] a;\n    input [4:0] b;\n\n    \u2026// some logic\nendmodule\n")),(0,i.yg)("p",null,"Pentru a instan\u021bia acest modul, vom avea nevoie de 3 variabile de 8, 4, respectiv 5 fire pe care le vom conecta astfel:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-verilog"},"My_beautiful_module inst1(out, a, b);\n")),(0,i.yg)("p",null,"Pe de alt\u0103 parte, av\xe2nd modulul:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-verilog"},"module my_beautiful_parameterized_module(out, a, b);\n    parameter a_width = 4;\n    parameter b_width = 5;\n    parameter out_width = 8;\n\n    output [out_width-1:0] out;\n    input [a_width-1:0] a;\n    input [b_width-1:0] b;\n\n    \u2026// some logic\nendmodule\n")),(0,i.yg)("p",null,"\xcei putem utiliza logica f\u0103r\u0103 a depinde de o dimensiune predefinit\u0103 a semnalelor din interfa\u021b\u0103"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-verilog"},"wire [4:0] out1;\nwire [4:0] out2;\nwire [2:0] a;\nwire [1:0] b;\n\nmy_beautiful_parameterized_module #(.a_width(3),\n                                    .b_width(2),\n                                    .out_width(5)) inst2(out, a, b);\n\n// Sau, men\u021bin\xe2ndu-se ordinea parametrilor, doar prin specificarea noilor // dimensiuni:\n\nmy_beautiful_parameterized_module #(3, 2, 5) inst3(out, a, b);\n")),(0,i.yg)("h2",{id:"macro-define"},"Macro: `define"),(0,i.yg)("p",null,"Un macro este un nume c\u0103ruia i se poate asocia o valoare \xeenainte de compilarea codului. Macro-urile sunt utile pe post de aliasuri, f\u0103r\u0103 a utiliza resursele compilatorului. Acestea nu sunt variabile, prin urmare nu pot fi atribuite valori unui macro \xeen timpul simul\u0103rii. Majoritatea limbajelor de programare, inclusiv Verilog suport\u0103 definirea de macrouri."),(0,i.yg)("p",null,"\xcen Verilog, un macro este specificat cu ajutorul directivei de compilator ",(0,i.yg)("strong",{parentName:"p"},"`define"),". Aceasta \xeenlocuie\u0219te textul definit cu o valoare specific\u0103. Un nume de tip ",(0,i.yg)("inlineCode",{parentName:"p"},"define este un macro global, \xeensemn\xe2nd c\u0103 dac\u0103 este declarat \xeentr-un modul, va r\u0103m\xe2ne declarat \u0219i la ie\u0219irea din modul. Dup\u0103 ce macroul este declarat, poate fi apelat \xeen cod cu ajutorul caracterului ")," (back-tic). Indiferent dac\u0103 sunt declarate \xeen interiorul sau \xeen afara unui modul, compilatorul le trateaz\u0103 la fel."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-verilog"},"`define MY_NUMBER 5\n`define MY_STRING \u201cHello world!\u201d\n`define ADD2PLUS2 2 + 2  \n")))}d.isMDXComponent=!0}}]);