"use strict";(self.webpackChunkcomputer_architecture=self.webpackChunkcomputer_architecture||[]).push([[5154],{5680:(e,t,a)=>{a.d(t,{xA:()=>c,yg:()=>g});var r=a(6540);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var u=r.createContext({}),s=function(e){var t=r.useContext(u),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,u=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=s(a),d=n,g=m["".concat(u,".").concat(d)]||m[d]||p[d]||i;return a?r.createElement(g,o(o({ref:t},c),{},{components:a})):r.createElement(g,o({ref:t},c))}));function g(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=d;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[m]="string"==typeof e?e:n,o[1]=l;for(var s=2;s<i;s++)o[s]=a[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},2592:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var r=a(8168),n=(a(6540),a(5680));const i={},o="Automate de st\u0103ri",l={unversionedId:"Lab4 - Verilog/Automate finite/Lectura/README",id:"Lab4 - Verilog/Automate finite/Lectura/README",title:"Automate de st\u0103ri",description:"Automatele de st\u0103ri sunt absolut necesare \xeen implementarea oric\u0103rui circuit digital. Exist\u0103 dou\u0103 tipuri de automate de st\u0103ri, clasificate dup\u0103 tipurile de ie\u0219iri generate de fiecare. Primul tip este Ma\u0219ina Mealy, caracterizat\u0103 de faptul c\u0103 una sau mai multe ie\u0219iri depind at\xe2t de starea curent\u0103, c\xe2t \u0219i de una sau mai multe intr\u0103ri, iar al doilea este Ma\u0219ina Moore, ale c\u0103rei ie\u0219iri sunt doar o func\u021bie care depinde doar de starea curent\u0103.",source:"@site/docs/Lab4 - Verilog/Automate finite/Lectura/README.md",sourceDirName:"Lab4 - Verilog/Automate finite/Lectura",slug:"/Lab4 - Verilog/Automate finite/Lectura/",permalink:"/computer-architecture/Lab4 - Verilog/Automate finite/Lectura/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Automate finite",permalink:"/computer-architecture/Lab4 - Verilog/Automate finite/"},next:{title:"Memorie",permalink:"/computer-architecture/Lab4 - Verilog/Memorie/"}},u={},s=[{value:"Ma\u0219ina Mealy",id:"ma\u0219ina-mealy",level:2},{value:"Exemplu de automat de st\u0103ri Mealy:",id:"exemplu-de-automat-de-st\u0103ri-mealy",level:3},{value:"Ma\u0219ina Moore",id:"ma\u0219ina-moore",level:2},{value:"Exemplu de automat de st\u0103ri Moore:",id:"exemplu-de-automat-de-st\u0103ri-moore",level:3}],c={toc:s},m="wrapper";function p(e){let{components:t,...i}=e;return(0,n.yg)(m,(0,r.A)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"automate-de-st\u0103ri"},"Automate de st\u0103ri"),(0,n.yg)("p",null,"Automatele de st\u0103ri sunt absolut necesare \xeen implementarea oric\u0103rui circuit digital. Exist\u0103 dou\u0103 tipuri de automate de st\u0103ri, clasificate dup\u0103 tipurile de ie\u0219iri generate de fiecare. Primul tip este ",(0,n.yg)("strong",{parentName:"p"},"Ma\u0219ina Mealy,")," caracterizat\u0103 de faptul c\u0103 una sau mai multe ie\u0219iri depind at\xe2t de starea curent\u0103, c\xe2t \u0219i de una sau mai multe intr\u0103ri, iar al doilea este ",(0,n.yg)("strong",{parentName:"p"},"Ma\u0219ina Moore"),", ale c\u0103rei ie\u0219iri sunt doar o func\u021bie care depinde doar de starea curent\u0103."),(0,n.yg)("h2",{id:"ma\u0219ina-mealy"},"Ma\u0219ina Mealy"),(0,n.yg)("p",null,"Un model general al unei ma\u0219ini secven\u021biale Mealy este format dintr-o re\u021bea combina\u021bional\u0103 care genereaz\u0103 ie\u0219irile, starea urm\u0103toare \u0219i o stare \u201cCurrent State Register\u201d reprezent\xe2nd starea curent\u0103, ca \xeen figura de mai jos. Starea \u201cCurrent State Register\u201d este modelat\u0103 utiliz\xe2nd bistabili D \u0219i este sensibil\u0103 la semnalul de ceas (Clock). At\xe2t ie\u0219irea, c\xe2t \u0219i determinarea st\u0103rii urm\u0103toare depind de intrare \u0219i de starea curent\u0103."),(0,n.yg)("p",null,(0,n.yg)("img",{alt:"Mealy",src:a(8922).A,width:"512",height:"192"})),(0,n.yg)("p",null,(0,n.yg)("em",{parentName:"p"},"Figure: Mealy")),(0,n.yg)("h3",{id:"exemplu-de-automat-de-st\u0103ri-mealy"},"Exemplu de automat de st\u0103ri Mealy:"),(0,n.yg)("p",null,(0,n.yg)("img",{alt:"Exemplu Mealy",src:a(3940).A,width:"512",height:"210"})),(0,n.yg)("p",null,(0,n.yg)("em",{parentName:"p"},"Figure: Exemplu Mealy")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-v"},"module mealy_fsm(\n    output reg parity,\n    input clk,\n    input reset,\n    input x);\n    \n    reg state, next_state;\n    parameter S0=0;\n    parameter S1=1;\n\n    // Partea secven\u021bial\u0103\n    always @(posedge clk or negedge reset)\n        if (!reset)\n            state <= S0;\n        else\n            state <= next_state;\n\n    // Partea combina\u021bional\u0103\n    always @(*) begin\n        parity = 1'b0;\n        case(state)\n            S0: \n                if(x) \n                    next_state = S1;\n                else\n                    next_state = S0;\n            S1: \n                if(x) begin\n                    parity = 1;\n                    next_state = S0;\n                end\n                else begin\n                    parity = 1;\n                    next_state = S1;\n                end\n            default:\n                next_state = S0;\n        endcase\n    end\nendmodule\n")),(0,n.yg)("h2",{id:"ma\u0219ina-moore"},"Ma\u0219ina Moore"),(0,n.yg)("p",null,"Un model general al unei ma\u0219ini secven\u021biale Moore este prezentat mai jos. Ie\u0219irea sa este dependent\u0103 doar de blocul st\u0103rii curente, iar starea urm\u0103toare este determinat\u0103 pe baza intr\u0103rii \u0219i a st\u0103rii curente. \xcen schema de mai jos, starea \u201cCurrent State Register\u201d este modelat\u0103 utiliz\xe2nd bistabili D. Ma\u0219inile Moore obi\u0219nuite sunt descrise prin intermediul a trei blocuri, dintre care unul con\u021bine logic\u0103 secven\u021bial\u0103, iar celelalte dou\u0103 con\u021bin logic\u0103 de tip combina\u021bional\u0103."),(0,n.yg)("p",null,(0,n.yg)("img",{alt:"Moore",src:a(1144).A,width:"512",height:"120"})),(0,n.yg)("p",null,(0,n.yg)("em",{parentName:"p"},"Figure: Moore")),(0,n.yg)("h3",{id:"exemplu-de-automat-de-st\u0103ri-moore"},"Exemplu de automat de st\u0103ri Moore:"),(0,n.yg)("p",null,(0,n.yg)("img",{alt:"Exemplu Moore",src:a(9080).A,width:"512",height:"210"})),(0,n.yg)("p",null,(0,n.yg)("em",{parentName:"p"},"Figure: Exemplu Moore")),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-verilog"},"module moore_fsm(\n    output reg parity,\n    input clk,\n    input reset,\n    input x);\n    \n    reg state, next_state;\n    parameter S0=0;\n    parameter S1=1;\n\n     // Partea secven\u021bial\u0103\n    always @(posedge clk or negedge reset)\n        if (!reset)\n            state <= S0;\n        else\n            state <= next_state;\n\n    always @(*) begin\n        case(state)\n            S0: begin\n                parity = 0;\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                parity = 1;\n                if(!x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n        endcase\n    end\nendmodule\n")))}p.isMDXComponent=!0},3940:(e,t,a)=>{a.d(t,{A:()=>r});const r=a.p+"assets/images/ex-mealy-3fbf596fa39fb4a4d29cb2d31ac3c143.jpg"},8922:(e,t,a)=>{a.d(t,{A:()=>r});const r=a.p+"assets/images/mealy-b4237f67488a2019094a7a1c73ca0dae.jpg"},9080:(e,t,a)=>{a.d(t,{A:()=>r});const r=a.p+"assets/images/moore-ex-9c428978647beb901ac573c7ba9b6cdc.jpg"},1144:(e,t,a)=>{a.d(t,{A:()=>r});const r=a.p+"assets/images/moore-fab522b275b671ed4b4f242a8865cf11.jpg"}}]);