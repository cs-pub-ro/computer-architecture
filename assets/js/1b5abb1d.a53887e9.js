"use strict";(self.webpackChunkcomputer_architecture=self.webpackChunkcomputer_architecture||[]).push([[943],{5680:(e,a,r)=>{r.d(a,{xA:()=>p,yg:()=>d});var i=r(6540);function t(e,a,r){return a in e?Object.defineProperty(e,a,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[a]=r,e}function n(e,a){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);a&&(i=i.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),r.push.apply(r,i)}return r}function l(e){for(var a=1;a<arguments.length;a++){var r=null!=arguments[a]?arguments[a]:{};a%2?n(Object(r),!0).forEach((function(a){t(e,a,r[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(r,a))}))}return e}function o(e,a){if(null==e)return{};var r,i,t=function(e,a){if(null==e)return{};var r,i,t={},n=Object.keys(e);for(i=0;i<n.length;i++)r=n[i],a.indexOf(r)>=0||(t[r]=e[r]);return t}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)r=n[i],a.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var u=i.createContext({}),m=function(e){var a=i.useContext(u),r=a;return e&&(r="function"==typeof e?e(a):l(l({},a),e)),r},p=function(e){var a=m(e.components);return i.createElement(u.Provider,{value:a},e.children)},c="mdxType",s={inlineCode:"code",wrapper:function(e){var a=e.children;return i.createElement(i.Fragment,{},a)}},g=i.forwardRef((function(e,a){var r=e.components,t=e.mdxType,n=e.originalType,u=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=m(r),g=t,d=c["".concat(u,".").concat(g)]||c[g]||s[g]||n;return r?i.createElement(d,l(l({ref:a},p),{},{components:r})):i.createElement(d,l({ref:a},p))}));function d(e,a){var r=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var n=r.length,l=new Array(n);l[0]=g;var o={};for(var u in a)hasOwnProperty.call(a,u)&&(o[u]=a[u]);o.originalType=e,o[c]="string"==typeof e?e:t,l[1]=o;for(var m=2;m<n;m++)l[m]=r[m];return i.createElement.apply(null,l)}return i.createElement.apply(null,r)}g.displayName="MDXCreateElement"},7085:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>u,contentTitle:()=>l,default:()=>s,frontMatter:()=>n,metadata:()=>o,toc:()=>m});var i=r(8168),t=(r(6540),r(5680));const n={},l="Exerci\u021bii",o={unversionedId:"Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103/README",id:"Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103/README",title:"Exerci\u021bii",description:"Seven-segment display",source:"@site/docs/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103/README.md",sourceDirName:"Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103",slug:"/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103/",permalink:"/computer-architecture/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Practic\u0103/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Descrierea comportamental\u0103",permalink:"/computer-architecture/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Teorie/"},next:{title:"4 Verilog Secven\u021bial",permalink:"/computer-architecture/Laboratoare/4 Verilog Secven\u021bial/"}},u={},m=[{value:"Seven-segment display",id:"seven-segment-display",level:2}],p={toc:m},c="wrapper";function s(e){let{components:a,...n}=e;return(0,t.yg)(c,(0,i.A)({},p,n,{components:a,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"exerci\u021bii"},"Exerci\u021bii"),(0,t.yg)("h2",{id:"seven-segment-display"},"Seven-segment display"),(0,t.yg)("p",null,"Acest tip de dispozitiv de afi\u0219are este alc\u0103tuit, a\u0219a cum v\u0103 pute\u021bi da seama \u0219i din numele acestuia, din 7 segmente controlabile individual. A\u0219adar, putem aprinde (1 logic) sau stinge (0 logic) fiecare segment din componen\u021ba acestuia."),(0,t.yg)("p",null,(0,t.yg)("img",{alt:"Reprezentarea numerelor \xeen format hexazecimal consider\xe2nd un afi\u0219aj cu 7 segmente",src:r(6197).A,width:"506",height:"512"})),(0,t.yg)("p",null,(0,t.yg)("em",{parentName:"p"},"Figure: Reprezentarea numerelor \xeen format hexazecimal consider\xe2nd un afi\u0219aj cu 7 segmente")),(0,t.yg)("p",null,"De exemplu, dac\u0103 dorim s\u0103 afi\u0219\u0103m cifra 6, ie\u0219irea noastr\u0103 va avea valoarea ''7\u2019b111_1101''."),(0,t.yg)("p",null,"Pentru mai multe detalii asupra acestui tip de modul, consulta\u021bi pagina de ",(0,t.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Seven-segment_display"},"Wiki"),"."),(0,t.yg)("p",null,"Pentru implementarea exerci\u021biilor se vor utiliza scheletele de cod din arhiva laboratorului. Scheletele de cod con\u021bin deja un proiect Xilinx ISE, iar unele din ele \u0219i un modul de testare. Urm\u0103ri\u021bi cerin\u021ba \u0219i zonele marcate cu TODO."),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"(4p)")," Implementa\u021bi \u0219i simula\u021bi un ",(0,t.yg)("strong",{parentName:"li"},"multiplicator pe 4 bi\u021bi")," f\u0103r\u0103 a folosi operatorul * (\xeenmul\u021bire).",(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("em",{parentName:"li"},"Hint"),": Folosi\u021bi conven\u021bia Verilog pentru interfa\u021ba modulului. C\xe2\u021bi bi\u021bi are ie\u0219irea? "),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("em",{parentName:"li"},"Hint"),": \xcenmul\u021bi\u021bi pe h\xe2rtie, \xeen baza 2, numerele 1001 \u0219i 1011. Transpune\u021bi \xeen limbajul Verilog algoritmul folosit."))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"(2p)")," Implementa\u021bi \u0219i simula\u021bi un modul de ",(0,t.yg)("strong",{parentName:"li"},"afi\u0219aj cu 7 segmente")," pentru numere \xeen baza 10.",(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("em",{parentName:"li"},"Hint"),": Exist\u0103 o ie\u0219ire valid\u0103 pentru fiecare intrare? Nu uita\u021bi de cazul ''default''. "),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("em",{parentName:"li"},"Hint"),": Se vor testa doar cifrele de la 0 la 9."))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"(4p)")," Implementa\u021bi o ",(0,t.yg)("strong",{parentName:"li"},"unitate aritmetico-logic\u0103")," simpl\u0103 (UAL), pe ",(0,t.yg)("strong",{parentName:"li"},"4")," bi\u021bi, cu 2 opera\u021bii: adunare \u0219i \xeenmul\u021bire. Folosi\u021bi o intrare de selec\u021bie de 1 bit pentru a alege \xeentre cele dou\u0103 opera\u021bii astfel: 0 - adunare, 1 - \xeenmul\u021bire.",(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("em",{parentName:"li"},"Hint"),": C\xe2\u021bi bi\u021bi au ie\u0219irea sumatorului \u0219i a multiplicatorului? Dar a UAL-ului? "),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("em",{parentName:"li"},"Hint"),": Pentru selec\u021bia dintre ie\u0219irea sumatorului \u0219i cea a multiplicatorului se poate folosi atribuirea continu\u0103 sau se poate implementa un modul multiplexor 2:1 "))),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"(3p)"),": Pentru o utilizare mai general\u0103, implementa\u021bi un UAL cu operatori cu dimensiune variabil\u0103. ",(0,t.yg)("ul",{parentName:"li"},(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("em",{parentName:"li"},"Hint"),": Pentru a-l implementa, este necesar\u0103 implementarea unui multiplicator parametrizat - aten\u021bie la dimensiunea semnalelor!")))))}s.isMDXComponent=!0},6197:(e,a,r)=>{r.d(a,{A:()=>i});const i=r.p+"assets/images/7seg-40188e007b1db4de8a3ea7e696a21be7.png"}}]);