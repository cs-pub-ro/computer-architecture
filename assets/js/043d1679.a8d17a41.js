"use strict";(self.webpackChunkcomputer_architecture=self.webpackChunkcomputer_architecture||[]).push([[4043],{5680:(e,a,i)=>{i.d(a,{xA:()=>m,yg:()=>g});var r=i(6540);function t(e,a,i){return a in e?Object.defineProperty(e,a,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[a]=i,e}function n(e,a){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter(function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable})),i.push.apply(i,r)}return i}function l(e){for(var a=1;a<arguments.length;a++){var i=null!=arguments[a]?arguments[a]:{};a%2?n(Object(i),!0).forEach(function(a){t(e,a,i[a])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):n(Object(i)).forEach(function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(i,a))})}return e}function o(e,a){if(null==e)return{};var i,r,t=function(e,a){if(null==e)return{};var i,r,t={},n=Object.keys(e);for(r=0;r<n.length;r++)i=n[r],a.indexOf(i)>=0||(t[i]=e[i]);return t}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)i=n[r],a.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(t[i]=e[i])}return t}var u=r.createContext({}),c=function(e){var a=r.useContext(u),i=a;return e&&(i="function"==typeof e?e(a):l(l({},a),e)),i},m=function(e){var a=c(e.components);return r.createElement(u.Provider,{value:a},e.children)},p="mdxType",s={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},d=r.forwardRef(function(e,a){var i=e.components,t=e.mdxType,n=e.originalType,u=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=c(i),d=t,g=p["".concat(u,".").concat(d)]||p[d]||s[d]||n;return i?r.createElement(g,l(l({ref:a},m),{},{components:i})):r.createElement(g,l({ref:a},m))});function g(e,a){var i=arguments,t=a&&a.mdxType;if("string"==typeof e||t){var n=i.length,l=new Array(n);l[0]=d;var o={};for(var u in a)hasOwnProperty.call(a,u)&&(o[u]=a[u]);o.originalType=e,o[p]="string"==typeof e?e:t,l[1]=o;for(var c=2;c<n;c++)l[c]=i[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,i)}d.displayName="MDXCreateElement"},7615:(e,a,i)=>{i.r(a),i.d(a,{assets:()=>u,contentTitle:()=>l,default:()=>s,frontMatter:()=>n,metadata:()=>o,toc:()=>c});var r=i(8168),t=(i(6540),i(5680));const n={},l="Descrierea comportamental\u0103",o={unversionedId:"Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Teorie/README",id:"Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Teorie/README",title:"Descrierea comportamental\u0103",description:"\xcen laboratoarele anterioare am studiat descrierea structural\u0103, folosind primitive, precum \u0219i descrierea comportamental\u0103, folosind atribuiri continue. Am remarcat faptul c\u0103 generalizarea modulelor folosind parametri conduce la o capacitate de reutilizare mai mare, cu schimb\u0103ri minime. Cu toate acestea, solu\u021biile prezentate nu sunt pretabile func\u021biilor complexe, \xeentruc\xe2t ele devin complicat de implementat sau de urm\u0103rit, \xeen momentul c\xe2nd este g\u0103sit un bug \xeen cod.",source:"@site/docs/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Teorie/README.md",sourceDirName:"Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Teorie",slug:"/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Teorie/",permalink:"/computer-architecture/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/Teorie/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Descriere Comportamentala",permalink:"/computer-architecture/Laboratoare/3 Verilog Combina\u021bional/Descriere Comportamentala/"},next:{title:"4 Verilog Secven\u021bial",permalink:"/computer-architecture/Laboratoare/4 Verilog Secven\u021bial/"}},u={},c=[{value:"Tipul reg",id:"tipul-reg",level:2},{value:"Exemplu declarare variabil\u0103 de tip reg",id:"exemplu-declarare-variabil\u0103-de-tip-reg",level:3},{value:"Construc\u021bii de control",id:"construc\u021bii-de-control",level:2},{value:"Blocul always@",id:"blocul-always",level:2},{value:"Exemplu declarare list\u0103 de senzitivitate",id:"exemplu-declarare-list\u0103-de-senzitivitate",level:3},{value:"Exemplu sumator descris comportamental, folosind always@",id:"exemplu-sumator-descris-comportamental-folosind-always",level:3},{value:"Exemplu declarare variabil\u0103 de tip reg \xeen interiorul blocului always",id:"exemplu-declarare-variabil\u0103-de-tip-reg-\xeen-interiorul-blocului-always",level:3}],m={toc:c},p="wrapper";function s({components:e,...a}){return(0,t.yg)(p,(0,r.A)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,t.yg)("h1",{id:"descrierea-comportamental\u0103"},"Descrierea comportamental\u0103"),(0,t.yg)("p",null,"\xcen laboratoarele anterioare am studiat descrierea structural\u0103, folosind primitive, precum \u0219i descrierea comportamental\u0103, folosind atribuiri continue. Am remarcat faptul c\u0103 generalizarea modulelor folosind parametri conduce la o capacitate de reutilizare mai mare, cu schimb\u0103ri minime. Cu toate acestea, solu\u021biile prezentate nu sunt pretabile func\u021biilor complexe, \xeentruc\xe2t ele devin complicat de implementat sau de urm\u0103rit, \xeen momentul c\xe2nd este g\u0103sit un bug \xeen cod."),(0,t.yg)("p",null,"In continuare vom trece prin elementele Verilog folosite pentru descrierea comportamental\u0103 la nivel procedural, ce se vor axa \xeen continuare pe conceptul de \u201c",(0,t.yg)("strong",{parentName:"p"},"ce face")," circuitul\u201d.  Se folosesc construc\u021bii de nivel \xeenalt, similare altor limbaje de programare \xeent\xe2lnite p\xe2n\u0103 \xeen prezent, prin care putem descrie mai facil algoritmul care calculeaz\u0103 ie\u0219irile circuitului."),(0,t.yg)("h2",{id:"tipul-reg"},"Tipul reg"),(0,t.yg)("p",null,"\xcen primele laboratoare a fost prezentat tipul ",(0,t.yg)("em",{parentName:"p"},"wire")," pentru reprezentarea semnalelor din interiorul modulelor. Porturile unui modul erau ",(0,t.yg)("em",{parentName:"p"},"wires"),", la fel \u0219i semnalele de leg\u0103tur\u0103 dintre instan\u021bele primitivelor \u0219i por\u021bilor. Deoarece acestea realizeaz\u0103 conexiuni, nu au o stare \u0219i nu li se pot atribui valori. Pentru a putea re\u021bine st\u0103ri/valori \u0219i a face atribuiri avem nevoie de tipul ",(0,t.yg)("strong",{parentName:"p"},"reg"),". "),(0,t.yg)("p",null,"Declararea variabilelor de tip reg se poate face \xeentr-un mod similar variabilelor de tip wire, cum este exemplificat \u0219i mai jos:"),(0,t.yg)("h3",{id:"exemplu-declarare-variabil\u0103-de-tip-reg"},"Exemplu declarare variabil\u0103 de tip reg"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"reg x;\nreg[7:0] m; \nreg[0:4] n;\nreg[7:0] a [3:0]; // array multidimensional cu 4 elemente de 8 biti\n")),(0,t.yg)("p",null,"Declararea unei variabile de tip reg (deci o variabil\u0103 de tip registru \xeen Verilog) ",(0,t.yg)("strong",{parentName:"p"},"nu")," implic\u0103 sinteza unui registru hardware!"),(0,t.yg)("h2",{id:"construc\u021bii-de-control"},"Construc\u021bii de control"),(0,t.yg)("p",null,"\xcen afar\u0103 de folosirea atribuirilor continue, circuitele pot fi descrise comportamental \u0219i prin blocuri always. \xcen interiorul acestora se pot folosi construc\u021bii de limbaj similare celor din limbajele procedurale."),(0,t.yg)("p",null,"Construc\u021biile de repeti\u021bie sunt sintetizabile doar dac\u0103 ele au un num\u0103r ",(0,t.yg)("strong",{parentName:"p"},"fix")," de itera\u021bii. Trebuie acordat\u0103 o deosebit\u0103 aten\u021bie \xeen momentul \xeen care se implementeaz\u0103 structuri repetitive utiliz\xe2nd ",(0,t.yg)("em",{parentName:"p"},"while")," sau ",(0,t.yg)("em",{parentName:"p"},"repeat"),", acestea fiind mult mai susceptibile la gre\u0219eli de implementare care vor genera, \xeen final, un cod simulabil, dar nesintetizabil."),(0,t.yg)("table",null,(0,t.yg)("thead",{parentName:"table"},(0,t.yg)("tr",{parentName:"thead"},(0,t.yg)("th",{parentName:"tr",align:null},"Cod Verilog"),(0,t.yg)("th",{parentName:"tr",align:null},"Cod C"))),(0,t.yg)("tbody",{parentName:"table"},(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"if (sig == 0) begin a = 2; end else if (sig == 1 ) begin a = 1; end else begin a = 0; end")),(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"if (sig == 0) { a = 2; } else if (sig == 1) { a = 1; } else { a = 0; }"))),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"case (sig) 'b0: a = 2; 'b1: a = 1; default: a = 0; endcase")),(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"switch (sig) { case 0: a = 2; break; case 1: a = 1; break; default: a = 0; }"))),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"for (i = 0; i < 10; i = i + 1) begin a = a / 2; end")),(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"for (i = 0; i < 10; i = i + 1) { a = a / 2; }"))),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"i = 0; while (i < 10) begin a = a / 2; i = i + 1; end")),(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"i = 0; while (i < 10) { a = a / 2; i = i + 1; }"))),(0,t.yg)("tr",{parentName:"tbody"},(0,t.yg)("td",{parentName:"tr",align:null},(0,t.yg)("inlineCode",{parentName:"td"},"repeat (10) begin a = a / 2; end")),(0,t.yg)("td",{parentName:"tr",align:null})))),(0,t.yg)("h2",{id:"blocul-always"},"Blocul always@"),(0,t.yg)("p",null,"Blocurile ",(0,t.yg)("em",{parentName:"p"},"always")," descriu un comportament ciclic, codul acestora fiind executat \xeen continuu. Prezen\u021ba operatorului ",(0,t.yg)("em",{parentName:"p"},"@")," face ca blocul s\u0103 se \u201cexecute\u201d doar la apari\u021bia unor evenimente. Evenimentele sunt reprezentate de modificarea unuia sau mai multor semnale."),(0,t.yg)("p",null,"\xcen cadrul acestui laborator ne ax\u0103m doar pe descrierea circuitelor combina\u021bionale \u0219i vom folosi doar blocuri ''always @(",(0,t.yg)("em",{parentName:"p"},")'', unde ("),") se nume\u0219te ",(0,t.yg)("strong",{parentName:"p"},"sensitivity list"),". Folosirea wildcard-ului * implic\u0103 \u201cexecu\u021bia\u201d blocului ",(0,t.yg)("em",{parentName:"p"},"always")," la orice eveniment de modificare a oric\u0103rui semnal folosit \xeen cadrul blocului."),(0,t.yg)("p",null,"Instruc\u021biunile din blocul ",(0,t.yg)("em",{parentName:"p"},"always")," sunt \xeencadrate \xeentre cuvintele cheie ''begin'' \u0219i ''end'' \u0219i sunt \u201cexecutate\u201d secven\u021bial atunci c\xe2nd blocul este activat. "),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"always @(*) begin\n   b = 0;     // registrul b este ini\u021bializat cu 0 la orice\n              // modificare a unui semnal\n   c = b ^ a; // registrul c va primi valoarea expresiei din dreapta\n              // la orice modificare a unui semnal (nu doar a sau b)\nend\n")),(0,t.yg)("p",null,"\xcen locul wildcard-ului *, sensitivity list-ul poate con\u021bine o list\u0103 de semnale la modificarea c\u0103rora blocul ",(0,t.yg)("em",{parentName:"p"},"always")," s\u0103 fie activat. Acestea se declar\u0103 prin numele lor, folosind or sau , pentru a le separa. "),(0,t.yg)("p",null,"Este foarte important ca lista de semnale dat\u0103 unui bloc ",(0,t.yg)("em",{parentName:"p"},"always@")," s\u0103 fie ",(0,t.yg)("strong",{parentName:"p"},"complet\u0103"),", altfel nu toate combina\u021biile de intr\u0103ri sunt acoperite \u0219i unele variabile pot r\u0103m\xe2ne neatribuite corespunz\u0103tor. Pentru a evita astfel de erori se recomand\u0103 folosirea wildcard-ului *."),(0,t.yg)("h3",{id:"exemplu-declarare-list\u0103-de-senzitivitate"},"Exemplu declarare list\u0103 de senzitivitate"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"always @(a or b or c) // sintaxa Verilog-1995\nalways @(a, b, c)     // sintaxa Verilog-2001, 2005\nalways @(a, b or c)   // permis dar nerecomandat, \xeengreuneaz\u0103\n                      // lizibilitatea codului\nalways @(*)           // toate semnalele din modul (intr\u0103ri +\n                      // wires declarate \xeen modul)\n")),(0,t.yg)("p",null,"\xcen modulul urm\u0103tor care implementeaz\u0103 o poart\u0103 xor, ie\u0219irea out se va schimba doar c\xe2nd semnalul a se schimb\u0103, ceea ce duce la un comportament incorect care nu ia \xeen considerare \u0219i schimbarea lui b. \xcen plus, modulul generat nu va fi unul combina\u021bional, deoarece este nevoie de memorie pentru a men\u021bine starea ie\u0219irii atunci c\xe2nd b se modific\u0103."),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"module my_xor(output reg out, input a, input b);\n    always @(a) begin\n        out = a ^ b;\n    end\nendmodule\n")),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Nu")," se pot instan\u021bia primitive \u0219i module \xeen interiorul blocurilor ",(0,t.yg)("em",{parentName:"p"},"always")," \u0219i ",(0,t.yg)("em",{parentName:"p"},"initial"),"."),(0,t.yg)("p",null,"\xcen cadrul blocurilor ",(0,t.yg)("em",{parentName:"p"},"initial")," \u0219i ",(0,t.yg)("em",{parentName:"p"},"always")," atribuirile pot fi de dou\u0103 feluri, cu semantici diferite:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Atribuiri blocante"),": sunt folosite pentru descrierea logicii combina\u021bionale (por\u021bi logice). Atribuirile blocante sunt interpretate ca execut\xe2ndu-se secven\u021bial, semantica fiind identic\u0103 cu cea din limbajele de programare procedurale."),(0,t.yg)("li",{parentName:"ul"},(0,t.yg)("strong",{parentName:"li"},"Atribuiri non-blocante"),": sunt folosite pentru descrierea logicii secven\u021biale (ne vom \xeent\xe2lni cu ele \xeen laboratorul urm\u0103tor).")),(0,t.yg)("p",null,"\xcen Verilog putem declara variabile de tipul ",(0,t.yg)("em",{parentName:"p"},"reg")," \u0219i ",(0,t.yg)("em",{parentName:"p"},"wire")," pentru a crea circuite combina\u021bionale. Atunci c\xe2nd se fac atribuirile exist\u0103 totu\u0219i urm\u0103toarele restric\u021bii:"),(0,t.yg)("ul",null,(0,t.yg)("li",{parentName:"ul"},"Pe o variabil\u0103 de tip ",(0,t.yg)("strong",{parentName:"li"},"wire")," nu putem face dec\xe2t ",(0,t.yg)("strong",{parentName:"li"},"atribuiri continue")," (",(0,t.yg)("em",{parentName:"li"},"assign"),"). Acestea trebuie s\u0103 fie ",(0,t.yg)("strong",{parentName:"li"},"\xeen exteriorul blocurilor")," always sau initial. Valoarea atribuit\u0103 poate fi o constant\u0103, o expresie, valoarea unui fir sau a unui registru."),(0,t.yg)("li",{parentName:"ul"},"Pe o variabil\u0103 de tip ",(0,t.yg)("strong",{parentName:"li"},"reg")," putem face doar ",(0,t.yg)("strong",{parentName:"li"},"atribuiri blocante/non-blocante"),". Acestea trebuie s\u0103 fie ",(0,t.yg)("strong",{parentName:"li"},"\xeen interiorul")," unui bloc initial sau always. Valoarea atribuit\u0103 poate fi o constant\u0103, o expresie, valoarea unui fir sau a unui registru. ")),(0,t.yg)("h3",{id:"exemplu-sumator-descris-comportamental-folosind-always"},"Exemplu sumator descris comportamental, folosind always@"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"module my_module(\n    output reg[4:0] o, // o trebuie sa fie reg pentru a o putea atribui\n                       // \xeen blocul always\n    input[3:0] a, b);\n\n    reg[2:0] i;        // poate fi maxim 7; noi avem nevoie de maxim 4\n    reg c;             // \u021binem minte transportul\n\n    always @(*) begin\n        i = 0; // la orice modificare a intr\u0103rilor, i va fi ini\u021bial 0\n        c = 0; // transportul initial este 0\n    \n        // to\u021bi bi\u021bii lui o sunt recalculati la modificarea intr\u0103rilor\n        for (i = 0; i < 4; i = i + 1) begin\n            {c, o[i]} = a[i] + b[i] + c;\n        end\n        o[4] = c;\n    end\nendmodule\n")),(0,t.yg)("p",null,"Pentru ca un bloc ",(0,t.yg)("em",{parentName:"p"},"always")," s\u0103 fie sintetizat \xeentr-un circuit combina\u021bional este necesar ca orice \u201cexecu\u021bie\u201d a blocului s\u0103 atribuie cel pu\u021bin o valoare pentru fiecare ie\u0219ire a modulului."),(0,t.yg)("p",null,"Bine\xeen\u021beles, acea valoare nu poate fi calculat\u0103 pe baza ie\u0219irilor sau valorilor anterioare ale variabilelor din interiorul modulului. Asta ar \xeensemna c\u0103 este necesar\u0103 o memorie pentru a men\u021bine acele valori, transform\xe2nd circuitul \xeentr-unul secven\u021bial."),(0,t.yg)("p",null,(0,t.yg)("strong",{parentName:"p"},"Nu")," este recomandat\u0103 declararea variabilelor de tip reg \xeen interiorul blocurilor de tip ",(0,t.yg)("em",{parentName:"p"},"always")," sau ",(0,t.yg)("em",{parentName:"p"},"initial"),". \xcen Verilog ea este totu\u0219i posibil\u0103, dac\u0103 blocul respectiv are un tag asociat. Variabila astfel declarat\u0103 va avea vizibilitate doar \xeen interiorul blocului."),(0,t.yg)("h3",{id:"exemplu-declarare-variabil\u0103-de-tip-reg-\xeen-interiorul-blocului-always"},"Exemplu declarare variabil\u0103 de tip reg \xeen interiorul blocului always"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-verilog"},"always @(*) begin :my_tag\n    reg x;\n    x = in1 ^ in2;\nend\n")))}s.isMDXComponent=!0}}]);